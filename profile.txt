*** File /home/tyler/Desktop/fland2/drules.h:
                #ifndef D_RULES_H
                #define D_RULES_H
                
                #include "descriminatoryr.h"
                #include <string>
                
                #include "baserule.h"
                #include "fmlparser.h"
                #include "tyler.h"
                #include "defines.h"
                #include "perlinnoise.h"
                
                /*
                	NOTE - To add a new rule here do these things:
                
                	- add the class definition here (copy and paste)
                	- add the function in drules.cpp
                	- go into fmlparser and add the rule to evaluateRule()
                */
                
                // PatternR
                class PatternR : public DescriminatoryR
                {
                    public:
                    intensityType size;
                    PerlinNoise noise;
                    PatternR();
                	virtual string assignValue( string valueType, istringstream *value, FmlParser* fPtr );
                    virtual intensityType getSecondRegionIntensity( BaseEnt* inClient );
                };
                
                //AltitudeR
                class AltitudeR : public DescriminatoryR
       ##### -> {
                	public:
                	virtual intensityType getSecondRegionIntensity( BaseEnt* inClient );
                };
                
                //SlopeR
                class SlopeR : public DescriminatoryR
           2 -> {
                	public:
                	virtual intensityType getSecondRegionIntensity( BaseEnt* inClient );
                };
                
                // SlopeXAltitudeR
                class SlopeXAltitudeR : public DescriminatoryR
       ##### -> {
                	public:
                	virtual intensityType getSecondRegionIntensity( BaseEnt* inClient );
                };
                
                #endif
                


Top 10 Lines:

     Line      Count

       41          2

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     0.67   Average executions per line


*** File /usr/lib/gcc/i486-linux-gnu/4.1.2/../../../../include/c++/4.1.2/bits/basic_string.h:
                // Components for manipulating sequences of characters -*- C++ -*-
                
                // Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
                // Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 2, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // You should have received a copy of the GNU General Public License along
                // with this library; see the file COPYING.  If not, write to the Free
                // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
                // USA.
                
                // As a special exception, you may use this file as part of a free software
                // library without restriction.  Specifically, if other files instantiate
                // templates or use macros or inline functions from this file, or you compile
                // this file and link it with other files to produce an executable, this
                // file does not by itself cause the resulting executable to be covered by
                // the GNU General Public License.  This exception does not however
                // invalidate any other reasons why the executable file might be covered by
                // the GNU General Public License.
                
                //
                // ISO C++ 14882: 21 Strings library
                //
                
                /** @file basic_string.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _BASIC_STRING_H
                #define _BASIC_STRING_H 1
                
                #pragma GCC system_header
                
                #include <bits/atomicity.h>
                #include <debug/debug.h>
                
                namespace std
                {
                  /**
                   *  @class basic_string basic_string.h <string>
                   *  @brief  Managing sequences of characters and character-like objects.
                   *
                   *  @ingroup Containers
                   *  @ingroup Sequences
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>.  Of the
                   *  <a href="tables.html#68">optional sequence requirements</a>, only
                   *  @c push_back, @c at, and array access are supported.
                   *
                   *  @doctodo
                   *
                   *
                   *  @if maint
                   *  Documentation?  What's that?
                   *  Nathan Myers <ncm@cantrip.org>.
                   *
                   *  A string looks like this:
                   *
                   *  @code
                   *                                        [_Rep]
                   *                                        _M_length
                   *   [basic_string<char_type>]            _M_capacity
                   *   _M_dataplus                          _M_refcount
                   *   _M_p ---------------->               unnamed array of char_type
                   *  @endcode
                   *
                   *  Where the _M_p points to the first character in the string, and
                   *  you cast it to a pointer-to-_Rep and subtract 1 to get a
                   *  pointer to the header.
                   *
                   *  This approach has the enormous advantage that a string object
                   *  requires only one allocation.  All the ugliness is confined
                   *  within a single pair of inline functions, which each compile to
                   *  a single "add" instruction: _Rep::_M_data(), and
                   *  string::_M_rep(); and the allocation function which gets a
                   *  block of raw bytes and with room enough and constructs a _Rep
                   *  object at the front.
                   *
                   *  The reason you want _M_data pointing to the character array and
                   *  not the _Rep is so that the debugger can see the string
                   *  contents. (Probably we should add a non-inline member to get
                   *  the _Rep for the debugger to use, so users can check the actual
                   *  string length.)
                   *
                   *  Note that the _Rep object is a POD so that you can have a
                   *  static "empty string" _Rep object already "constructed" before
                   *  static constructors have run.  The reference-count encoding is
                   *  chosen so that a 0 indicates one reference, so you never try to
                   *  destroy the empty-string _Rep object.
                   *
                   *  All but the last paragraph is considered pretty conventional
                   *  for a C++ string implementation.
                   *  @endif
                  */
                  // 21.3  Template class basic_string
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    class basic_string
                    {
                      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;
                
                      // Types:
                    public:
                      typedef _Traits					    traits_type;
                      typedef typename _Traits::char_type		    value_type;
                      typedef _Alloc					    allocator_type;
                      typedef typename _CharT_alloc_type::size_type	    size_type;
                      typedef typename _CharT_alloc_type::difference_type   difference_type;
                      typedef typename _CharT_alloc_type::reference	    reference;
                      typedef typename _CharT_alloc_type::const_reference   const_reference;
                      typedef typename _CharT_alloc_type::pointer	    pointer;
                      typedef typename _CharT_alloc_type::const_pointer	    const_pointer;
                      typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                                            const_iterator;
                      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		    reverse_iterator;
                
                    private:
                      // _Rep: string representation
                      //   Invariants:
                      //   1. String really contains _M_length + 1 characters: due to 21.3.4
                      //      must be kept null-terminated.
                      //   2. _M_capacity >= _M_length
                      //      Allocated memory is always (_M_capacity + 1) * sizeof(_CharT).
                      //   3. _M_refcount has three states:
                      //      -1: leaked, one reference, no ref-copies allowed, non-const.
                      //       0: one reference, non-const.
                      //     n>0: n + 1 references, operations require a lock, const.
                      //   4. All fields==0 is an empty string, given the extra storage
                      //      beyond-the-end for a null terminator; thus, the shared
                      //      empty string representation needs no constructor.
                
                      struct _Rep_base
                      {
                	size_type		_M_length;
                	size_type		_M_capacity;
                	_Atomic_word		_M_refcount;
                      };
                
                      struct _Rep : _Rep_base
                      {
                	// Types:
                	typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
                
                	// (Public) Data members:
                
                	// The maximum number of individual char_type elements of an
                	// individual string is determined by _S_max_size. This is the
                	// value that will be returned by max_size().  (Whereas npos
                	// is the maximum number of bytes the allocator can allocate.)
                	// If one was to divvy up the theoretical largest size string,
                	// with a terminating character and m _CharT elements, it'd
                	// look like this:
                	// npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT)
                	// Solving for m:
                	// m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1
                	// In addition, this implementation quarters this amount.
                	static const size_type	_S_max_size;
                	static const _CharT	_S_terminal;
                
                	// The following storage is init'd to 0 by the linker, resulting
                        // (carefully) in an empty string with one reference.
                        static size_type _S_empty_rep_storage[];
                
                        static _Rep&
                        _S_empty_rep()
                        {
                	  void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
                	  return *reinterpret_cast<_Rep*>(__p);
                	}
                
                        bool
                	_M_is_leaked() const
                        { return this->_M_refcount < 0; }
                
                        bool
                	_M_is_shared() const
                        { return this->_M_refcount > 0; }
                
                        void
                	_M_set_leaked()
                        { this->_M_refcount = -1; }
                
                        void
                	_M_set_sharable()
                        { this->_M_refcount = 0; }
                
                	void
                	_M_set_length_and_sharable(size_type __n)
                	{ 
                	  this->_M_set_sharable();  // One reference.
                	  this->_M_length = __n;
                	  traits_type::assign(this->_M_refdata()[__n], _S_terminal);
                	  // grrr. (per 21.3.4)
                	  // You cannot leave those LWG people alone for a second.
                	}
                
                	_CharT*
                	_M_refdata() throw()
                	{ return reinterpret_cast<_CharT*>(this + 1); }
                
                	_CharT*
                	_M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
                	{
                	  return (!_M_is_leaked() && __alloc1 == __alloc2)
                	          ? _M_refcopy() : _M_clone(__alloc1);
                	}
                
                	// Create & Destroy
                	static _Rep*
                	_S_create(size_type, size_type, const _Alloc&);
                
                	void
                	_M_dispose(const _Alloc& __a)
                	{
                #ifndef _GLIBCXX_FULLY_DYNAMIC_STRING
                	  if (__builtin_expect(this != &_S_empty_rep(), false))
                #endif
                	    if (__gnu_cxx::__exchange_and_add(&this->_M_refcount, -1) <= 0)
                	      _M_destroy(__a);
                	}  // XXX MT
                
                	void
                	_M_destroy(const _Alloc&) throw();
                
                	_CharT*
                	_M_refcopy() throw()
                	{
                #ifndef _GLIBCXX_FULLY_DYNAMIC_STRING
                	  if (__builtin_expect(this != &_S_empty_rep(), false))
                #endif
                            __gnu_cxx::__atomic_add(&this->_M_refcount, 1);
                	  return _M_refdata();
                	}  // XXX MT
                
                	_CharT*
                	_M_clone(const _Alloc&, size_type __res = 0);
                      };
                
                      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
                      struct _Alloc_hider : _Alloc
                      {
                	_Alloc_hider(_CharT* __dat, const _Alloc& __a)
                	: _Alloc(__a), _M_p(__dat) { }
                
                	_CharT* _M_p; // The actual data.
                      };
                
                    public:
                      // Data Members (public):
                      // NB: This is an unsigned type, and thus represents the maximum
                      // size that the allocator can hold.
                      ///  Value returned by various member functions when they fail.
                      static const size_type	npos = static_cast<size_type>(-1);
                
                    private:
                      // Data Members (private):
                      mutable _Alloc_hider	_M_dataplus;
                
                      _CharT*
                      _M_data() const
                      { return  _M_dataplus._M_p; }
                
                      _CharT*
                      _M_data(_CharT* __p)
                      { return (_M_dataplus._M_p = __p); }
                
                      _Rep*
                      _M_rep() const
                      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
                
                      // For the internal use we have functions similar to `begin'/`end'
                      // but they do not call _M_leak.
                      iterator
                      _M_ibegin() const
                      { return iterator(_M_data()); }
                
                      iterator
                      _M_iend() const
                      { return iterator(_M_data() + this->size()); }
                
                      void
                      _M_leak()    // for use in begin() & non-const op[]
                      {
                	if (!_M_rep()->_M_is_leaked())
                	  _M_leak_hard();
                      }
                
                      size_type
                      _M_check(size_type __pos, const char* __s) const
                      {
                	if (__pos > this->size())
                	  __throw_out_of_range(__N(__s));
                	return __pos;
                      }
                
                      void
                      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
                      {
                	if (this->max_size() - (this->size() - __n1) < __n2)
                	  __throw_length_error(__N(__s));
                      }
                
                      // NB: _M_limit doesn't check for a bad __pos value.
                      size_type
                      _M_limit(size_type __pos, size_type __off) const
                      {
                	const bool __testoff =  __off < this->size() - __pos;
                	return __testoff ? __off : this->size() - __pos;
                      }
                
                      // True if _Rep and source do not overlap.
                      bool
                      _M_disjunct(const _CharT* __s) const
                      {
                	return (less<const _CharT*>()(__s, _M_data())
                		|| less<const _CharT*>()(_M_data() + this->size(), __s));
                      }
                
                      // When __n = 1 way faster than the general multichar
                      // traits_type::copy/move/assign.
                      static void
                      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::copy(__d, __s, __n);
                      }
                
                      static void
                      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::move(__d, __s, __n);	  
                      }
                
                      static void
                      _M_assign(_CharT* __d, size_type __n, _CharT __c)
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, __c);
                	else
                	  traits_type::assign(__d, __n, __c);	  
                      }
                
                      // _S_copy_chars is a separate template to permit specialization
                      // to optimize for the common case of pointers as iterators.
                      template<class _Iterator>
                        static void
                        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
                        {
                	  for (; __k1 != __k2; ++__k1, ++__p)
                	    traits_type::assign(*__p, *__k1); // These types are off.
                	}
                
                      static void
                      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
                      { _M_copy(__p, __k1, __k2 - __k1); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
                      { _M_copy(__p, __k1, __k2 - __k1); }
                
                      void
                      _M_mutate(size_type __pos, size_type __len1, size_type __len2);
                
                      void
                      _M_leak_hard();
                
                      static _Rep&
                      _S_empty_rep()
                      { return _Rep::_S_empty_rep(); }
                
                    public:
                      // Construct/copy/destroy:
                      // NB: We overload ctors in some cases instead of using default
                      // arguments, per 17.4.4.4 para. 2 item 2.
                
                      /**
                       *  @brief  Default constructor creates an empty string.
                       */
                      inline
                      basic_string();
                
                      /**
                       *  @brief  Construct an empty string using allocator @a a.
                       */
                      explicit
                      basic_string(const _Alloc& __a);
                
                      // NB: per LWG issue 42, semantics different from IS:
                      /**
                       *  @brief  Construct string with copy of value of @a str.
                       *  @param  str  Source string.
                       */
                      basic_string(const basic_string& __str);
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  str  Source string.
                       *  @param  pos  Index of first character to copy from.
                       *  @param  n  Number of characters to copy (default remainder).
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n = npos);
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  str  Source string.
                       *  @param  pos  Index of first character to copy from.
                       *  @param  n  Number of characters to copy.
                       *  @param  a  Allocator to use.
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n, const _Alloc& __a);
                
                      /**
                       *  @brief  Construct string initialized by a character array.
                       *  @param  s  Source character array.
                       *  @param  n  Number of characters to copy.
                       *  @param  a  Allocator to use (default is default allocator).
                       *
                       *  NB: @a s must have at least @a n characters, '\0' has no special
                       *  meaning.
                       */
                      basic_string(const _CharT* __s, size_type __n,
                		   const _Alloc& __a = _Alloc());
                      /**
                       *  @brief  Construct string as copy of a C string.
                       *  @param  s  Source C string.
                       *  @param  a  Allocator to use (default is default allocator).
                       */
                      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());
                      /**
                       *  @brief  Construct string as multiple characters.
                       *  @param  n  Number of characters.
                       *  @param  c  Character to use.
                       *  @param  a  Allocator to use (default is default allocator).
                       */
                      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
                
                      /**
                       *  @brief  Construct string as copy of a range.
                       *  @param  beg  Start of range.
                       *  @param  end  End of range.
                       *  @param  a  Allocator to use (default is default allocator).
                       */
                      template<class _InputIterator>
                        basic_string(_InputIterator __beg, _InputIterator __end,
                		     const _Alloc& __a = _Alloc());
                
                      /**
                       *  @brief  Destroy the string instance.
                       */
                      ~basic_string()
                      { _M_rep()->_M_dispose(this->get_allocator()); }
                
                      /**
                       *  @brief  Assign the value of @a str to this string.
                       *  @param  str  Source string.
                       */
                      basic_string&
                      operator=(const basic_string& __str) 
                      { return this->assign(__str); }
                
                      /**
                       *  @brief  Copy contents of @a s into this string.
                       *  @param  s  Source null-terminated string.
                       */
                      basic_string&
                      operator=(const _CharT* __s) 
                      { return this->assign(__s); }
                
                      /**
                       *  @brief  Set value to string of length 1.
                       *  @param  c  Source character.
                       *
                       *  Assigning to a character makes this string length 1 and
                       *  (*this)[0] == @a c.
                       */
                      basic_string&
                      operator=(_CharT __c) 
                      { 
                	this->assign(1, __c); 
                	return *this;
                      }
                
                      // Iterators:
                      /**
                       *  Returns a read/write iterator that points to the first character in
                       *  the %string.  Unshares the string.
                       */
                      iterator
                      begin()
                      {
                	_M_leak();
                	return iterator(_M_data());
                      }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  character in the %string.
                       */
                      const_iterator
                      begin() const
                      { return const_iterator(_M_data()); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  character in the %string.  Unshares the string.
                       */
                      iterator
                      end()
                      {
                	_M_leak();
                	return iterator(_M_data() + this->size());
                      }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the
                       *  last character in the %string.
                       */
                      const_iterator
                      end() const
                      { return const_iterator(_M_data() + this->size()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the last
                       *  character in the %string.  Iteration is done in reverse element
                       *  order.  Unshares the string.
                       */
                      reverse_iterator
                      rbegin()
                      { return reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last character in the %string.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const
                      { return const_reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one before the
                       *  first character in the %string.  Iteration is done in reverse
                       *  element order.  Unshares the string.
                       */
                      reverse_iterator
                      rend()
                      { return reverse_iterator(this->begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first character in the %string.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const
                      { return const_reverse_iterator(this->begin()); }
                
                    public:
                      // Capacity:
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      size() const
                      { return _M_rep()->_M_length; }
                
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      length() const
                      { return _M_rep()->_M_length; }
                
                      /// Returns the size() of the largest possible %string.
                      size_type
                      max_size() const
                      { return _Rep::_S_max_size; }
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  n  Number of characters the %string should contain.
                       *  @param  c  Character to fill any new elements.
                       *
                       *  This function will %resize the %string to the specified
                       *  number of characters.  If the number is smaller than the
                       *  %string's current size the %string is truncated, otherwise
                       *  the %string is extended and new elements are set to @a c.
                       */
                      void
                      resize(size_type __n, _CharT __c);
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  n  Number of characters the %string should contain.
                       *
                       *  This function will resize the %string to the specified length.  If
                       *  the new size is smaller than the %string's current size the %string
                       *  is truncated, otherwise the %string is extended and new characters
                       *  are default-constructed.  For basic types such as char, this means
                       *  setting them to 0.
                       */
                      void
                      resize(size_type __n)
                      { this->resize(__n, _CharT()); }
                
                      /**
                       *  Returns the total number of characters that the %string can hold
                       *  before needing to allocate more memory.
                       */
                      size_type
                      capacity() const
                      { return _M_rep()->_M_capacity; }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          characters.
                       *  @param  res_arg  Number of characters required.
                       *  @throw  std::length_error  If @a res_arg exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %string to hold the specified number of characters.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the string length that will be
                       *  required, the user can reserve the memory in %advance, and thus
                       *  prevent a possible reallocation of memory and copying of %string
                       *  data.
                       */
                      void
                      reserve(size_type __res_arg = 0);
                
                      /**
                       *  Erases the string, making it empty.
                       */
                      void
                      clear()
                      { _M_mutate(0, this->size(), 0); }
                
                      /**
                       *  Returns true if the %string is empty.  Equivalent to *this == "".
                       */
                      bool
                      empty() const
                      { return this->size() == 0; }
                
                      // Element access:
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  pos  The index of the character to access.
                       *  @return  Read-only (constant) reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
                      operator[] (size_type __pos) const
                      {
                	_GLIBCXX_DEBUG_ASSERT(__pos <= size());
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  pos  The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)  Unshares the string.
                       */
                      reference
                      operator[](size_type __pos)
                      {
                        // allow pos == size() as v3 extension:
                	_GLIBCXX_DEBUG_ASSERT(__pos <= size());
                        // but be strict in pedantic mode:
                	_GLIBCXX_DEBUG_PEDASSERT(__pos < size());
                	_M_leak();
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param n The index of the character to access.
                       *  @return  Read-only (const) reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range(__N("basic_string::at"));
                	return _M_data()[__n];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param n The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.  Success results in
                       *  unsharing the string.
                       */
                      reference
                      at(size_type __n)
                      {
                	if (__n >= size())
                	  __throw_out_of_range(__N("basic_string::at"));
                	_M_leak();
                	return _M_data()[__n];
                      }
                
                      // Modifiers:
                      /**
                       *  @brief  Append a string to this string.
                       *  @param str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const basic_string& __str)
                      { return this->append(__str); }
                
                      /**
                       *  @brief  Append a C string.
                       *  @param s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const _CharT* __s)
                      { return this->append(__s); }
                
                      /**
                       *  @brief  Append a character.
                       *  @param c  The character to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(_CharT __c)
                      { 
                	this->push_back(__c);
                	return *this;
                      }
                
                      /**
                       *  @brief  Append a string to this string.
                       *  @param str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const basic_string& __str);
                
                      /**
                       *  @brief  Append a substring.
                       *  @param str  The string to append.
                       *  @param pos  Index of the first character of str to append.
                       *  @param n  The number of characters to append.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a pos is not a valid index.
                       *
                       *  This function appends @a n characters from @a str starting at @a pos
                       *  to this string.  If @a n is is larger than the number of available
                       *  characters in @a str, the remainder of @a str is appended.
                       */
                      basic_string&
                      append(const basic_string& __str, size_type __pos, size_type __n);
                
                      /**
                       *  @brief  Append a C substring.
                       *  @param s  The C string to append.
                       *  @param n  The number of characters to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s, size_type __n);
                
                      /**
                       *  @brief  Append a C string.
                       *  @param s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->append(__s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Append multiple characters.
                       *  @param n  The number of characters to append.
                       *  @param c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  Appends n copies of c to this string.
                       */
                      basic_string&
                      append(size_type __n, _CharT __c);
                
                      /**
                       *  @brief  Append a range of characters.
                       *  @param first  Iterator referencing the first character to append.
                       *  @param last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Appends characters in the range [first,last) to this string.
                       */
                      template<class _InputIterator>
                        basic_string&
                        append(_InputIterator __first, _InputIterator __last)
                        { return this->replace(_M_iend(), _M_iend(), __first, __last); }
                
                      /**
                       *  @brief  Append a single character.
                       *  @param c  Character to append.
                       */
                      void
                      push_back(_CharT __c)
                      { 
                	const size_type __len = 1 + this->size();
                	if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	  this->reserve(__len);
                	traits_type::assign(_M_data()[this->size()], __c);
                	_M_rep()->_M_set_length_and_sharable(__len);
                      }
                
                      /**
                       *  @brief  Set value to contents of another string.
                       *  @param  str  Source string to use.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      assign(const basic_string& __str);
                
                      /**
                       *  @brief  Set value to a substring of a string.
                       *  @param str  The string to use.
                       *  @param pos  Index of the first character of str.
                       *  @param n  Number of characters to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a pos is not a valid index.
                       *
                       *  This function sets this string to the substring of @a str consisting
                       *  of @a n characters at @a pos.  If @a n is is larger than the number
                       *  of available characters in @a str, the remainder of @a str is used.
                       */
                      basic_string&
                      assign(const basic_string& __str, size_type __pos, size_type __n)
                      { return this->assign(__str._M_data()
                			    + __str._M_check(__pos, "basic_string::assign"),
                			    __str._M_limit(__pos, __n)); }
                
                      /**
                       *  @brief  Set value to a C substring.
                       *  @param s  The C string to use.
                       *  @param n  Number of characters to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the first @a n
                       *  characters of @a s.  If @a n is is larger than the number of
                       *  available characters in @a s, the remainder of @a s is used.
                       */
                      basic_string&
                      assign(const _CharT* __s, size_type __n);
                
                      /**
                       *  @brief  Set value to contents of a C string.
                       *  @param s  The C string to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the value of @a s.
                       *  The data is copied, so there is no dependence on @a s once the
                       *  function returns.
                       */
                      basic_string&
                      assign(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->assign(__s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Set value to multiple characters.
                       *  @param n  Length of the resulting string.
                       *  @param c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to @a n copies of
                       *  character @a c.
                       */
                      basic_string&
                      assign(size_type __n, _CharT __c)
                      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
                
                      /**
                       *  @brief  Set value to a range of characters.
                       *  @param first  Iterator referencing the first character to append.
                       *  @param last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Sets value of string to characters in the range [first,last).
                      */
                      template<class _InputIterator>
                        basic_string&
                        assign(_InputIterator __first, _InputIterator __last)
                        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
                
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param p  Iterator referencing location in string to insert at.
                       *  @param n  Number of characters to insert
                       *  @param c  The character to insert.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts @a n copies of character @a c starting at the position
                       *  referenced by iterator @a p.  If adding characters causes the length
                       *  to exceed max_size(), length_error is thrown.  The value of the
                       *  string doesn't change if an error is thrown.
                      */
                      void
                      insert(iterator __p, size_type __n, _CharT __c)
                      {	this->replace(__p, __p, __n, __c);  }
                
                      /**
                       *  @brief  Insert a range of characters.
                       *  @param p  Iterator referencing location in string to insert at.
                       *  @param beg  Start of range.
                       *  @param end  End of range.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts characters in range [beg,end).  If adding characters causes
                       *  the length to exceed max_size(), length_error is thrown.  The value
                       *  of the string doesn't change if an error is thrown.
                      */
                      template<class _InputIterator>
                        void
                        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
                        { this->replace(__p, __p, __beg, __end); }
                
                      /**
                       *  @brief  Insert value of a string.
                       *  @param pos1  Iterator referencing location in string to insert at.
                       *  @param str  The string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts value of @a str starting at @a pos1.  If adding characters
                       *  causes the length to exceed max_size(), length_error is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str)
                      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
                
                      /**
                       *  @brief  Insert a substring.
                       *  @param pos1  Iterator referencing location in string to insert at.
                       *  @param str  The string to insert.
                       *  @param pos2  Start of characters in str to insert.
                       *  @param n  Number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos1 > size() or
                       *  @a pos2 > @a str.size().
                       *
                       *  Starting at @a pos1, insert @a n character of @a str beginning with
                       *  @a pos2.  If adding characters causes the length to exceed
                       *  max_size(), length_error is thrown.  If @a pos1 is beyond the end of
                       *  this string or @a pos2 is beyond the end of @a str, out_of_range is
                       *  thrown.  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str,
                	     size_type __pos2, size_type __n)
                      { return this->insert(__pos1, __str._M_data()
                			    + __str._M_check(__pos2, "basic_string::insert"),
                			    __str._M_limit(__pos2, __n)); }
                
                      /**
                       *  @brief  Insert a C substring.
                       *  @param pos  Iterator referencing location in string to insert at.
                       *  @param s  The C string to insert.
                       *  @param n  The number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a n characters of @a s starting at @a pos.  If
                       *  adding characters causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a pos is beyond end(), out_of_range is
                       *  thrown.  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s, size_type __n);
                
                      /**
                       *  @brief  Insert a C string.
                       *  @param pos  Iterator referencing location in string to insert at.
                       *  @param s  The C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a n characters of @a s starting at @a pos.  If
                       *  adding characters causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a pos is beyond end(), out_of_range is
                       *  thrown.  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->insert(__pos, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param pos  Index in string to insert at.
                       *  @param n  Number of characters to insert
                       *  @param c  The character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts @a n copies of character @a c starting at index @a pos.  If
                       *  adding characters causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a pos > length(), out_of_range is
                       *  thrown.  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      insert(size_type __pos, size_type __n, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
                			      size_type(0), __n, __c); }
                
                      /**
                       *  @brief  Insert one character.
                       *  @param p  Iterator referencing position in string to insert at.
                       *  @param c  The character to insert.
                       *  @return  Iterator referencing newly inserted char.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts character @a c at position referenced by @a p.  If adding
                       *  character causes the length to exceed max_size(), length_error is
                       *  thrown.  If @a p is beyond end of string, out_of_range is thrown.
                       *  The value of the string doesn't change if an error is thrown.
                      */
                      iterator
                      insert(iterator __p, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());
                	const size_type __pos = __p - _M_ibegin();
                	_M_replace_aux(__pos, size_type(0), size_type(1), __c);
                	_M_rep()->_M_set_leaked();
                	return this->_M_ibegin() + __pos;
                      }
                
                      /**
                       *  @brief  Remove characters.
                       *  @param pos  Index of first character to remove (default 0).
                       *  @param n  Number of characters to remove (default remainder).
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Removes @a n characters from this string starting at @a pos.  The
                       *  length of the string is reduced by @a n.  If there are < @a n
                       *  characters to remove, the remainder of the string is truncated.  If
                       *  @a p is beyond end of string, out_of_range is thrown.  The value of
                       *  the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      erase(size_type __pos = 0, size_type __n = npos)
                      { 
                	_M_mutate(_M_check(__pos, "basic_string::erase"),
                		  _M_limit(__pos, __n), size_type(0));
                	return *this;
                      }
                
                      /**
                       *  @brief  Remove one character.
                       *  @param position  Iterator referencing the character to remove.
                       *  @return  iterator referencing same location after removal.
                       *
                       *  Removes the character at @a position from this string. The value
                       *  of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(iterator __position)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__position >= _M_ibegin()
                				 && __position < _M_iend());
                	const size_type __pos = __position - _M_ibegin();
                	_M_mutate(__pos, size_type(1), size_type(0));
                	_M_rep()->_M_set_leaked();
                	return _M_ibegin() + __pos;
                      }
                
                      /**
                       *  @brief  Remove a range of characters.
                       *  @param first  Iterator referencing the first character to remove.
                       *  @param last  Iterator referencing the end of the range.
                       *  @return  Iterator referencing location of first after removal.
                       *
                       *  Removes the characters in the range [first,last) from this string.
                       *  The value of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(iterator __first, iterator __last)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__first >= _M_ibegin() && __first <= __last
                				 && __last <= _M_iend());
                        const size_type __pos = __first - _M_ibegin();
                	_M_mutate(__pos, __last - __first, size_type(0));
                	_M_rep()->_M_set_leaked();
                	return _M_ibegin() + __pos;
                      }
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param pos  Index of first character to replace.
                       *  @param n  Number of characters to be replaced.
                       *  @param str  String to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [pos,pos+n) from this string.
                       *  In place, the value of @a str is inserted.  If @a pos is beyond end
                       *  of string, out_of_range is thrown.  If the length of the result
                       *  exceeds max_size(), length_error is thrown.  The value of the string
                       *  doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n, const basic_string& __str)
                      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param pos1  Index of first character to replace.
                       *  @param n1  Number of characters to be replaced.
                       *  @param str  String to insert.
                       *  @param pos2  Index of first character of str to use.
                       *  @param n2  Number of characters from str to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos1 > size() or @a pos2 >
                       *  str.size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [pos1,pos1 + n) from this
                       *  string.  In place, the value of @a str is inserted.  If @a pos is
                       *  beyond end of string, out_of_range is thrown.  If the length of the
                       *  result exceeds max_size(), length_error is thrown.  The value of the
                       *  string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2)
                      { return this->replace(__pos1, __n1, __str._M_data()
                			     + __str._M_check(__pos2, "basic_string::replace"),
                			     __str._M_limit(__pos2, __n2)); }
                
                      /**
                       *  @brief  Replace characters with value of a C substring.
                       *  @param pos  Index of first character to replace.
                       *  @param n1  Number of characters to be replaced.
                       *  @param s  C string to insert.
                       *  @param n2  Number of characters from @a s to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos1 > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [pos,pos + n1) from this string.
                       *  In place, the first @a n2 characters of @a s are inserted, or all
                       *  of @a s if @a n2 is too large.  If @a pos is beyond end of string,
                       *  out_of_range is thrown.  If the length of result exceeds max_size(),
                       *  length_error is thrown.  The value of the string doesn't change if
                       *  an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2);
                
                      /**
                       *  @brief  Replace characters with value of a C string.
                       *  @param pos  Index of first character to replace.
                       *  @param n1  Number of characters to be replaced.
                       *  @param s  C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [pos,pos + n1) from this string.
                       *  In place, the first @a n characters of @a s are inserted.  If @a
                       *  pos is beyond end of string, out_of_range is thrown.  If the length
                       *  of result exceeds max_size(), length_error is thrown.  The value of
                       *  the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__pos, __n1, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace characters with multiple characters.
                       *  @param pos  Index of first character to replace.
                       *  @param n1  Number of characters to be replaced.
                       *  @param n2  Number of characters to insert.
                       *  @param c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [pos,pos + n1) from this string.
                       *  In place, @a n2 copies of @a c are inserted.  If @a pos is beyond
                       *  end of string, out_of_range is thrown.  If the length of result
                       *  exceeds max_size(), length_error is thrown.  The value of the string
                       *  doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
                			      _M_limit(__pos, __n1), __n2, __c); }
                
                      /**
                       *  @brief  Replace range of characters with string.
                       *  @param i1  Iterator referencing start of range to replace.
                       *  @param i2  Iterator referencing end of range to replace.
                       *  @param str  String value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [i1,i2).  In place, the value of
                       *  @a str is inserted.  If the length of result exceeds max_size(),
                       *  length_error is thrown.  The value of the string doesn't change if
                       *  an error is thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, const basic_string& __str)
                      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace range of characters with C substring.
                       *  @param i1  Iterator referencing start of range to replace.
                       *  @param i2  Iterator referencing end of range to replace.
                       *  @param s  C string value to insert.
                       *  @param n  Number of characters from s to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [i1,i2).  In place, the first @a
                       *  n characters of @a s are inserted.  If the length of result exceeds
                       *  max_size(), length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
                      }
                
                      /**
                       *  @brief  Replace range of characters with C string.
                       *  @param i1  Iterator referencing start of range to replace.
                       *  @param i2  Iterator referencing end of range to replace.
                       *  @param s  C string value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [i1,i2).  In place, the
                       *  characters of @a s are inserted.  If the length of result exceeds
                       *  max_size(), length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__i1, __i2, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace range of characters with multiple characters
                       *  @param i1  Iterator referencing start of range to replace.
                       *  @param i2  Iterator referencing end of range to replace.
                       *  @param n  Number of characters to insert.
                       *  @param c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [i1,i2).  In place, @a n copies
                       *  of @a c are inserted.  If the length of result exceeds max_size(),
                       *  length_error is thrown.  The value of the string doesn't change if
                       *  an error is thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
                      }
                
                      /**
                       *  @brief  Replace range of characters with range.
                       *  @param i1  Iterator referencing start of range to replace.
                       *  @param i2  Iterator referencing end of range to replace.
                       *  @param k1  Iterator referencing start of range to insert.
                       *  @param k2  Iterator referencing end of range to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [i1,i2).  In place, characters
                       *  in the range [k1,k2) are inserted.  If the length of result exceeds
                       *  max_size(), length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      template<class _InputIterator>
                        basic_string&
                        replace(iterator __i1, iterator __i2,
                		_InputIterator __k1, _InputIterator __k2)
                        {
                	  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				   && __i2 <= _M_iend());
                	  __glibcxx_requires_valid_range(__k1, __k2);
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
                	}
                
                      // Specializations for the common case of pointer and iterator:
                      // useful to avoid the overhead of temporary buffering in _M_replace.
                      basic_string&
                      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(iterator __i1, iterator __i2,
                	      const _CharT* __k1, const _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                
                      basic_string&
                      replace(iterator __i1, iterator __i2,
                	      const_iterator __k1, const_iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                      
                    private:
                      template<class _Integer>
                	basic_string&
                	_M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
                			    _Integer __val, __true_type)
                        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }
                
                      template<class _InputIterator>
                	basic_string&
                	_M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
                			    _InputIterator __k2, __false_type);
                
                      basic_string&
                      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
                		     _CharT __c);
                
                      basic_string&
                      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
                		      size_type __n2);
                
                      // _S_construct_aux is used to implement the 21.3.1 para 15 which
                      // requires special behaviour if _InIter is an integral type
                      template<class _InIterator>
                        static _CharT*
                        _S_construct_aux(_InIterator __beg, _InIterator __end,
                			 const _Alloc& __a, __false_type)
                	{
                          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
                          return _S_construct(__beg, __end, __a, _Tag());
                	}
                
                      template<class _InIterator>
                        static _CharT*
                        _S_construct_aux(_InIterator __beg, _InIterator __end,
                			 const _Alloc& __a, __true_type)
                	{ return _S_construct(static_cast<size_type>(__beg),
                			      static_cast<value_type>(__end), __a); }
                
                      template<class _InIterator>
                        static _CharT*
                        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
                	{
                	  typedef typename std::__is_integer<_InIterator>::__type _Integral;
                	  return _S_construct_aux(__beg, __end, __a, _Integral());
                        }
                
                      // For Input Iterators, used in istreambuf_iterators, etc.
                      template<class _InIterator>
                        static _CharT*
                         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
                		      input_iterator_tag);
                
                      // For forward_iterators up to random_access_iterators, used for
                      // string::iterator, _CharT*, etc.
                      template<class _FwdIterator>
                        static _CharT*
                        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
                		     forward_iterator_tag);
                
                      static _CharT*
                      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);
                
                    public:
                
                      /**
                       *  @brief  Copy substring into C string.
                       *  @param s  C string to copy value into.
                       *  @param n  Number of characters to copy.
                       *  @param pos  Index of first character to copy.
                       *  @return  Number of characters actually copied
                       *  @throw  std::out_of_range  If pos > size().
                       *
                       *  Copies up to @a n characters starting at @a pos into the C string @a
                       *  s.  If @a pos is greater than size(), out_of_range is thrown.
                      */
                      size_type
                      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
                
                      /**
                       *  @brief  Swap contents with another string.
                       *  @param s  String to swap with.
                       *
                       *  Exchanges the contents of this string with that of @a s in constant
                       *  time.
                      */
                      void
                      swap(basic_string& __s);
                
                      // String operations:
                      /**
                       *  @brief  Return const pointer to null-terminated contents.
                       *
                       *  This is a handle to internal data.  Do not modify or dire things may
                       *  happen.
                      */
                      const _CharT*
                      c_str() const
                      { return _M_data(); }
                
                      /**
                       *  @brief  Return const pointer to contents.
                       *
                       *  This is a handle to internal data.  Do not modify or dire things may
                       *  happen.
                      */
                      const _CharT*
                      data() const
                      { return _M_data(); }
                
                      /**
                       *  @brief  Return copy of allocator used to construct this string.
                      */
                      allocator_type
                      get_allocator() const
                      { return _M_dataplus; }
                
                      /**
                       *  @brief  Find position of a C substring.
                       *  @param s  C string to locate.
                       *  @param pos  Index of character to search from.
                       *  @param n  Number of characters from @a s to search for.
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a pos, searches forward for the first @a n characters
                       *  in @a s within this string.  If found, returns the index where it
                       *  begins.  If not found, returns npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find position of a string.
                       *  @param str  String to locate.
                       *  @param pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a pos, searches forward for value of @a str within
                       *  this string.  If found, returns the index where it begins.  If not
                       *  found, returns npos.
                      */
                      size_type
                      find(const basic_string& __str, size_type __pos = 0) const
                      { return this->find(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a C string.
                       *  @param s  C string to locate.
                       *  @param pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a pos, searches forward for the value of @a s within
                       *  this string.  If found, returns the index where it begins.  If not
                       *  found, returns npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos = 0) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param c  Character to locate.
                       *  @param pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a pos, searches forward for @a c within this string.
                       *  If found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find(_CharT __c, size_type __pos = 0) const;
                
                      /**
                       *  @brief  Find last position of a string.
                       *  @param str  String to locate.
                       *  @param pos  Index of character to search back from (default end).
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a pos, searches backward for value of @a str within
                       *  this string.  If found, returns the index where it begins.  If not
                       *  found, returns npos.
                      */
                      size_type
                      rfind(const basic_string& __str, size_type __pos = npos) const
                      { return this->rfind(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a C substring.
                       *  @param s  C string to locate.
                       *  @param pos  Index of character to search back from.
                       *  @param n  Number of characters from s to search for.
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a pos, searches backward for the first @a n
                       *  characters in @a s within this string.  If found, returns the index
                       *  where it begins.  If not found, returns npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find last position of a C string.
                       *  @param s  C string to locate.
                       *  @param pos  Index of character to start search at (default 0).
                       *  @return  Index of start of  last occurrence.
                       *
                       *  Starting from @a pos, searches backward for the value of @a s within
                       *  this string.  If found, returns the index where it begins.  If not
                       *  found, returns npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->rfind(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param c  Character to locate.
                       *  @param pos  Index of character to search back from (default 0).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a pos, searches backward for @a c within this string.
                       *  If found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      rfind(_CharT __c, size_type __pos = npos) const;
                
                      /**
                       *  @brief  Find position of a character of string.
                       *  @param str  String containing characters to locate.
                       *  @param pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a pos, searches forward for one of the characters of
                       *  @a str within this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_first_of(const basic_string& __str, size_type __pos = 0) const
                      { return this->find_first_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a character of C substring.
                       *  @param s  String containing characters to locate.
                       *  @param pos  Index of character to search from (default 0).
                       *  @param n  Number of characters from s to search for.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a pos, searches forward for one of the first @a n
                       *  characters of @a s within this string.  If found, returns the index
                       *  where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find position of a character of C string.
                       *  @param s  String containing characters to locate.
                       *  @param pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a pos, searches forward for one of the characters of
                       *  @a s within this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos = 0) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param c  Character to locate.
                       *  @param pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a pos, searches forward for the character @a c within
                       *  this string.  If found, returns the index where it was found.  If
                       *  not found, returns npos.
                       *
                       *  Note: equivalent to find(c, pos).
                      */
                      size_type
                      find_first_of(_CharT __c, size_type __pos = 0) const
                      { return this->find(__c, __pos); }
                
                      /**
                       *  @brief  Find last position of a character of string.
                       *  @param str  String containing characters to locate.
                       *  @param pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a pos, searches backward for one of the characters of
                       *  @a str within this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_last_of(const basic_string& __str, size_type __pos = npos) const
                      { return this->find_last_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a character of C substring.
                       *  @param s  C string containing characters to locate.
                       *  @param pos  Index of character to search back from (default end).
                       *  @param n  Number of characters from s to search for.
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a pos, searches backward for one of the first @a n
                       *  characters of @a s within this string.  If found, returns the index
                       *  where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
                
                      /**
                       *  @brief  Find last position of a character of C string.
                       *  @param s  C string containing characters to locate.
                       *  @param pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a pos, searches backward for one of the characters of
                       *  @a s within this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param c  Character to locate.
                       *  @param pos  Index of character to search back from (default 0).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a pos, searches backward for @a c within this string.
                       *  If found, returns the index where it was found.  If not found,
                       *  returns npos.
                       *
                       *  Note: equivalent to rfind(c, pos).
                      */
                      size_type
                      find_last_of(_CharT __c, size_type __pos = npos) const
                      { return this->rfind(__c, __pos); }
                
                      /**
                       *  @brief  Find position of a character not in string.
                       *  @param str  String containing characters to avoid.
                       *  @param pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a pos, searches forward for a character not contained
                       *  in @a str within this string.  If found, returns the index where it
                       *  was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
                      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a character not in C substring.
                       *  @param s  C string containing characters to avoid.
                       *  @param pos  Index of character to search from (default 0).
                       *  @param n  Number of characters from s to consider.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a pos, searches forward for a character not contained
                       *  in the first @a n characters of @a s within this string.  If found,
                       *  returns the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos,
                			size_type __n) const;
                
                      /**
                       *  @brief  Find position of a character not in C string.
                       *  @param s  C string containing characters to avoid.
                       *  @param pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a pos, searches forward for a character not contained
                       *  in @a s within this string.  If found, returns the index where it
                       *  was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a different character.
                       *  @param c  Character to avoid.
                       *  @param pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a pos, searches forward for a character other than @a c
                       *  within this string.  If found, returns the index where it was found.
                       *  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(_CharT __c, size_type __pos = 0) const;
                
                      /**
                       *  @brief  Find last position of a character not in string.
                       *  @param str  String containing characters to avoid.
                       *  @param pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a pos, searches backward for a character not
                       *  contained in @a str within this string.  If found, returns the index
                       *  where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
                      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a character not in C substring.
                       *  @param s  C string containing characters to avoid.
                       *  @param pos  Index of character to search from (default 0).
                       *  @param n  Number of characters from s to consider.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a pos, searches backward for a character not
                       *  contained in the first @a n characters of @a s within this string.
                       *  If found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos,
                		       size_type __n) const;
                      /**
                       *  @brief  Find position of a character not in C string.
                       *  @param s  C string containing characters to avoid.
                       *  @param pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a pos, searches backward for a character not
                       *  contained in @a s within this string.  If found, returns the index
                       *  where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a different character.
                       *  @param c  Character to avoid.
                       *  @param pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a pos, searches backward for a character other than
                       *  @a c within this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_last_not_of(_CharT __c, size_type __pos = npos) const;
                
                      /**
                       *  @brief  Get a substring.
                       *  @param pos  Index of first character (default 0).
                       *  @param n  Number of characters in substring (default remainder).
                       *  @return  The new string.
                       *  @throw  std::out_of_range  If pos > size().
                       *
                       *  Construct and return a new string using the @a n characters starting
                       *  at @a pos.  If the string is too short, use the remainder of the
                       *  characters.  If @a pos is beyond the end of the string, out_of_range
                       *  is thrown.
                      */
                      basic_string
                      substr(size_type __pos = 0, size_type __n = npos) const
                      { return basic_string(*this,
                			    _M_check(__pos, "basic_string::substr"), __n); }
                
                      /**
                       *  @brief  Compare to a string.
                       *  @param str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a str, 0 if
                       *  their values are equivalent, or > 0 if this string is ordered after
                       *  @a str.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of size() and str.size().  The function
                       *  then compares the two strings by calling traits::compare(data(),
                       *  str.data(),rlen).  If the result of the comparison is nonzero returns
                       *  it, otherwise the shorter one is ordered first.
                      */
                      int
                      compare(const basic_string& __str) const
                      {
                	const size_type __size = this->size();
                	const size_type __osize = __str.size();
                	const size_type __len = std::min(__size, __osize);
                
                	int __r = traits_type::compare(_M_data(), __str.data(), __len);
                	if (!__r)
                	  __r =  __size - __osize;
                	return __r;
                      }
                
                      /**
                       *  @brief  Compare substring to a string.
                       *  @param pos  Index of first character of substring.
                       *  @param n  Number of characters in substring.
                       *  @param str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a n characters starting
                       *  at @a pos.  Returns an integer < 0 if the substring is ordered
                       *  before @a str, 0 if their values are equivalent, or > 0 if the
                       *  substring is ordered after @a str.  Determines the effective length
                       *  rlen of the strings to compare as the smallest of the length of the
                       *  substring and @a str.size().  The function then compares the two
                       *  strings by calling traits::compare(substring.data(),str.data(),rlen).
                       *  If the result of the comparison is nonzero returns it, otherwise the
                       *  shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n, const basic_string& __str) const;
                
                      /**
                       *  @brief  Compare substring to a substring.
                       *  @param pos1  Index of first character of substring.
                       *  @param n1  Number of characters in substring.
                       *  @param str  String to compare against.
                       *  @param pos2  Index of first character of substring of str.
                       *  @param n2  Number of characters in substring of str.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a n1 characters starting
                       *  at @a pos1.  Form the substring of @a str from the @a n2 characters
                       *  starting at @a pos2.  Returns an integer < 0 if this substring is
                       *  ordered before the substring of @a str, 0 if their values are
                       *  equivalent, or > 0 if this substring is ordered after the substring
                       *  of @a str.  Determines the effective length rlen of the strings
                       *  to compare as the smallest of the lengths of the substrings.  The
                       *  function then compares the two strings by calling
                       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).
                       *  If the result of the comparison is nonzero returns it, otherwise the
                       *  shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2) const;
                
                      /**
                       *  @brief  Compare to a C string.
                       *  @param s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a s, 0 if
                       *  their values are equivalent, or > 0 if this string is ordered after
                       *  @a s.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of size() and the length of a string
                       *  constructed from @a s.  The function then compares the two strings
                       *  by calling traits::compare(data(),s,rlen).  If the result of the
                       *  comparison is nonzero returns it, otherwise the shorter one is
                       *  ordered first.
                      */
                      int
                      compare(const _CharT* __s) const;
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 5 String::compare specification questionable
                      /**
                       *  @brief  Compare substring to a C string.
                       *  @param pos  Index of first character of substring.
                       *  @param n1  Number of characters in substring.
                       *  @param s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a n1 characters starting
                       *  at @a pos.  Returns an integer < 0 if the substring is ordered
                       *  before @a s, 0 if their values are equivalent, or > 0 if the
                       *  substring is ordered after @a s.  Determines the effective length
                       *  rlen of the strings to compare as the smallest of the length of the 
                       *  substring and the length of a string constructed from @a s.  The
                       *  function then compares the two string by calling
                       *  traits::compare(substring.data(),s,rlen).  If the result of the
                       *  comparison is nonzero returns it, otherwise the shorter one is
                       *  ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
                
                      /**
                       *  @brief  Compare substring against a character array.
                       *  @param pos1  Index of first character of substring.
                       *  @param n1  Number of characters in substring.
                       *  @param s  character array to compare against.
                       *  @param n2  Number of characters of s.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a n1 characters starting
                       *  at @a pos1.  Form a string from the first @a n2 characters of @a s.
                       *  Returns an integer < 0 if this substring is ordered before the string
                       *  from @a s, 0 if their values are equivalent, or > 0 if this substring
                       *  is ordered after the string from @a s.   Determines the effective
                       *  length rlen of the strings to compare as the smallest of the length
                       *  of the substring and @a n2.  The function then compares the two
                       *  strings by calling traits::compare(substring.data(),s,rlen).  If the
                       *  result of the comparison is nonzero returns it, otherwise the shorter
                       *  one is ordered first.
                       *
                       *  NB: s must have at least n2 characters, '\0' has no special
                       *  meaning.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2) const;
                  };
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>::
                    basic_string()
                #ifndef _GLIBCXX_FULLY_DYNAMIC_STRING
                    : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
                #else
                    : _M_dataplus(_S_construct(size_type(), _CharT(), _Alloc()), _Alloc()) { }
                #endif
                
                  // operator+
                  /**
                   *  @brief  Concatenate two strings.
                   *  @param lhs  First string.
                   *  @param rhs  Last string.
                   *  @return  New string with value of @a lhs followed by @a rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       ##### -> 	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    {
                      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  /**
                   *  @brief  Concatenate C string and string.
                   *  @param lhs  First string.
                   *  @param rhs  Last string.
                   *  @return  New string with value of @a lhs followed by @a rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT,_Traits,_Alloc>
                    operator+(const _CharT* __lhs,
                	      const basic_string<_CharT,_Traits,_Alloc>& __rhs);
                
                  /**
                   *  @brief  Concatenate character and string.
                   *  @param lhs  First string.
                   *  @param rhs  Last string.
                   *  @return  New string with @a lhs followed by @a rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT,_Traits,_Alloc>
                    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);
                
                  /**
                   *  @brief  Concatenate string and C string.
                   *  @param lhs  First string.
                   *  @param rhs  Last string.
                   *  @return  New string with @a lhs followed by @a rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
           1 -> 	     const _CharT* __rhs)
                    {
                      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  /**
                   *  @brief  Concatenate string and character.
                   *  @param lhs  First string.
                   *  @param rhs  Last string.
                   *  @return  New string with @a lhs followed by @a rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
        8822 ->     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
                    {
                      typedef basic_string<_CharT, _Traits, _Alloc>	__string_type;
                      typedef typename __string_type::size_type		__size_type;
                      __string_type __str(__lhs);
                      __str.append(__size_type(1), __rhs);
                      return __str;
                    }
                
                  // operator ==
                  /**
                   *  @brief  Test equivalence of two strings.
                   *  @param lhs  First string.
                   *  @param rhs  Second string.
                   *  @return  True if @a lhs.compare(@a rhs) == 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) == 0; }
                
                  /**
                   *  @brief  Test equivalence of C string and string.
                   *  @param lhs  C string.
                   *  @param rhs  String.
                   *  @return  True if @a rhs.compare(@a lhs) == 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator==(const _CharT* __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) == 0; }
                
                  /**
                   *  @brief  Test equivalence of string and C string.
                   *  @param lhs  String.
                   *  @param rhs  C string.
                   *  @return  True if @a lhs.compare(@a rhs) == 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     5472638 -> 	       const _CharT* __rhs)
                    { return __lhs.compare(__rhs) == 0; }
                
                  // operator !=
                  /**
                   *  @brief  Test difference of two strings.
                   *  @param lhs  First string.
                   *  @param rhs  Second string.
                   *  @return  True if @a lhs.compare(@a rhs) != 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) != 0; }
                
                  /**
                   *  @brief  Test difference of C string and string.
                   *  @param lhs  C string.
                   *  @param rhs  String.
                   *  @return  True if @a rhs.compare(@a lhs) != 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator!=(const _CharT* __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) != 0; }
                
                  /**
                   *  @brief  Test difference of string and C string.
                   *  @param lhs  String.
                   *  @param rhs  C string.
                   *  @return  True if @a lhs.compare(@a rhs) != 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        1469 -> 	       const _CharT* __rhs)
                    { return __lhs.compare(__rhs) != 0; }
                
                  // operator <
                  /**
                   *  @brief  Test if string precedes string.
                   *  @param lhs  First string.
                   *  @param rhs  Second string.
                   *  @return  True if @a lhs precedes @a rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
         553 -> 	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) < 0; }
                
                  /**
                   *  @brief  Test if string precedes C string.
                   *  @param lhs  String.
                   *  @param rhs  C string.
                   *  @return  True if @a lhs precedes @a rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const _CharT* __rhs)
                    { return __lhs.compare(__rhs) < 0; }
                
                  /**
                   *  @brief  Test if C string precedes string.
                   *  @param lhs  C string.
                   *  @param rhs  String.
                   *  @return  True if @a lhs precedes @a rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<(const _CharT* __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) > 0; }
                
                  // operator >
                  /**
                   *  @brief  Test if string follows string.
                   *  @param lhs  First string.
                   *  @param rhs  Second string.
                   *  @return  True if @a lhs follows @a rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) > 0; }
                
                  /**
                   *  @brief  Test if string follows C string.
                   *  @param lhs  String.
                   *  @param rhs  C string.
                   *  @return  True if @a lhs follows @a rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const _CharT* __rhs)
                    { return __lhs.compare(__rhs) > 0; }
                
                  /**
                   *  @brief  Test if C string follows string.
                   *  @param lhs  C string.
                   *  @param rhs  String.
                   *  @return  True if @a lhs follows @a rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>(const _CharT* __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) < 0; }
                
                  // operator <=
                  /**
                   *  @brief  Test if string doesn't follow string.
                   *  @param lhs  First string.
                   *  @param rhs  Second string.
                   *  @return  True if @a lhs doesn't follow @a rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) <= 0; }
                
                  /**
                   *  @brief  Test if string doesn't follow C string.
                   *  @param lhs  String.
                   *  @param rhs  C string.
                   *  @return  True if @a lhs doesn't follow @a rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return __lhs.compare(__rhs) <= 0; }
                
                  /**
                   *  @brief  Test if C string doesn't follow string.
                   *  @param lhs  C string.
                   *  @param rhs  String.
                   *  @return  True if @a lhs doesn't follow @a rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<=(const _CharT* __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) >= 0; }
                
                  // operator >=
                  /**
                   *  @brief  Test if string doesn't precede string.
                   *  @param lhs  First string.
                   *  @param rhs  Second string.
                   *  @return  True if @a lhs doesn't precede @a rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __lhs.compare(__rhs) >= 0; }
                
                  /**
                   *  @brief  Test if string doesn't precede C string.
                   *  @param lhs  String.
                   *  @param rhs  C string.
                   *  @return  True if @a lhs doesn't precede @a rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return __lhs.compare(__rhs) >= 0; }
                
                  /**
                   *  @brief  Test if C string doesn't precede string.
                   *  @param lhs  C string.
                   *  @param rhs  String.
                   *  @return  True if @a lhs doesn't precede @a rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>=(const _CharT* __lhs,
                	     const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) <= 0; }
                
                  /**
                   *  @brief  Swap contents of two strings.
                   *  @param lhs  First string.
                   *  @param rhs  Second string.
                   *
                   *  Exchanges the contents of @a lhs and @a rhs in constant time.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline void
                    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	 basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { __lhs.swap(__rhs); }
                
                  /**
                   *  @brief  Read stream into a string.
                   *  @param is  Input stream.
                   *  @param str  Buffer to store into.
                   *  @return  Reference to the input stream.
                   *
                   *  Stores characters from @a is into @a str until whitespace is found, the
                   *  end of the stream is encountered, or str.max_size() is reached.  If
                   *  is.width() is non-zero, that is the limit on the number of characters
                   *  stored into @a str.  Any previous contents of @a str are erased.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_istream<_CharT, _Traits>&
                    operator>>(basic_istream<_CharT, _Traits>& __is,
                	       basic_string<_CharT, _Traits, _Alloc>& __str);
                
                  template<>
                    basic_istream<char>&
                    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
                
                  /**
                   *  @brief  Write string to a stream.
                   *  @param os  Output stream.
                   *  @param str  String to write out.
                   *  @return  Reference to the output stream.
                   *
                   *  Output characters of @a str into os following the same rules as for
                   *  writing a C string.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_ostream<_CharT, _Traits>&
                    operator<<(basic_ostream<_CharT, _Traits>& __os,
                	       const basic_string<_CharT, _Traits, _Alloc>& __str);
                
                  /**
                   *  @brief  Read a line from stream into a string.
                   *  @param is  Input stream.
                   *  @param str  Buffer to store into.
                   *  @param delim  Character marking end of line.
                   *  @return  Reference to the input stream.
                   *
                   *  Stores characters from @a is into @a str until @a delim is found, the
                   *  end of the stream is encountered, or str.max_size() is reached.  If
                   *  is.width() is non-zero, that is the limit on the number of characters
                   *  stored into @a str.  Any previous contents of @a str are erased.  If @a
                   *  delim was encountered, it is extracted but not stored into @a str.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
                
                  /**
                   *  @brief  Read a line from stream into a string.
                   *  @param is  Input stream.
                   *  @param str  Buffer to store into.
                   *  @return  Reference to the input stream.
                   *
                   *  Stores characters from is into @a str until '\n' is found, the end of
                   *  the stream is encountered, or str.max_size() is reached.  If is.width()
                   *  is non-zero, that is the limit on the number of characters stored into
                   *  @a str.  Any previous contents of @a str are erased.  If end of line was
                   *  encountered, it is extracted but not stored into @a str.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str);
                    
                  template<>
                    basic_istream<char>&
                    getline(basic_istream<char>& __in, basic_string<char>& __str,
                	    char __delim);
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  template<>
                    basic_istream<wchar_t>&
                    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
                	    wchar_t __delim);
                #endif  
                } // namespace std
                
                #endif /* _BASIC_STRING_H */


Top 10 Lines:

     Line      Count

     2162    5472638
     2119       8822
     2199       1469
     2212        553
     2104          1

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

  5483483   Total number of line executions
913913.83   Average executions per line


*** File /home/tyler/Desktop/fland2/groupr.h:
                // This rule acts like a group of rules.
                // It acts like one rule.
                // When you say groupr1 = groupr2 it creates all the new children rules
                // exactly the same for group2 as group1 has.
                
                // TODO: insert class name before _CPP
                #ifndef GROUPR_H
                #define GROUPR_H
                
                using namespace std;
                
                #include "baserule.h"
                #include "templates.h"
                
                class GroupR : public BaseRule
                {
                	public:
                
                	// This is where we store all the rules that are in this group
                	vector< BaseRule* > groupMember;
                
                	GroupR();
                
                	void addGroupMember( BaseRule* );
                
                	virtual void destructor( bool willDelete = false );
                
                	virtual void goCalcMe( BaseEnt *inClient, intensityType );
                
                	virtual void propogateChildren( BaseEnt* newEnt, intensityType intensity );
                
                	// used in FMLParse
                	virtual string assignValue( string valueType, istringstream *value, FmlParser* fPtr );
                
                	// return the number of members
                	inline int size();
                
                	// clears all the rules, dosn't ask any questions. Be careful of MEM leaks!
                	inline void clear();
                
                	// adds a rule. If the rule is NULL, it dosn't add it.
                	inline void addRule( BaseRule* );
                
                	#if( DEBUG )
                	virtual string toString( int );
       ##### -> 	virtual string getType(){ return "GroupR"; }
                	#endif
                };
                
      105411 -> inline int GroupR::size()
                {
                	return groupMember.size();
                }
                
                inline void GroupR::clear()
                {
                	groupMember.clear();
                }
                
          26 -> inline void GroupR::addRule( BaseRule* inRule )
                {
                	if( inRule ) // if it isn't NULL
                	{
                		groupMember.push_back( inRule );
                	}
                }
                
                
                #endif


Top 10 Lines:

     Line      Count

       50     105411
       60         26

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

   105437   Total number of line executions
 35145.67   Average executions per line


*** File /usr/lib/gcc/i486-linux-gnu/4.1.2/../../../../include/c++/4.1.2/new:
                // The -*- C++ -*- dynamic memory management header.
                
                // Copyright (C) 1994, 1996, 1997, 1998, 2000, 2001, 2002
                // Free Software Foundation
                
                // This file is part of GCC.
                //
                // GCC is free software; you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation; either version 2, or (at your option)
                // any later version.
                // 
                // GCC is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                // 
                // You should have received a copy of the GNU General Public License
                // along with GCC; see the file COPYING.  If not, write to
                // the Free Software Foundation, 51 Franklin Street, Fifth Floor,
                // Boston, MA 02110-1301, USA.
                
                // As a special exception, you may use this file as part of a free software
                // library without restriction.  Specifically, if other files instantiate
                // templates or use macros or inline functions from this file, or you compile
                // this file and link it with other files to produce an executable, this
                // file does not by itself cause the resulting executable to be covered by
                // the GNU General Public License.  This exception does not however
                // invalidate any other reasons why the executable file might be covered by
                // the GNU General Public License.
                
                /** @file new
                 *  The header @c new defines several functions to manage dynamic memory and
                 *  handling memory allocation errors; see
                 *  http://gcc.gnu.org/onlinedocs/libstdc++/18_support/howto.html#4 for more.
                 */
                
                #ifndef _NEW
                #define _NEW
                
                #include <cstddef>
                #include <exception>
                
                #pragma GCC visibility push(default)
                
                extern "C++" {
                
                namespace std 
                {
                  /**
                   *  @brief  Exception possibly thrown by @c new.
                   *
                   *  @c bad_alloc (or classes derived from it) is used to report allocation
                   *  errors from the throwing forms of @c new.  */
                  class bad_alloc : public exception 
                  {
                  public:
                    bad_alloc() throw() { }
                    // This declaration is not useless:
                    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
                    virtual ~bad_alloc() throw();
                  };
                
                  struct nothrow_t { };
                  extern const nothrow_t nothrow;
                  /** If you write your own error handler to be called by @c new, it must
                   *  be of this type.  */
                  typedef void (*new_handler)();
                  /// Takes a replacement handler as the argument, returns the previous handler.
                  new_handler set_new_handler(new_handler) throw();
                } // namespace std
                
                //@{
                /** These are replaceable signatures:
                 *  - normal single new and delete (no arguments, throw @c bad_alloc on error)
                 *  - normal array new and delete (same)
                 *  - @c nothrow single new and delete (take a @c nothrow argument, return
                 *    @c NULL on error)
                 *  - @c nothrow array new and delete (same)
                 *
                 *  Placement new and delete signatures (take a memory address argument,
                 *  does nothing) may not be replaced by a user's program.
                */
                void* operator new(std::size_t) throw (std::bad_alloc);
                void* operator new[](std::size_t) throw (std::bad_alloc);
                void operator delete(void*) throw();
                void operator delete[](void*) throw();
                void* operator new(std::size_t, const std::nothrow_t&) throw();
                void* operator new[](std::size_t, const std::nothrow_t&) throw();
                void operator delete(void*, const std::nothrow_t&) throw();
                void operator delete[](void*, const std::nothrow_t&) throw();
                
                // Default placement versions of operator new.
    12128680 -> inline void* operator new(std::size_t, void* __p) throw() { return __p; }
                inline void* operator new[](std::size_t, void* __p) throw() { return __p; }
                
                // Default placement versions of operator delete.
       ##### -> inline void  operator delete  (void*, void*) throw() { }
                inline void  operator delete[](void*, void*) throw() { }
                //@}
                } // extern "C++"
                
                #pragma GCC visibility pop
                
                #endif


Top 10 Lines:

     Line      Count

       94   12128680

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

 12128680   Total number of line executions
6064340.00   Average executions per line


*** File /usr/lib/gcc/i486-linux-gnu/4.1.2/../../../../include/c++/4.1.2/bits/stl_function.h:
                // Functor implementations -*- C++ -*-
                
                // Copyright (C) 2001, 2002, 2004, 2005 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 2, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // You should have received a copy of the GNU General Public License along
                // with this library; see the file COPYING.  If not, write to the Free
                // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
                // USA.
                
                // As a special exception, you may use this file as part of a free software
                // library without restriction.  Specifically, if other files instantiate
                // templates or use macros or inline functions from this file, or you compile
                // this file and link it with other files to produce an executable, this
                // file does not by itself cause the resulting executable to be covered by
                // the GNU General Public License.  This exception does not however
                // invalidate any other reasons why the executable file might be covered by
                // the GNU General Public License.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file stl_function.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _FUNCTION_H
                #define _FUNCTION_H 1
                
                namespace std
                {
                  // 20.3.1 base classes
                  /** @defgroup s20_3_1_base Functor Base Classes
                   *  Function objects, or @e functors, are objects with an @c operator()
                   *  defined and accessible.  They can be passed as arguments to algorithm
                   *  templates and used in place of a function pointer.  Not only is the
                   *  resulting expressiveness of the library increased, but the generated
                   *  code can be more efficient than what you might write by hand.  When we
                   *  refer to "functors," then, generally we include function pointers in
                   *  the description as well.
                   *
                   *  Often, functors are only created as temporaries passed to algorithm
                   *  calls, rather than being created as named variables.
                   *
                   *  Two examples taken from the standard itself follow.  To perform a
                   *  by-element addition of two vectors @c a and @c b containing @c double,
                   *  and put the result in @c a, use
                   *  \code
                   *  transform (a.begin(), a.end(), b.begin(), a.begin(), plus<double>());
                   *  \endcode
                   *  To negate every element in @c a, use
                   *  \code
                   *  transform(a.begin(), a.end(), a.begin(), negate<double>());
                   *  \endcode
                   *  The addition and negation functions will be inlined directly.
                   *
                   *  The standard functors are derived from structs named @c unary_function
                   *  and @c binary_function.  These two classes contain nothing but typedefs,
                   *  to aid in generic (template) programming.  If you write your own
                   *  functors, you might consider doing the same.
                   *
                   *  @{
                   */
                  /**
                   *  This is one of the @link s20_3_1_base functor base classes@endlink.
                   */
                  template <class _Arg, class _Result>
                    struct unary_function
                    {
                      typedef _Arg argument_type;   ///< @c argument_type is the type of the
                                                    ///     argument (no surprises here)
                
                      typedef _Result result_type;  ///< @c result_type is the return type
                    };
                
                  /**
                   *  This is one of the @link s20_3_1_base functor base classes@endlink.
                   */
                  template <class _Arg1, class _Arg2, class _Result>
                    struct binary_function
                    {
                      typedef _Arg1 first_argument_type;   ///< the type of the first argument
                                                           ///  (no surprises here)
                
                      typedef _Arg2 second_argument_type;  ///< the type of the second argument
                      typedef _Result result_type;         ///< type of the return type
                    };
                  /** @}  */
                
                  // 20.3.2 arithmetic
                  /** @defgroup s20_3_2_arithmetic Arithmetic Classes
                   *  Because basic math often needs to be done during an algorithm, the library
                   *  provides functors for those operations.  See the documentation for
                   *  @link s20_3_1_base the base classes@endlink for examples of their use.
                   *
                   *  @{
                   */
                  /// One of the @link s20_3_2_arithmetic math functors@endlink.
                  template <class _Tp>
                    struct plus : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x + __y; }
                    };
                
                  /// One of the @link s20_3_2_arithmetic math functors@endlink.
                  template <class _Tp>
                    struct minus : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x - __y; }
                    };
                
                  /// One of the @link s20_3_2_arithmetic math functors@endlink.
                  template <class _Tp>
                    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x * __y; }
                    };
                
                  /// One of the @link s20_3_2_arithmetic math functors@endlink.
                  template <class _Tp>
                    struct divides : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x / __y; }
                    };
                
                  /// One of the @link s20_3_2_arithmetic math functors@endlink.
                  template <class _Tp>
                    struct modulus : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x % __y; }
                    };
                
                  /// One of the @link s20_3_2_arithmetic math functors@endlink.
                  template <class _Tp>
                    struct negate : public unary_function<_Tp, _Tp>
                    {
                      _Tp
                      operator()(const _Tp& __x) const
                      { return -__x; }
                    };
                  /** @}  */
                
                  // 20.3.3 comparisons
                  /** @defgroup s20_3_3_comparisons Comparison Classes
                   *  The library provides six wrapper functors for all the basic comparisons
                   *  in C++, like @c <.
                   *
                   *  @{
                   */
                  /// One of the @link s20_3_3_comparisons comparison functors@endlink.
                  template <class _Tp>
                    struct equal_to : public binary_function<_Tp, _Tp, bool>
                    {
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x == __y; }
                    };
                
                  /// One of the @link s20_3_3_comparisons comparison functors@endlink.
                  template <class _Tp>
                    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
                    {
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x != __y; }
                    };
                
                  /// One of the @link s20_3_3_comparisons comparison functors@endlink.
                  template <class _Tp>
                    struct greater : public binary_function<_Tp, _Tp, bool>
                    {
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x > __y; }
                    };
                
                  /// One of the @link s20_3_3_comparisons comparison functors@endlink.
                  template <class _Tp>
                    struct less : public binary_function<_Tp, _Tp, bool>
                    {
                      bool
         553 ->       operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x < __y; }
                    };
                
                  /// One of the @link s20_3_3_comparisons comparison functors@endlink.
                  template <class _Tp>
                    struct greater_equal : public binary_function<_Tp, _Tp, bool>
                    {
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x >= __y; }
                    };
                
                  /// One of the @link s20_3_3_comparisons comparison functors@endlink.
                  template <class _Tp>
                    struct less_equal : public binary_function<_Tp, _Tp, bool>
                    {
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x <= __y; }
                    };
                  /** @}  */
                
                  // 20.3.4 logical operations
                  /** @defgroup s20_3_4_logical Boolean Operations Classes
                   *  Here are wrapper functors for Boolean operations:  @c &&, @c ||, and @c !.
                   *
                   *  @{
                   */
                  /// One of the @link s20_3_4_logical Boolean operations functors@endlink.
                  template <class _Tp>
                    struct logical_and : public binary_function<_Tp, _Tp, bool>
                    {
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x && __y; }
                    };
                
                  /// One of the @link s20_3_4_logical Boolean operations functors@endlink.
                  template <class _Tp>
                    struct logical_or : public binary_function<_Tp, _Tp, bool>
                    {
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x || __y; }
                    };
                
                  /// One of the @link s20_3_4_logical Boolean operations functors@endlink.
                  template <class _Tp>
                    struct logical_not : public unary_function<_Tp, bool>
                    {
                      bool
                      operator()(const _Tp& __x) const
                      { return !__x; }
                    };
                  /** @}  */
                
                  // 20.3.5 negators
                  /** @defgroup s20_3_5_negators Negators
                   *  The functions @c not1 and @c not2 each take a predicate functor
                   *  and return an instance of @c unary_negate or
                   *  @c binary_negate, respectively.  These classes are functors whose
                   *  @c operator() performs the stored predicate function and then returns
                   *  the negation of the result.
                   *
                   *  For example, given a vector of integers and a trivial predicate,
                   *  \code
                   *  struct IntGreaterThanThree
                   *    : public std::unary_function<int, bool>
                   *  {
                   *      bool operator() (int x) { return x > 3; }
                   *  };
                   *
                   *  std::find_if (v.begin(), v.end(), not1(IntGreaterThanThree()));
                   *  \endcode
                   *  The call to @c find_if will locate the first index (i) of @c v for which
                   *  "!(v[i] > 3)" is true.
                   *
                   *  The not1/unary_negate combination works on predicates taking a single
                   *  argument.  The not2/binary_negate combination works on predicates which
                   *  take two arguments.
                   *
                   *  @{
                   */
                  /// One of the @link s20_3_5_negators negation functors@endlink.
                  template <class _Predicate>
                    class unary_negate
                    : public unary_function<typename _Predicate::argument_type, bool>
                    {
                    protected:
                      _Predicate _M_pred;
                    public:
                      explicit
                      unary_negate(const _Predicate& __x) : _M_pred(__x) {}
                
                      bool
                      operator()(const typename _Predicate::argument_type& __x) const
                      { return !_M_pred(__x); }
                    };
                
                  /// One of the @link s20_3_5_negators negation functors@endlink.
                  template <class _Predicate>
                    inline unary_negate<_Predicate>
                    not1(const _Predicate& __pred)
                    { return unary_negate<_Predicate>(__pred); }
                
                  /// One of the @link s20_3_5_negators negation functors@endlink.
                  template <class _Predicate>
                    class binary_negate
                    : public binary_function<typename _Predicate::first_argument_type,
                			     typename _Predicate::second_argument_type,
                			     bool>
                    {
                    protected:
                      _Predicate _M_pred;
                    public:
                      explicit
                      binary_negate(const _Predicate& __x)
                      : _M_pred(__x) { }
                
                      bool
                      operator()(const typename _Predicate::first_argument_type& __x,
                		 const typename _Predicate::second_argument_type& __y) const
                      { return !_M_pred(__x, __y); }
                    };
                
                  /// One of the @link s20_3_5_negators negation functors@endlink.
                  template <class _Predicate>
                    inline binary_negate<_Predicate>
                    not2(const _Predicate& __pred)
                    { return binary_negate<_Predicate>(__pred); }
                  /** @}  */
                
                  // 20.3.6 binders
                  /** @defgroup s20_3_6_binder Binder Classes
                   *  Binders turn functions/functors with two arguments into functors with
                   *  a single argument, storing an argument to be applied later.  For
                   *  example, a variable @c B of type @c binder1st is constructed from a
                   *  functor @c f and an argument @c x.  Later, B's @c operator() is called
                   *  with a single argument @c y.  The return value is the value of @c f(x,y).
                   *  @c B can be "called" with various arguments (y1, y2, ...) and will in
                   *  turn call @c f(x,y1), @c f(x,y2), ...
                   *
                   *  The function @c bind1st is provided to save some typing.  It takes the
                   *  function and an argument as parameters, and returns an instance of
                   *  @c binder1st.
                   *
                   *  The type @c binder2nd and its creator function @c bind2nd do the same
                   *  thing, but the stored argument is passed as the second parameter instead
                   *  of the first, e.g., @c bind2nd(std::minus<float>,1.3) will create a
                   *  functor whose @c operator() accepts a floating-point number, subtracts
                   *  1.3 from it, and returns the result.  (If @c bind1st had been used,
                   *  the functor would perform "1.3 - x" instead.
                   *
                   *  Creator-wrapper functions like @c bind1st are intended to be used in
                   *  calling algorithms.  Their return values will be temporary objects.
                   *  (The goal is to not require you to type names like
                   *  @c std::binder1st<std::plus<int>> for declaring a variable to hold the
                   *  return value from @c bind1st(std::plus<int>,5).
                   *
                   *  These become more useful when combined with the composition functions.
                   *
                   *  @{
                   */
                  /// One of the @link s20_3_6_binder binder functors@endlink.
                  template <class _Operation>
                    class binder1st
                    : public unary_function<typename _Operation::second_argument_type,
                			    typename _Operation::result_type>
                    {
                    protected:
                      _Operation op;
                      typename _Operation::first_argument_type value;
                    public:
                      binder1st(const _Operation& __x,
                		const typename _Operation::first_argument_type& __y)
                      : op(__x), value(__y) {}
                
                      typename _Operation::result_type
                      operator()(const typename _Operation::second_argument_type& __x) const
                      { return op(value, __x); }
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 109.  Missing binders for non-const sequence elements
                      typename _Operation::result_type
                      operator()(typename _Operation::second_argument_type& __x) const
                      { return op(value, __x); }
                    };
                
                  /// One of the @link s20_3_6_binder binder functors@endlink.
                  template <class _Operation, class _Tp>
                    inline binder1st<_Operation>
                    bind1st(const _Operation& __fn, const _Tp& __x)
                    {
                      typedef typename _Operation::first_argument_type _Arg1_type;
                      return binder1st<_Operation>(__fn, _Arg1_type(__x));
                    }
                
                  /// One of the @link s20_3_6_binder binder functors@endlink.
                  template <class _Operation>
                    class binder2nd
                    : public unary_function<typename _Operation::first_argument_type,
                			    typename _Operation::result_type>
                    {
                    protected:
                      _Operation op;
                      typename _Operation::second_argument_type value;
                    public:
                      binder2nd(const _Operation& __x,
                		const typename _Operation::second_argument_type& __y)
                      : op(__x), value(__y) {}
                
                      typename _Operation::result_type
                      operator()(const typename _Operation::first_argument_type& __x) const
                      { return op(__x, value); }
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 109.  Missing binders for non-const sequence elements
                      typename _Operation::result_type
                      operator()(typename _Operation::first_argument_type& __x) const
                      { return op(__x, value); }
                    };
                
                  /// One of the @link s20_3_6_binder binder functors@endlink.
                  template <class _Operation, class _Tp>
                    inline binder2nd<_Operation>
                    bind2nd(const _Operation& __fn, const _Tp& __x)
                    {
                      typedef typename _Operation::second_argument_type _Arg2_type;
                      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
                    }
                  /** @}  */
                
                  // 20.3.7 adaptors pointers functions
                  /** @defgroup s20_3_7_adaptors Adaptors for pointers to functions
                   *  The advantage of function objects over pointers to functions is that
                   *  the objects in the standard library declare nested typedefs describing
                   *  their argument and result types with uniform names (e.g., @c result_type
                   *  from the base classes @c unary_function and @c binary_function).
                   *  Sometimes those typedefs are required, not just optional.
                   *
                   *  Adaptors are provided to turn pointers to unary (single-argument) and
                   *  binary (double-argument) functions into function objects.  The
                   *  long-winded functor @c pointer_to_unary_function is constructed with a
                   *  function pointer @c f, and its @c operator() called with argument @c x
                   *  returns @c f(x).  The functor @c pointer_to_binary_function does the same
                   *  thing, but with a double-argument @c f and @c operator().
                   *
                   *  The function @c ptr_fun takes a pointer-to-function @c f and constructs
                   *  an instance of the appropriate functor.
                   *
                   *  @{
                   */
                  /// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.
                  template <class _Arg, class _Result>
                    class pointer_to_unary_function : public unary_function<_Arg, _Result>
                    {
                    protected:
                      _Result (*_M_ptr)(_Arg);
                    public:
                      pointer_to_unary_function() {}
                
                      explicit
                      pointer_to_unary_function(_Result (*__x)(_Arg))
                      : _M_ptr(__x) {}
                
                      _Result
                      operator()(_Arg __x) const
                      { return _M_ptr(__x); }
                    };
                
                  /// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.
                  template <class _Arg, class _Result>
                    inline pointer_to_unary_function<_Arg, _Result>
                    ptr_fun(_Result (*__x)(_Arg))
                    { return pointer_to_unary_function<_Arg, _Result>(__x); }
                
                  /// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.
                  template <class _Arg1, class _Arg2, class _Result>
                    class pointer_to_binary_function
                    : public binary_function<_Arg1, _Arg2, _Result>
                    {
                    protected:
                      _Result (*_M_ptr)(_Arg1, _Arg2);
                    public:
                      pointer_to_binary_function() {}
                
                      explicit
                      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
                      : _M_ptr(__x) {}
                
                      _Result
                      operator()(_Arg1 __x, _Arg2 __y) const
                      { return _M_ptr(__x, __y); }
                    };
                
                  /// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.
                  template <class _Arg1, class _Arg2, class _Result>
                    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
                    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
                    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }
                  /** @}  */
                
                  template <class _Tp>
                    struct _Identity : public unary_function<_Tp,_Tp>
                    {
                      _Tp&
                      operator()(_Tp& __x) const
                      { return __x; }
                
                      const _Tp&
                      operator()(const _Tp& __x) const
                      { return __x; }
                    };
                
                  template <class _Pair>
                    struct _Select1st : public unary_function<_Pair,
                					      typename _Pair::first_type>
                    {
                      typename _Pair::first_type&
                      operator()(_Pair& __x) const
                      { return __x.first; }
                
                      const typename _Pair::first_type&
         526 ->       operator()(const _Pair& __x) const
                      { return __x.first; }
                    };
                
                  template <class _Pair>
                    struct _Select2nd : public unary_function<_Pair,
                					      typename _Pair::second_type>
                    {
                      typename _Pair::second_type&
                      operator()(_Pair& __x) const
                      { return __x.second; }
                
                      const typename _Pair::second_type&
                      operator()(const _Pair& __x) const
                      { return __x.second; }
                    };
                
                  // 20.3.8 adaptors pointers members
                  /** @defgroup s20_3_8_memadaptors Adaptors for pointers to members
                   *  There are a total of 8 = 2^3 function objects in this family.
                   *   (1) Member functions taking no arguments vs member functions taking
                   *        one argument.
                   *   (2) Call through pointer vs call through reference.
                   *   (3) Const vs non-const member function.
                   *
                   *  All of this complexity is in the function objects themselves.  You can
                   *   ignore it by using the helper function mem_fun and mem_fun_ref,
                   *   which create whichever type of adaptor is appropriate.
                   *
                   *  @{
                   */
                  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
                  template <class _Ret, class _Tp>
                    class mem_fun_t : public unary_function<_Tp*, _Ret>
                    {
                    public:
                      explicit
                      mem_fun_t(_Ret (_Tp::*__pf)())
                      : _M_f(__pf) {}
                
                      _Ret
                      operator()(_Tp* __p) const
                      { return (__p->*_M_f)(); }
                    private:
                      _Ret (_Tp::*_M_f)();
                    };
                
                  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
                  template <class _Ret, class _Tp>
                    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
                    {
                    public:
                      explicit
                      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
                      : _M_f(__pf) {}
                
                      _Ret
                      operator()(const _Tp* __p) const
                      { return (__p->*_M_f)(); }
                    private:
                      _Ret (_Tp::*_M_f)() const;
                    };
                
                  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
                  template <class _Ret, class _Tp>
                    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
                    {
                    public:
                      explicit
                      mem_fun_ref_t(_Ret (_Tp::*__pf)())
                      : _M_f(__pf) {}
                
                      _Ret
                      operator()(_Tp& __r) const
                      { return (__r.*_M_f)(); }
                    private:
                      _Ret (_Tp::*_M_f)();
                  };
                
                  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
                  template <class _Ret, class _Tp>
                    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
                    {
                    public:
                      explicit
                      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
                      : _M_f(__pf) {}
                
                      _Ret
                      operator()(const _Tp& __r) const
                      { return (__r.*_M_f)(); }
                    private:
                      _Ret (_Tp::*_M_f)() const;
                    };
                
                  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
                  template <class _Ret, class _Tp, class _Arg>
                    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
                    {
                    public:
                      explicit
                      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
                      : _M_f(__pf) {}
                
                      _Ret
                      operator()(_Tp* __p, _Arg __x) const
                      { return (__p->*_M_f)(__x); }
                    private:
                      _Ret (_Tp::*_M_f)(_Arg);
                    };
                
                  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
                  template <class _Ret, class _Tp, class _Arg>
                    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
                    {
                    public:
                      explicit
                      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
                      : _M_f(__pf) {}
                
                      _Ret
                      operator()(const _Tp* __p, _Arg __x) const
                      { return (__p->*_M_f)(__x); }
                    private:
                      _Ret (_Tp::*_M_f)(_Arg) const;
                    };
                
                  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
                  template <class _Ret, class _Tp, class _Arg>
                    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
                    {
                    public:
                      explicit
                      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
                      : _M_f(__pf) {}
                
                      _Ret
                      operator()(_Tp& __r, _Arg __x) const
                      { return (__r.*_M_f)(__x); }
                    private:
                      _Ret (_Tp::*_M_f)(_Arg);
                    };
                
                  /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.
                  template <class _Ret, class _Tp, class _Arg>
                    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
                    {
                    public:
                      explicit
                      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
                      : _M_f(__pf) {}
                
                      _Ret
                      operator()(const _Tp& __r, _Arg __x) const
                      { return (__r.*_M_f)(__x); }
                    private:
                      _Ret (_Tp::*_M_f)(_Arg) const;
                    };
                
                  // Mem_fun adaptor helper functions.  There are only two:
                  // mem_fun and mem_fun_ref.
                  template <class _Ret, class _Tp>
                    inline mem_fun_t<_Ret, _Tp>
                    mem_fun(_Ret (_Tp::*__f)())
                    { return mem_fun_t<_Ret, _Tp>(__f); }
                
                  template <class _Ret, class _Tp>
                    inline const_mem_fun_t<_Ret, _Tp>
                    mem_fun(_Ret (_Tp::*__f)() const)
                    { return const_mem_fun_t<_Ret, _Tp>(__f); }
                
                  template <class _Ret, class _Tp>
                    inline mem_fun_ref_t<_Ret, _Tp>
                    mem_fun_ref(_Ret (_Tp::*__f)())
                    { return mem_fun_ref_t<_Ret, _Tp>(__f); }
                
                  template <class _Ret, class _Tp>
                    inline const_mem_fun_ref_t<_Ret, _Tp>
                    mem_fun_ref(_Ret (_Tp::*__f)() const)
                    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }
                
                  template <class _Ret, class _Tp, class _Arg>
                    inline mem_fun1_t<_Ret, _Tp, _Arg>
                    mem_fun(_Ret (_Tp::*__f)(_Arg))
                    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }
                
                  template <class _Ret, class _Tp, class _Arg>
                    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
                    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
                    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }
                
                  template <class _Ret, class _Tp, class _Arg>
                    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
                    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
                    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
                
                  template <class _Ret, class _Tp, class _Arg>
                    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
                    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
                    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
                
                  /** @}  */
                
                } // namespace std
                
                #endif /* _FUNCTION_H */
                
                // Local Variables:
                // mode:C++
                // End:


Top 10 Lines:

     Line      Count

      226        553
      550        526

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

     1079   Total number of line executions
   539.50   Average executions per line


*** File /home/tyler/Desktop/fland2/fland.h:
                // The main interface file. Any program can include this file and have access to all the
                // fland interface and functionality.
                // fland is a class
                #ifndef FLAND_H
                #define FLAND_H
                
                using namespace std;
                
                
                // The includes were looking messy so I put them in this file.
                #include <string>
                #include "defines.h"
                #include "env.h"
                class FmlParser;
                class BaseEnt;
                class Camera;
                
                class Fland
                {
                	public:
                	// the seed function is momentarily broken
                	Fland( int inSeed );
                	~Fland();
                
                	double targetFrameRate;
                	int maxCreates;
                
                	// The actual morph ammount being used at any given moment
                	double morphPercentage;
                
                	// this must be called before draw();
                	int recalculateView();
                	// renders the whole landscape. Must call recalculateView first!
                	int draw();
                	void dump( ostream&, int ); // each entity writes it's attributes to cout.
                
                	// This is the clostest vertex or entity that is being drawn this frame.
                	// The near clipping plane should be this value.
                	DIS_TYPE closestRenderDistance;
                	// The farthest vertex being rendered.
                	DIS_TYPE farthestRenderDistance;
                
                	// pointer to the beginning!
                	BaseEnt *firstEnt;
                	Camera *camera;
                	FmlParser *fmlParser;
                
                	// this keeps track of fland's environment stuff
                	// the camera uses it a lot.
                	Env env;
                
                	inline void setSplitVisibility( DIS_TYPE );
                	inline DIS_TYPE getSplitVisibility();
                	inline DIS_TYPE getInverseSplitVisibility();
                
                	// This function builds the html files to view the rules graphically.
                	// All files are stored in the folder 'html' in the current directory.
                	// It first builds a single index.html file with a broad layout of the
                	// entities and thier rules.
                	// Then it creates a single simple html file for every each rule and
                	// entity that will be displayed when the user clicks on one of the
                	// links in index.html
                	void buildRuleLayout();
                
                	// this dumps a full listing of every object and it's rules to a file.
                	// called by pressing 'o' while fland is running.
                	void dumpObjectsToFile( string fileName );
                
                	static Fland* fland;
                
                
                
                	private:
                	DIS_TYPE splitVisibility;
                	DIS_TYPE inverseSplitVisibility;
                
                };
                
           7 -> inline void Fland::setSplitVisibility( DIS_TYPE inVal )
                {
                	splitVisibility = inVal;
                	inverseSplitVisibility = 1.0 / inVal;
                }
                
          12 -> inline DIS_TYPE Fland::getSplitVisibility()
                {
                	return splitVisibility;
                }
     1580165 -> inline DIS_TYPE Fland::getInverseSplitVisibility()
                {
                	return inverseSplitVisibility;
                }
                
                
     7356145 -> inline Fland* getFlandPtr(){ return Fland::fland; }
                void resetFland(); // defined in main.cpp, used in events.cpp
                
                #endif


Top 10 Lines:

     Line      Count

       95    7356145
       89    1580165
       85         12
       79          7

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

  8936329   Total number of line executions
2234082.25   Average executions per line


*** File /home/tyler/Desktop/fland2/perlinnoise.h:
                #ifndef PERLINNOISE_H
                #define PERLINNOISE_H
                
                #include <math.h>
                #include <iostream>
                
                using namespace std;
                
                //*
                // IMPLEMENTATION OF IMPROVED NOISE - COPYRIGHT 2002 KEN PERLIN.
                class PerlinNoise
                {
                    public:
                
                    int p[512];
                    int permutation[256];
                
           2 ->     PerlinNoise(){
                        for (int i=0; i < 256 ; i++) p[256+i] = p[i] = rand() % 256;
                        
                //        p = { 151,160,137,91,90,15,
                //        131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
                //        190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
                //        88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
                //        77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
                //        102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
                //        135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
                //        5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
                //        223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
                //        129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
                //        251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
                //        49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
                //        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180
                //        };
                    }
                
      157959 ->    double fade(double t) { return t * t * t * (t * (t * 6 - 15) + 10); }
      368571 ->    double lerp(double t, double a, double b) { return a + t * (b - a); }
      421224 ->    double grad(int hash, double x, double y, double z) {
                      int h = hash & 15;                      // CONVERT LO 4 BITS OF HASH CODE
                      double u = h<8 ? x : y;                 // INTO 12 GRADIENT DIRECTIONS.
                      double v = h<4 ? y : h==12||h==14 ? x : z;
                      return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);
                   }
       52653 ->    double noise(double x, double y, double z) {
                      int X = (int)floor(x) & 255;                  // FIND UNIT CUBE THAT
                      int Y = (int)floor(y) & 255;                  // CONTAINS POINT.
                      int  Z = (int)floor(z) & 255;
                      x -= floor(x);                                // FIND RELATIVE X,Y,Z
                      y -= floor(y);                                // OF POINT IN CUBE.
                      z -= floor(z);
                      double u = fade(x);                                // COMPUTE FADE CURVES
                      double v = fade(y);                                // FOR EACH OF X,Y,Z.
                      double w = fade(z);
                      int A = p[X  ]+Y, AA = p[A]+Z, AB = p[A+1]+Z;      // HASH COORDINATES OF
                      int B = p[X+1]+Y, BA = p[B]+Z, BB = p[B+1]+Z;      // THE 8 CUBE CORNERS,
                
                      return lerp(w, lerp(v, lerp(u, grad(p[AA  ], x  , y  , z   ),  // AND ADD
                                                     grad(p[BA  ], x-1, y  , z   )), // BLENDED
                                             lerp(u, grad(p[AB  ], x  , y-1, z   ),  // RESULTS
                                                     grad(p[BB  ], x-1, y-1, z   ))),// FROM  8
                                     lerp(v, lerp(u, grad(p[AA+1], x  , y  , z-1 ),  // CORNERS
                                                     grad(p[BA+1], x-1, y  , z-1 )), // OF CUBE
                                             lerp(u, grad(p[AB+1], x  , y-1, z-1 ),
                                                     grad(p[BB+1], x-1, y-1, z-1 ))));
                   }
                
                    // Runs the noise function recursively
                    // PARAMS:
                    //   - initialSize: The frequency of the initial pass. 
                    //   - iterations: the number of times to do this. Each iteration
                    //     the frequency doubles
                    //   - x, y, z: The quardinates of this point
                    //   - amplitudeFalloff: Each iteration the amplitude normally is about
                    //     half of what the last iteration was. Half is the default.
                    // RETURNS:
                    //   - the noise value of this point. Between -1 and 1.
       17551 ->     double multipleNoise( double initialFrequency, int iterations, double x, double y, double z, double amplitudeFalloff = 0.5 )
                    {
                        double retVal = 0.0;
                        double amplitude = 1.0;
                        double freq = initialFrequency;
                
                        for( int i=0; i<iterations; ++i )
                        {
                            double n = noise( x * freq, y * freq, z * freq ) * amplitude;
                            retVal += n;
                
                            amplitude *= amplitudeFalloff;
                            freq *= 2.0;
                        }
                        return( retVal );
                    }
                };
                //*/
                
                
                
                #endif 
                


Top 10 Lines:

     Line      Count

       39     421224
       38     368571
       37     157959
       45      52653
       78      17551
       18          2

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

  1017960   Total number of line executions
169660.00   Average executions per line


*** File /usr/lib/gcc/i486-linux-gnu/4.1.2/../../../../include/c++/4.1.2/bits/char_traits.h:
                // Character Traits for use by standard string and iostream -*- C++ -*-
                
                // Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
                // Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 2, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // You should have received a copy of the GNU General Public License along
                // with this library; see the file COPYING.  If not, write to the Free
                // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
                // USA.
                
                // As a special exception, you may use this file as part of a free software
                // library without restriction.  Specifically, if other files instantiate
                // templates or use macros or inline functions from this file, or you compile
                // this file and link it with other files to produce an executable, this
                // file does not by itself cause the resulting executable to be covered by
                // the GNU General Public License.  This exception does not however
                // invalidate any other reasons why the executable file might be covered by
                // the GNU General Public License.
                
                //
                // ISO C++ 14882: 21  Strings library
                //
                
                /** @file char_traits.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _CHAR_TRAITS_H
                #define _CHAR_TRAITS_H 1
                
                #pragma GCC system_header
                
                #include <cstring>            // For memmove, memset, memchr
                #include <bits/stl_algobase.h>// For copy, lexicographical_compare, fill_n
                #include <bits/postypes.h>    // For streampos
                
                namespace __gnu_cxx
                {
                  /**
                   *  @brief  Mapping from character type to associated types.
                   *
                   *  @note This is an implementation class for the generic version
                   *  of char_traits.  It defines int_type, off_type, pos_type, and
                   *  state_type.  By default these are unsigned long, streamoff,
                   *  streampos, and mbstate_t.  Users who need a different set of
                   *  types, but who don't need to change the definitions of any function
                   *  defined in char_traits, can specialize __gnu_cxx::_Char_types
                   *  while leaving __gnu_cxx::char_traits alone. */
                  template <class _CharT>
                    struct _Char_types
                    {
                      typedef unsigned long   int_type;
                      typedef std::streampos  pos_type;
                      typedef std::streamoff  off_type;
                      typedef std::mbstate_t  state_type;
                    };
                
                
                  /**
                   *  @brief  Base class used to implement std::char_traits.
                   *
                   *  @note For any given actual character type, this definition is
                   *  probably wrong.  (Most of the member functions are likely to be
                   *  right, but the int_type and state_type typedefs, and the eof()
                   *  member function, are likely to be wrong.)  The reason this class
                   *  exists is so users can specialize it.  Classes in namespace std
                   *  may not be specialized for fundamentl types, but classes in
                   *  namespace __gnu_cxx may be.
                   *
                   *  See http://gcc.gnu.org/onlinedocs/libstdc++/21_strings/howto.html#5
                   *  for advice on how to make use of this class for "unusual" character
                   *  types. Also, check out include/ext/pod_char_traits.h.  
                   */
                  template<typename _CharT>
                    struct char_traits
                    {
                      typedef _CharT                                    char_type;
                      typedef typename _Char_types<_CharT>::int_type    int_type;
                      typedef typename _Char_types<_CharT>::pos_type    pos_type;
                      typedef typename _Char_types<_CharT>::off_type    off_type;
                      typedef typename _Char_types<_CharT>::state_type  state_type;
                
                      static void
                      assign(char_type& __c1, const char_type& __c2)
                      { __c1 = __c2; }
                
                      static bool
                      eq(const char_type& __c1, const char_type& __c2)
                      { return __c1 == __c2; }
                
                      static bool
                      lt(const char_type& __c1, const char_type& __c2)
                      { return __c1 < __c2; }
                
                      static int
                      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);
                
                      static std::size_t
                      length(const char_type* __s);
                
                      static const char_type*
                      find(const char_type* __s, std::size_t __n, const char_type& __a);
                
                      static char_type*
                      move(char_type* __s1, const char_type* __s2, std::size_t __n);
                
                      static char_type*
                      copy(char_type* __s1, const char_type* __s2, std::size_t __n);
                
                      static char_type*
                      assign(char_type* __s, std::size_t __n, char_type __a);
                
                      static char_type
                      to_char_type(const int_type& __c)
                      { return static_cast<char_type>(__c); }
                
                      static int_type
                      to_int_type(const char_type& __c)
                      { return static_cast<int_type>(__c); }
                
                      static bool
                      eq_int_type(const int_type& __c1, const int_type& __c2)
                      { return __c1 == __c2; }
                
                      static int_type
                      eof()
                      { return static_cast<int_type>(EOF); }
                
                      static int_type
                      not_eof(const int_type& __c)
                      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
                    };
                
                  template<typename _CharT>
                    int
                    char_traits<_CharT>::
                    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
                    {
                      for (size_t __i = 0; __i < __n; ++__i)
                	if (lt(__s1[__i], __s2[__i]))
                	  return -1;
                	else if (lt(__s2[__i], __s1[__i]))
                	  return 1;
                      return 0;
                    }
                
                  template<typename _CharT>
                    std::size_t
                    char_traits<_CharT>::
                    length(const char_type* __p)
                    {
                      std::size_t __i = 0;
                      while (!eq(__p[__i], char_type()))
                        ++__i;
                      return __i;
                    }
                
                  template<typename _CharT>
                    const typename char_traits<_CharT>::char_type*
                    char_traits<_CharT>::
                    find(const char_type* __s, std::size_t __n, const char_type& __a)
                    {
                      for (std::size_t __i = 0; __i < __n; ++__i)
                        if (eq(__s[__i], __a))
                          return __s + __i;
                      return 0;
                    }
                
                  template<typename _CharT>
                    typename char_traits<_CharT>::char_type*
                    char_traits<_CharT>::
                    move(char_type* __s1, const char_type* __s2, std::size_t __n)
                    {
                      return static_cast<_CharT*>(std::memmove(__s1, __s2,
                					       __n * sizeof(char_type)));
                    }
                
                  template<typename _CharT>
                    typename char_traits<_CharT>::char_type*
                    char_traits<_CharT>::
                    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
                    {
                      std::copy(__s2, __s2 + __n, __s1);
                      return __s1;
                    }
                
                  template<typename _CharT>
                    typename char_traits<_CharT>::char_type*
                    char_traits<_CharT>::
                    assign(char_type* __s, std::size_t __n, char_type __a)
                    {
                      std::fill_n(__s, __n, __a);
                      return __s;
                    }
                }
                
                namespace std
                {
                  // 21.1
                  /**
                   *  @brief  Basis for explicit traits specializations.
                   *
                   *  @note  For any given actual character type, this definition is
                   *  probably wrong.  Since this is just a thin wrapper around
                   *  __gnu_cxx::char_traits, it is possible to achieve a more
                   *  appropriate definition by specializing __gnu_cxx::char_traits.
                   *
                   *  See http://gcc.gnu.org/onlinedocs/libstdc++/21_strings/howto.html#5
                   *  for advice on how to make use of this class for "unusual" character
                   *  types. Also, check out include/ext/pod_char_traits.h.
                  */
                  template<class _CharT>
                    struct char_traits : public __gnu_cxx::char_traits<_CharT>
                    { };
                
                
                  /// @brief  21.1.3.1  char_traits specializations
                  template<>
                    struct char_traits<char>
                    {
                      typedef char              char_type;
                      typedef int               int_type;
                      typedef streampos         pos_type;
                      typedef streamoff         off_type;
                      typedef mbstate_t         state_type;
                
                      static void
                      assign(char_type& __c1, const char_type& __c2)
                      { __c1 = __c2; }
                
                      static bool
                      eq(const char_type& __c1, const char_type& __c2)
                      { return __c1 == __c2; }
                
                      static bool
                      lt(const char_type& __c1, const char_type& __c2)
                      { return __c1 < __c2; }
                
                      static int
                      compare(const char_type* __s1, const char_type* __s2, size_t __n)
                      { return memcmp(__s1, __s2, __n); }
                
                      static size_t
          33 ->       length(const char_type* __s)
                      { return strlen(__s); }
                
                      static const char_type*
                      find(const char_type* __s, size_t __n, const char_type& __a)
                      { return static_cast<const char_type*>(memchr(__s, __a, __n)); }
                
                      static char_type*
                      move(char_type* __s1, const char_type* __s2, size_t __n)
                      { return static_cast<char_type*>(memmove(__s1, __s2, __n)); }
                
                      static char_type*
                      copy(char_type* __s1, const char_type* __s2, size_t __n)
                      { return static_cast<char_type*>(memcpy(__s1, __s2, __n)); }
                
                      static char_type*
                      assign(char_type* __s, size_t __n, char_type __a)
                      { return static_cast<char_type*>(memset(__s, __a, __n)); }
                
                      static char_type
                      to_char_type(const int_type& __c)
                      { return static_cast<char_type>(__c); }
                
                      // To keep both the byte 0xff and the eof symbol 0xffffffff
                      // from ending up as 0xffffffff.
                      static int_type
                      to_int_type(const char_type& __c)
                      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }
                
                      static bool
                      eq_int_type(const int_type& __c1, const int_type& __c2)
                      { return __c1 == __c2; }
                
                      static int_type
                      eof() { return static_cast<int_type>(EOF); }
                
                      static int_type
                      not_eof(const int_type& __c)
                      { return (__c == eof()) ? 0 : __c; }
                  };
                
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  /// @brief  21.1.3.2  char_traits specializations
                  template<>
                    struct char_traits<wchar_t>
                    {
                      typedef wchar_t           char_type;
                      typedef wint_t            int_type;
                      typedef streamoff         off_type;
                      typedef wstreampos        pos_type;
                      typedef mbstate_t         state_type;
                
                      static void
                      assign(char_type& __c1, const char_type& __c2)
                      { __c1 = __c2; }
                
                      static bool
                      eq(const char_type& __c1, const char_type& __c2)
                      { return __c1 == __c2; }
                
                      static bool
                      lt(const char_type& __c1, const char_type& __c2)
                      { return __c1 < __c2; }
                
                      static int
                      compare(const char_type* __s1, const char_type* __s2, size_t __n)
                      { return wmemcmp(__s1, __s2, __n); }
                
                      static size_t
                      length(const char_type* __s)
                      { return wcslen(__s); }
                
                      static const char_type*
                      find(const char_type* __s, size_t __n, const char_type& __a)
                      { return wmemchr(__s, __a, __n); }
                
                      static char_type*
                      move(char_type* __s1, const char_type* __s2, size_t __n)
                      { return wmemmove(__s1, __s2, __n); }
                
                      static char_type*
                      copy(char_type* __s1, const char_type* __s2, size_t __n)
                      { return wmemcpy(__s1, __s2, __n); }
                
                      static char_type*
                      assign(char_type* __s, size_t __n, char_type __a)
                      { return wmemset(__s, __a, __n); }
                
                      static char_type
                      to_char_type(const int_type& __c) { return char_type(__c); }
                
                      static int_type
                      to_int_type(const char_type& __c) { return int_type(__c); }
                
                      static bool
                      eq_int_type(const int_type& __c1, const int_type& __c2)
                      { return __c1 == __c2; }
                
                      static int_type
                      eof() { return static_cast<int_type>(WEOF); }
                
                      static int_type
                      not_eof(const int_type& __c)
                      { return eq_int_type(__c, eof()) ? 0 : __c; }
                  };
                #endif //_GLIBCXX_USE_WCHAR_T
                
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

      256         33

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       33   Total number of line executions
    33.00   Average executions per line


*** File /usr/lib/gcc/i486-linux-gnu/4.1.2/../../../../include/c++/4.1.2/bits/stl_pair.h:
                // Pair implementation -*- C++ -*-
                
                // Copyright (C) 2001, 2004 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 2, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // You should have received a copy of the GNU General Public License along
                // with this library; see the file COPYING.  If not, write to the Free
                // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
                // USA.
                
                // As a special exception, you may use this file as part of a free software
                // library without restriction.  Specifically, if other files instantiate
                // templates or use macros or inline functions from this file, or you compile
                // this file and link it with other files to produce an executable, this
                // file does not by itself cause the resulting executable to be covered by
                // the GNU General Public License.  This exception does not however
                // invalidate any other reasons why the executable file might be covered by
                // the GNU General Public License.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file stl_pair.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _PAIR_H
                #define _PAIR_H 1
                
                namespace std
                {
                  /// pair holds two objects of arbitrary type.
                  template<class _T1, class _T2>
                    struct pair
          87 ->     {
                      typedef _T1 first_type;    ///<  @c first_type is the first bound type
                      typedef _T2 second_type;   ///<  @c second_type is the second bound type
                
                      _T1 first;                 ///< @c first is a copy of the first object
                      _T2 second;                ///< @c second is a copy of the second object
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 265.  std::pair::pair() effects overly restrictive
                      /** The default constructor creates @c first and @c second using their
                       *  respective default constructors.  */
                      pair()
                      : first(), second() { }
                
                      /** Two objects may be passed to a @c pair constructor to be copied.  */
          30 ->       pair(const _T1& __a, const _T2& __b)
                      : first(__a), second(__b) { }
                
                      /** There is also a templated copy ctor for the @c pair class itself.  */
                      template<class _U1, class _U2>
                        pair(const pair<_U1, _U2>& __p)
                	: first(__p.first), second(__p.second) { }
                    };
                
                  /// Two pairs of the same type are equal iff their members are equal.
                  template<class _T1, class _T2>
                    inline bool
                    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __x.first == __y.first && __x.second == __y.second; }
                
                  /// <http://gcc.gnu.org/onlinedocs/libstdc++/20_util/howto.html#pairlt>
                  template<class _T1, class _T2>
                    inline bool
                    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __x.first < __y.first
                	     || (!(__y.first < __x.first) && __x.second < __y.second); }
                
                  /// Uses @c operator== to find the result.
                  template<class _T1, class _T2>
                    inline bool
                    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__x == __y); }
                
                  /// Uses @c operator< to find the result.
                  template<class _T1, class _T2>
                    inline bool
                    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __y < __x; }
                
                  /// Uses @c operator< to find the result.
                  template<class _T1, class _T2>
                    inline bool
                    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__y < __x); }
                
                  /// Uses @c operator< to find the result.
                  template<class _T1, class _T2>
                    inline bool
                    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__x < __y); }
                
                  /**
                   *  @brief A convenience wrapper for creating a pair from two objects.
                   *  @param  x  The first object.
                   *  @param  y  The second object.
                   *  @return   A newly-constructed pair<> object of the appropriate type.
                   *
                   *  The standard requires that the objects be passed by reference-to-const,
                   *  but LWG issue #181 says they should be passed by const value.  We follow
                   *  the LWG by default.
                   */
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 181.  make_pair() unintended behavior
                  template<class _T1, class _T2>
                    inline pair<_T1, _T2>
                    make_pair(_T1 __x, _T2 __y)
                    { return pair<_T1, _T2>(__x, __y); }
                } // namespace std
                
                #endif /* _PAIR_H */


Top 10 Lines:

     Line      Count

       69         87
       84         30

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

      117   Total number of line executions
    58.50   Average executions per line


*** File /usr/lib/gcc/i486-linux-gnu/4.1.2/../../../../include/c++/4.1.2/bits/basic_string.tcc:
                // Components for manipulating sequences of characters -*- C++ -*-
                
                // Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
                // Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 2, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // You should have received a copy of the GNU General Public License along
                // with this library; see the file COPYING.  If not, write to the Free
                // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
                // USA.
                
                // As a special exception, you may use this file as part of a free software
                // library without restriction.  Specifically, if other files instantiate
                // templates or use macros or inline functions from this file, or you compile
                // this file and link it with other files to produce an executable, this
                // file does not by itself cause the resulting executable to be covered by
                // the GNU General Public License.  This exception does not however
                // invalidate any other reasons why the executable file might be covered by
                // the GNU General Public License.
                
                /** @file basic_string.tcc
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                //
                // ISO C++ 14882: 21  Strings library
                //
                
                // Written by Jason Merrill based upon the specification by Takanori Adachi
                // in ANSI X3J16/94-0013R2.  Rewritten by Nathan Myers to ISO-14882.
                
                #ifndef _BASIC_STRING_TCC
                #define _BASIC_STRING_TCC 1
                
                #pragma GCC system_header
                
                namespace std
                {
                  template<typename _Type>
                    inline bool
                    __is_null_pointer(_Type* __ptr)
                    { return __ptr == 0; }
                
                  template<typename _Type>
                    inline bool
                    __is_null_pointer(_Type)
                    { return false; }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    const _CharT
                    basic_string<_CharT, _Traits, _Alloc>::
                    _Rep::_S_terminal = _CharT();
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::npos;
                
                  // Linker sets _S_empty_rep_storage to all 0s (one reference, empty string)
                  // at static init time (before static ctors are run).
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
                    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
                      sizeof(size_type)];
                
                  // NB: This is the special case for Input Iterators, used in
                  // istreambuf_iterators, etc.
                  // Input Iterators have a cost structure very different from
                  // pointers, calling for a different coding style.
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template<typename _InIterator>
                      _CharT*
                      basic_string<_CharT, _Traits, _Alloc>::
                      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
                		   input_iterator_tag)
                      {
                #ifndef _GLIBCXX_FULLY_DYNAMIC_STRING
                	if (__beg == __end && __a == _Alloc())
                	  return _S_empty_rep()._M_refdata();
                #endif
                	// Avoid reallocation for common case.
                	_CharT __buf[128];
                	size_type __len = 0;
                	while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
                	  {
                	    __buf[__len++] = *__beg;
                	    ++__beg;
                	  }
                	_Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
                	_M_copy(__r->_M_refdata(), __buf, __len);
                	try
                	  {
                	    while (__beg != __end)
                	      {
                		if (__len == __r->_M_capacity)
                		  {
                		    // Allocate more space.
                		    _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
                		    _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
                		    __r->_M_destroy(__a);
                		    __r = __another;
                		  }
                		__r->_M_refdata()[__len++] = *__beg;
                		++__beg;
                	      }
                	  }
                	catch(...)
                	  {
                	    __r->_M_destroy(__a);
                	    __throw_exception_again;
                	  }
                	__r->_M_set_length_and_sharable(__len);
                	return __r->_M_refdata();
                      }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template <typename _InIterator>
                      _CharT*
                      basic_string<_CharT, _Traits, _Alloc>::
                      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
                		   forward_iterator_tag)
                      {
                #ifndef _GLIBCXX_FULLY_DYNAMIC_STRING
                	if (__beg == __end && __a == _Alloc())
                	  return _S_empty_rep()._M_refdata();
                #endif
                	// NB: Not required, but considered best practice.
                	if (__builtin_expect(__is_null_pointer(__beg) && __beg != __end, 0))
                	  __throw_logic_error(__N("basic_string::_S_construct NULL not valid"));
                
                	const size_type __dnew = static_cast<size_type>(std::distance(__beg,
                								      __end));
                	// Check for out_of_range and length_error exceptions.
                	_Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
                	try
                	  { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
                	catch(...)
                	  {
                	    __r->_M_destroy(__a);
                	    __throw_exception_again;
                	  }
                	__r->_M_set_length_and_sharable(__dnew);
                	return __r->_M_refdata();
                      }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    _CharT*
                    basic_string<_CharT, _Traits, _Alloc>::
                    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
                    {
                #ifndef _GLIBCXX_FULLY_DYNAMIC_STRING
                      if (__n == 0 && __a == _Alloc())
                	return _S_empty_rep()._M_refdata();
                #endif
                      // Check for out_of_range and length_error exceptions.
                      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
                      if (__n)
                	_M_assign(__r->_M_refdata(), __n, __c);
                
                      __r->_M_set_length_and_sharable(__n);
                      return __r->_M_refdata();
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const basic_string& __str)
                    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
                					  __str.get_allocator()),
                		  __str.get_allocator())
                    { }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const _Alloc& __a)
                    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
                    { }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const basic_string& __str, size_type __pos, size_type __n)
                    : _M_dataplus(_S_construct(__str._M_data()
                			       + __str._M_check(__pos,
                						"basic_string::basic_string"),
                			       __str._M_data() + __str._M_limit(__pos, __n)
                			       + __pos, _Alloc()), _Alloc())
                    { }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const basic_string& __str, size_type __pos,
                		 size_type __n, const _Alloc& __a)
                    : _M_dataplus(_S_construct(__str._M_data()
                			       + __str._M_check(__pos,
                						"basic_string::basic_string"),
                			       __str._M_data() + __str._M_limit(__pos, __n)
                			       + __pos, __a), __a)
                    { }
                
                  // TBD: DPG annotate
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
                    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
                    { }
                
                  // TBD: DPG annotate
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const _CharT* __s, const _Alloc& __a)
                    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
                			       __s + npos, __a), __a)
                    { }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
                    : _M_dataplus(_S_construct(__n, __c, __a), __a)
                    { }
                
                  // TBD: DPG annotate
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template<typename _InputIterator>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
                    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
                    { }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    assign(const basic_string& __str)
                    {
                      if (_M_rep() != __str._M_rep())
                	{
                	  // XXX MT
                	  const allocator_type __a = this->get_allocator();
                	  _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
                	  _M_rep()->_M_dispose(__a);
                	  _M_data(__tmp);
                	}
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    assign(const _CharT* __s, size_type __n)
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      _M_check_length(this->size(), __n, "basic_string::assign");
                      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
                	return _M_replace_safe(size_type(0), this->size(), __s, __n);
                      else
                	{
                	  // Work in-place.
                	  const size_type __pos = __s - _M_data();
                	  if (__pos >= __n)
                	    _M_copy(_M_data(), __s, __n);
                	  else if (__pos)
                	    _M_move(_M_data(), __s, __n);
                	  _M_rep()->_M_set_length_and_sharable(__n);
                	  return *this;
                	}
                     }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    append(size_type __n, _CharT __c)
                    {
                      if (__n)
                	{
                	  _M_check_length(size_type(0), __n, "basic_string::append");	  
                	  const size_type __len = __n + this->size();
                	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	    this->reserve(__len);
                	  _M_assign(_M_data() + this->size(), __n, __c);
                	  _M_rep()->_M_set_length_and_sharable(__len);
                	}
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    append(const _CharT* __s, size_type __n)
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      if (__n)
                	{
                	  _M_check_length(size_type(0), __n, "basic_string::append");
                	  const size_type __len = __n + this->size();
                	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	    {
                	      if (_M_disjunct(__s))
                		this->reserve(__len);
                	      else
                		{
                		  const size_type __off = __s - _M_data();
                		  this->reserve(__len);
                		  __s = _M_data() + __off;
                		}
                	    }
                	  _M_copy(_M_data() + this->size(), __s, __n);
                	  _M_rep()->_M_set_length_and_sharable(__len);
                	}
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    append(const basic_string& __str)
                    {
                      const size_type __size = __str.size();
                      if (__size)
                	{
                	  const size_type __len = __size + this->size();
                	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	    this->reserve(__len);
                	  _M_copy(_M_data() + this->size(), __str._M_data(), __size);
                	  _M_rep()->_M_set_length_and_sharable(__len);
                	}
                      return *this;
                    }    
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    append(const basic_string& __str, size_type __pos, size_type __n)
                    {
                      __str._M_check(__pos, "basic_string::append");
                      __n = __str._M_limit(__pos, __n);
                      if (__n)
                	{
                	  const size_type __len = __n + this->size();
                	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	    this->reserve(__len);
                	  _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
                	  _M_rep()->_M_set_length_and_sharable(__len);	  
                	}
                      return *this;
                    }
                
                   template<typename _CharT, typename _Traits, typename _Alloc>
                     basic_string<_CharT, _Traits, _Alloc>&
                     basic_string<_CharT, _Traits, _Alloc>::
                     insert(size_type __pos, const _CharT* __s, size_type __n)
                     {
                       __glibcxx_requires_string_len(__s, __n);
                       _M_check(__pos, "basic_string::insert");
                       _M_check_length(size_type(0), __n, "basic_string::insert");
                       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
                         return _M_replace_safe(__pos, size_type(0), __s, __n);
                       else
                         {
                           // Work in-place.
                           const size_type __off = __s - _M_data();
                           _M_mutate(__pos, 0, __n);
                           __s = _M_data() + __off;
                           _CharT* __p = _M_data() + __pos;
                           if (__s  + __n <= __p)
                             _M_copy(__p, __s, __n);
                           else if (__s >= __p)
                             _M_copy(__p, __s + __n, __n);
                           else
                             {
                	       const size_type __nleft = __p - __s;
                               _M_copy(__p, __s, __nleft);
                               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
                             }
                           return *this;
                         }
                     }
                
                   template<typename _CharT, typename _Traits, typename _Alloc>
                     basic_string<_CharT, _Traits, _Alloc>&
                     basic_string<_CharT, _Traits, _Alloc>::
                     replace(size_type __pos, size_type __n1, const _CharT* __s,
                	     size_type __n2)
                     {
                       __glibcxx_requires_string_len(__s, __n2);
                       _M_check(__pos, "basic_string::replace");
                       __n1 = _M_limit(__pos, __n1);
                       _M_check_length(__n1, __n2, "basic_string::replace");
                       bool __left;
                       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
                         return _M_replace_safe(__pos, __n1, __s, __n2);
                       else if ((__left = __s + __n2 <= _M_data() + __pos)
                		|| _M_data() + __pos + __n1 <= __s)
                	 {
                	   // Work in-place: non-overlapping case.
                	   size_type __off = __s - _M_data();
                	   __left ? __off : (__off += __n2 - __n1);
                	   _M_mutate(__pos, __n1, __n2);
                	   _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
                	   return *this;
                	 }
                       else
                	 {
                	   // Todo: overlapping case.
                	   const basic_string __tmp(__s, __n2);
                	   return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
                	 }
                     }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::_Rep::
                    _M_destroy(const _Alloc& __a) throw ()
                    {
                      const size_type __size = sizeof(_Rep_base) +
                	                       (this->_M_capacity + 1) * sizeof(_CharT);
                      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_leak_hard()
                    {
                #ifndef _GLIBCXX_FULLY_DYNAMIC_STRING
                      if (_M_rep() == &_S_empty_rep())
                	return;
                #endif
                      if (_M_rep()->_M_is_shared())
                	_M_mutate(0, 0, 0);
                      _M_rep()->_M_set_leaked();
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
                    {
                      const size_type __old_size = this->size();
                      const size_type __new_size = __old_size + __len2 - __len1;
                      const size_type __how_much = __old_size - __pos - __len1;
                
                      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
                	{
                	  // Must reallocate.
                	  const allocator_type __a = get_allocator();
                	  _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);
                
                	  if (__pos)
                	    _M_copy(__r->_M_refdata(), _M_data(), __pos);
                	  if (__how_much)
                	    _M_copy(__r->_M_refdata() + __pos + __len2,
                		    _M_data() + __pos + __len1, __how_much);
                
                	  _M_rep()->_M_dispose(__a);
                	  _M_data(__r->_M_refdata());
                	}
                      else if (__how_much && __len1 != __len2)
                	{
                	  // Work in-place.
                	  _M_move(_M_data() + __pos + __len2,
                		  _M_data() + __pos + __len1, __how_much);
                	}
                      _M_rep()->_M_set_length_and_sharable(__new_size);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    reserve(size_type __res)
                    {
                      if (__res != this->capacity() || _M_rep()->_M_is_shared())
                        {
                	  // Make sure we don't shrink below the current size
                	  if (__res < this->size())
                	    __res = this->size();
                	  const allocator_type __a = get_allocator();
                	  _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
                	  _M_rep()->_M_dispose(__a);
                	  _M_data(__tmp);
                        }
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    swap(basic_string& __s)
                    {
                      if (_M_rep()->_M_is_leaked())
                	_M_rep()->_M_set_sharable();
                      if (__s._M_rep()->_M_is_leaked())
                	__s._M_rep()->_M_set_sharable();
                      if (this->get_allocator() == __s.get_allocator())
                	{
                	  _CharT* __tmp = _M_data();
                	  _M_data(__s._M_data());
                	  __s._M_data(__tmp);
                	}
                      // The code below can usually be optimized away.
                      else
                	{
                	  const basic_string __tmp1(_M_ibegin(), _M_iend(),
                				    __s.get_allocator());
                	  const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
                				    this->get_allocator());
                	  *this = __tmp2;
                	  __s = __tmp1;
                	}
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
                    basic_string<_CharT, _Traits, _Alloc>::_Rep::
                    _S_create(size_type __capacity, size_type __old_capacity,
                	      const _Alloc& __alloc)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 83.  String::npos vs. string::max_size()
                      if (__capacity > _S_max_size)
                	__throw_length_error(__N("basic_string::_S_create"));
                
                      // The standard places no restriction on allocating more memory
                      // than is strictly needed within this layer at the moment or as
                      // requested by an explicit application call to reserve().
                
                      // Many malloc implementations perform quite poorly when an
                      // application attempts to allocate memory in a stepwise fashion
                      // growing each allocation size by only 1 char.  Additionally,
                      // it makes little sense to allocate less linear memory than the
                      // natural blocking size of the malloc implementation.
                      // Unfortunately, we would need a somewhat low-level calculation
                      // with tuned parameters to get this perfect for any particular
                      // malloc implementation.  Fortunately, generalizations about
                      // common features seen among implementations seems to suffice.
                
                      // __pagesize need not match the actual VM page size for good
                      // results in practice, thus we pick a common value on the low
                      // side.  __malloc_header_size is an estimate of the amount of
                      // overhead per memory allocation (in practice seen N * sizeof
                      // (void*) where N is 0, 2 or 4).  According to folklore,
                      // picking this value on the high side is better than
                      // low-balling it (especially when this algorithm is used with
                      // malloc implementations that allocate memory blocks rounded up
                      // to a size which is a power of 2).
                      const size_type __pagesize = 4096;
                      const size_type __malloc_header_size = 4 * sizeof(void*);
                
                      // The below implements an exponential growth policy, necessary to
                      // meet amortized linear time requirements of the library: see
                      // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.
                      // It's active for allocations requiring an amount of memory above
                      // system pagesize. This is consistent with the requirements of the
                      // standard: http://gcc.gnu.org/ml/libstdc++/2001-07/msg00130.html
                      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
                	__capacity = 2 * __old_capacity;
                
                      // NB: Need an array of char_type[__capacity], plus a terminating
                      // null char_type() element, plus enough for the _Rep data structure.
                      // Whew. Seemingly so needy, yet so elemental.
                      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
                
                      const size_type __adj_size = __size + __malloc_header_size;
                      if (__adj_size > __pagesize && __capacity > __old_capacity)
                	{
                	  const size_type __extra = __pagesize - __adj_size % __pagesize;
                	  __capacity += __extra / sizeof(_CharT);
                	  // Never allocate a string bigger than _S_max_size.
                	  if (__capacity > _S_max_size)
                	    __capacity = _S_max_size;
                	  __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
                	}
                
                      // NB: Might throw, but no worries about a leak, mate: _Rep()
                      // does not throw.
                      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
                      _Rep *__p = new (__place) _Rep;
                      __p->_M_capacity = __capacity;
                      return __p;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    _CharT*
                    basic_string<_CharT, _Traits, _Alloc>::_Rep::
                    _M_clone(const _Alloc& __alloc, size_type __res)
                    {
                      // Requested capacity of the clone.
                      const size_type __requested_cap = this->_M_length + __res;
                      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
                				  __alloc);
                      if (this->_M_length)
                	_M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);
                
                      __r->_M_set_length_and_sharable(this->_M_length);
                      return __r->_M_refdata();
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    resize(size_type __n, _CharT __c)
                    {
                      const size_type __size = this->size();
                      _M_check_length(__size, __n, "basic_string::resize");
                      if (__size < __n)
                	this->append(__n - __size, __c);
                      else if (__n < __size)
                	this->erase(__n);
                      // else nothing (in particular, avoid calling _M_mutate() unnecessarily.)
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template<typename _InputIterator>
                      basic_string<_CharT, _Traits, _Alloc>&
                      basic_string<_CharT, _Traits, _Alloc>::
                      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
                			  _InputIterator __k2, __false_type)
                      {
                	const basic_string __s(__k1, __k2);
                	const size_type __n1 = __i2 - __i1;
                	_M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
                	return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
                			       __s.size());
                      }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
                		   _CharT __c)
                    {
                      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
                      _M_mutate(__pos1, __n1, __n2);
                      if (__n2)
                	_M_assign(_M_data() + __pos1, __n2, __c);
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
                		    size_type __n2)
                    {
                      _M_mutate(__pos1, __n1, __n2);
                      if (__n2)
                	_M_copy(_M_data() + __pos1, __s, __n2);
                      return *this;
                    }
                   
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>
                    operator+(const _CharT* __lhs,
          33 -> 	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    {
                      __glibcxx_requires_string(__lhs);
                      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
                      typedef typename __string_type::size_type	  __size_type;
                      const __size_type __len = _Traits::length(__lhs);
                      __string_type __str;
                      __str.reserve(__len + __rhs.size());
                      __str.append(__lhs, __len);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>
                    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    {
                      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
                      typedef typename __string_type::size_type	  __size_type;
                      __string_type __str;
                      const __size_type __len = __rhs.size();
                      __str.reserve(__len + 1);
                      __str.append(__size_type(1), __lhs);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    copy(_CharT* __s, size_type __n, size_type __pos) const
                    {
                      _M_check(__pos, "basic_string::copy");
                      __n = _M_limit(__pos, __n);
                      __glibcxx_requires_string_len(__s, __n);
                      if (__n)
                	_M_copy(__s, _M_data() + __pos, __n);
                      // 21.3.5.7 par 3: do not append null.  (good.)
                      return __n;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find(const _CharT* __s, size_type __pos, size_type __n) const
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      size_type __ret = npos;
                      const size_type __size = this->size();
                      if (__pos + __n <= __size)
                	{
                	  const _CharT* __data = _M_data();
                	  const _CharT* __p = std::search(__data + __pos, __data + __size,
                					  __s, __s + __n, traits_type::eq);
                	  if (__p != __data + __size || __n == 0)
                	    __ret = __p - __data;
                	}
                      return __ret;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find(_CharT __c, size_type __pos) const
                    {
                      size_type __ret = npos;
                      const size_type __size = this->size();
                      if (__pos < __size)
                	{
                	  const _CharT* __data = _M_data();
                	  const size_type __n = __size - __pos;
                	  const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
                	  if (__p)
                	    __ret = __p - __data;
                	}
                      return __ret;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    rfind(const _CharT* __s, size_type __pos, size_type __n) const
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      const size_type __size = this->size();
                      if (__n <= __size)
                	{
                	  __pos = std::min(size_type(__size - __n), __pos);
                	  const _CharT* __data = _M_data();
                	  do
                	    {
                	      if (traits_type::compare(__data + __pos, __s, __n) == 0)
                		return __pos;
                	    }
                	  while (__pos-- > 0);
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    rfind(_CharT __c, size_type __pos) const
                    {
                      size_type __size = this->size();
                      if (__size)
                	{
                	  if (--__size > __pos)
                	    __size = __pos;
                	  for (++__size; __size-- > 0; )
                	    if (traits_type::eq(_M_data()[__size], __c))
                	      return __size;
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      for (; __n && __pos < this->size(); ++__pos)
                	{
                	  const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
                	  if (__p)
                	    return __pos;
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      size_type __size = this->size();
                      if (__size && __n)
                	{
                	  if (--__size > __pos)
                	    __size = __pos;
                	  do
                	    {
                	      if (traits_type::find(__s, __n, _M_data()[__size]))
                		return __size;
                	    }
                	  while (__size-- != 0);
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      for (; __pos < this->size(); ++__pos)
                	if (!traits_type::find(__s, __n, _M_data()[__pos]))
                	  return __pos;
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_first_not_of(_CharT __c, size_type __pos) const
                    {
                      for (; __pos < this->size(); ++__pos)
                	if (!traits_type::eq(_M_data()[__pos], __c))
                	  return __pos;
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      size_type __size = this->size();
                      if (__size)
                	{
                	  if (--__size > __pos)
                	    __size = __pos;
                	  do
                	    {
                	      if (!traits_type::find(__s, __n, _M_data()[__size]))
                		return __size;
                	    }
                	  while (__size--);
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_last_not_of(_CharT __c, size_type __pos) const
                    {
                      size_type __size = this->size();
                      if (__size)
                	{
                	  if (--__size > __pos)
                	    __size = __pos;
                	  do
                	    {
                	      if (!traits_type::eq(_M_data()[__size], __c))
                		return __size;
                	    }
                	  while (__size--);
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string<_CharT, _Traits, _Alloc>::
                    compare(size_type __pos, size_type __n, const basic_string& __str) const
                    {
                      _M_check(__pos, "basic_string::compare");
                      __n = _M_limit(__pos, __n);
                      const size_type __osize = __str.size();
                      const size_type __len = std::min(__n, __osize);
                      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
                      if (!__r)
                	__r = __n - __osize;
                      return __r;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string<_CharT, _Traits, _Alloc>::
                    compare(size_type __pos1, size_type __n1, const basic_string& __str,
                	    size_type __pos2, size_type __n2) const
                    {
                      _M_check(__pos1, "basic_string::compare");
                      __str._M_check(__pos2, "basic_string::compare");
                      __n1 = _M_limit(__pos1, __n1);
                      __n2 = __str._M_limit(__pos2, __n2);
                      const size_type __len = std::min(__n1, __n2);
                      int __r = traits_type::compare(_M_data() + __pos1,
                				     __str.data() + __pos2, __len);
                      if (!__r)
                	__r = __n1 - __n2;
                      return __r;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string<_CharT, _Traits, _Alloc>::
                    compare(const _CharT* __s) const
                    {
                      __glibcxx_requires_string(__s);
                      const size_type __size = this->size();
                      const size_type __osize = traits_type::length(__s);
                      const size_type __len = std::min(__size, __osize);
                      int __r = traits_type::compare(_M_data(), __s, __len);
                      if (!__r)
                	__r = __size - __osize;
                      return __r;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string <_CharT, _Traits, _Alloc>::
                    compare(size_type __pos, size_type __n1, const _CharT* __s) const
                    {
                      __glibcxx_requires_string(__s);
                      _M_check(__pos, "basic_string::compare");
                      __n1 = _M_limit(__pos, __n1);
                      const size_type __osize = traits_type::length(__s);
                      const size_type __len = std::min(__n1, __osize);
                      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
                      if (!__r)
                	__r = __n1 - __osize;
                      return __r;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string <_CharT, _Traits, _Alloc>::
                    compare(size_type __pos, size_type __n1, const _CharT* __s,
                	    size_type __n2) const
                    {
                      __glibcxx_requires_string_len(__s, __n2);
                      _M_check(__pos, "basic_string::compare");
                      __n1 = _M_limit(__pos, __n1);
                      const size_type __len = std::min(__n1, __n2);
                      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
                      if (!__r)
                	__r = __n1 - __n2;
                      return __r;
                    }
                
                  // Inhibit implicit instantiations for required instantiations,
                  // which are defined via explicit instantiations elsewhere.
                  // NB: This syntax is a GNU extension.
                #if _GLIBCXX_EXTERN_TEMPLATE
                  extern template class basic_string<char>;
                  extern template
                    basic_istream<char>&
                    operator>>(basic_istream<char>&, string&);
                  extern template
                    basic_ostream<char>&
                    operator<<(basic_ostream<char>&, const string&);
                  extern template
                    basic_istream<char>&
                    getline(basic_istream<char>&, string&, char);
                  extern template
                    basic_istream<char>&
                    getline(basic_istream<char>&, string&);
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  extern template class basic_string<wchar_t>;
                  extern template
                    basic_istream<wchar_t>&
                    operator>>(basic_istream<wchar_t>&, wstring&);
                  extern template
                    basic_ostream<wchar_t>&
                    operator<<(basic_ostream<wchar_t>&, const wstring&);
                  extern template
                    basic_istream<wchar_t>&
                    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
                  extern template
                    basic_istream<wchar_t>&
                    getline(basic_istream<wchar_t>&, wstring&);
                #endif
                #endif
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

      666         33

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       33   Total number of line executions
    33.00   Average executions per line


*** File /home/tyler/Desktop/fland2/baseent.h:
                #ifndef BASEENT_H
                #define BASEENT_H
                
                using namespace std;
                
                #include "defines.h"
                #include "rendervertex.h"
                #include "groupr.h"
                #include "templates.h"
                
                class BaseRule;
                class RulePointer;
                //class GroupR;
                class BaseEnt
                {
                	public:
                	// pointer back to our parent
                	BaseEnt *parent;
                
                	// how many generations we are removed from the great root entity.
                	// root is one, each child is 2, grandchildren are 3, etc...
                	int iterationDepth;
                
                	// each entity has a random seed value, given at creation time.
                	int seed;
                
                	// Each entity has a list of children.
                	vector< BaseEnt* > child;
                
                	// Each entity has 2 vectors of rules. The meRules are run on a new entity as
                	// soon as it has been created. the splitrules are run when it is split, to create
                	// children.
                	//vector< BaseRule* > meRule;
                	//vector< BaseRule* > splitRule;
                	//GroupR* meRule;
                	//GroupR* splitRule;
                
                	// Nope. We decided to give each entity one of these.
                	vector< RulePointer > rules;
                
                	// adds a rule to the vector of rules.
                	void addRule( BaseRule*, int numPropogates, intensityType );
                	// adds a rule and then runs it.
                	void addAndRunRule( BaseRule*, int numPropogates, intensityType );
                
                	// Whether or not this entity is split
                	bool isSplit;
                
                	// The distance from the viewer. Recalculated every frame.
                	DIS_TYPE viewDistance;
                
                	// recalculated when created. This is the visibility of the entity
                	// when it is created. When the visibility gets down to this value,
                	// the entity is deleted out of the world.
                	double createVisibility;
                
                	// These are recalculated every frame and are used to know who to split
                	// and un-split
                	bool isVisible;
                	double visibility;
                
                
                	// each entity gets a bounding sphere.
                	// It and all its future should fit inside this sphere.
                	BoundSphere bound;
                
                	/////////////////////////////////////////////////////////////////////////////////
                	// functions
                
                	// PROBLEM: Since there are so many entities and rules being created and destroyed
                	// every frame the program will have to dynamically create and destroy objects a whole lot.
                	// SOLUTION: There is a stack of each type of entity and rule . When an entity or rule
                	// is needed it checks if there is one on the stack. If so, it pulls it off and runs it's
                	// "constructor". If there isn't one available, it creates it, and then calls it's "constructor".
                	// Note that this is not the real constructor, it cant be the real one because you cant call
                	// the real one more then once.
                	virtual int constructor( BaseEnt *parent );
                
                	// The real constructor.
                	BaseEnt();
                
                	// The destructor is called explicitly, It has to "delete" it's children.
                	virtual void destructor( bool willDelete = false );
                
                	// This is the "indescriminate kill". By using the actual destructor
                	// you just kill and object and all it's kids, not worying about detaching
                	// everything right, just making sure it all gets deleted.
                	virtual ~BaseEnt();
                
                	// Every entity has the function draw();
                	virtual void draw();
                
                	// This function recursively goes through each entity and calculates the
                	// visibility of each one.
                	void recursiveCalcVisibility();
                
                	// This runs through each entity and splits it if necessary
                	// You have to calculate the visibility of each object first!
                	void recursiveSplit();
                
                	// Calculates and stores the visibility and isVisible
                	// for the entity
                	// Is NOT recursive. calculates and sets if it is visible, the visibility level,
                	// and the morph amount.
                	void calcVisibility();
                
                	// called when the object is created. Runs the 'me' rules.
                	// This function calculates the unique attributes for each entity.
                	// such as X, Y, Z, color, it's rules, etc.
                	//virtual int calculateMe();
                
                	// every entity has the function split(). This function creates it's children,
                	// and calls calculateMe() for each one.
                	// It first calls propogateRules to get the parent's rules, then it
                	// uses those rules to determine it's attributes.
                	virtual void split();
                
                	// unsplits an entity. Donsen't check if this is allowed. Check that before calling this function.
                	// Deletes all it's children.
                	// NOTE: if a vertex, it will delete all neighbors that need to be deleted.
                	virtual void unSplit();
                
                	// goes through and un-splits the approprite entities.
                	// Returns true if this entity can be deleted.
                	bool recursiveUnSplit();
                
                	// returns true if there aren't any neighbors depending on this entity
                	// for existance.
                	virtual bool canUnSplit();
                
                	// Right before an entity is un-split,
                	// it runs this function. A regular entity simply
                	// returns true-can be un-split, but a vertex
                	// will check it's neighbors.
                	// Returns true if it can be un-split, and false if not.
                	// NOTE: a vertex may run recursiveUnSplit on neighbors
                	// from this function.
                	virtual bool specialUnSplitCheck();
                
                	// for a newly created child. Goes through the parent's rules and
                	// takes the appropriate ones for itself.
                	void takeRulesFromParent();
                
                	// Counts recursively how many children this entity has.
                	// Also gets the deepest iteration depth
                	int getCount( int& deepestIteration );
                
                	// returns true if the entity should be split. NOTE: uses the
                	// visibility calculations from calcVisibility. Must run calcVisibility first.
                	inline bool shouldSplit();
                	// should this entity unsplit?
                	inline bool shouldUnSplit();
                
                	// This sets an entity and all it's posterity as visible or invisible.
                	void setVisible( bool );
                
                	// this is the first pass the calculate loop makes. The return
                	// value is the number of entities gone through so far.
                	int calcPass1();
                
                	// after an entity has had it's visibility calulated, it runs this function.
                	virtual void calcMorph( double );
                
                	// writes each object's key attributes to the screen.
                	#if DEBUG
                
                	// When an entity is tDeleted it will set this to true.
                	// This is to help make sure that there are no deleted entities still in the world.
                	bool isDeleted;
                
                	// print info about each entity
                	virtual void dump( ostream&, int );
                
                	virtual string toString( int );
                
                	virtual void printType();
                	virtual string getType();
                
                	// Prints in a compact form every entity, in a way easy to see parent-children relationships.
                	void printGeneology( int depth );
                	#endif
                
                	static Reuse< BaseEnt, BaseEnt > reuse;
                };
                
                
                // returns true if the entity should be split. NOTE: uses the
                // visibility calculations from calcVisibility. Must run calcVisibility first.
     1679097 -> inline bool BaseEnt::shouldSplit()
                {
                	//Fland *fl = getFlandPtr();
                	if( isVisible && visibility > 1.0 )//fl->getSplitVisibility() )
                		return true;
                	else
                		return false;
                }
                
                // should this entity unsplit? (based only on visibility, not on
                // the status of it's neighbors.
     1861032 -> inline bool BaseEnt::shouldUnSplit()
                {
                	//Fland *fl = getFlandPtr();
                	if( !isVisible || visibility < 1.0 )//fl->getSplitVisibility() )
                		return true;
                	else
                		return false;
                }
                
                // every entity has a vector of pointers to these.
                class RulePointer
         954 -> {
                	private:
                	BaseRule* rule;
                	int remainingPropogates;
                	intensityType intensity;
                
                	public:
                	inline BaseRule* getRule(){ return rule; }
       17556 -> 	inline void setRule( BaseRule* r ){ rule = r; }
       ##### -> 	inline intensityType getIntensity(){ return intensity; }
       17556 -> 	inline void setIntensity( intensityType i ){ intensity = i; }
                	inline int getRemainingPropogates(){ return remainingPropogates; }
       17556 -> 	inline void setRemainingPropogates( int p ){ remainingPropogates = p; }
                	string toString( int = 0 );
                
                	RulePointer();
                
                	//// tells the rule to do it's thing to the entity.
                	//inline void goCalcMe( BaseEnt* newEnt )
                	//{
                	//	sassert( rule );
                	//	sassert( newEnt );
                	//	rule->goCalcMe( newEnt, intensity );
                	//}
                
       17555 -> 	inline void propogateRules( BaseEnt* newEnt )
                	{
                		sassert( newEnt );
                		rule->propogateRules( newEnt, remainingPropogates, intensity );
                	}
                
       ##### -> 	string getFmlName()
                	{
                		return rule->fmlName;
                	}
                
                };
                
                #endif


Top 10 Lines:

     Line      Count

      200    1861032
      189    1679097
      219      17556
      221      17556
      223      17556
      236      17555
      211        954

Execution Summary:

        9   Executable lines in this file
        9   Lines executed
   100.00   Percent of the file executed

  3611306   Total number of line executions
401256.22   Average executions per line


*** File /home/tyler/Desktop/fland2/templates.h:
                #ifndef _TEMPLATE_H
                #define _TEMPLATE_H
                
                using namespace std;
                
                
                #include <iostream>
                #include <vector>
                
                
                // Reuse is used to create a stack of dead objects so we dont have to keep
                // dynamically creating and deleting them.
                // it makes an auto growing stack and puts the dead object pointers on it.
                // then when an object is needed, it pops its pointer off the stack.
                
                // B is the base class object type,
                // D is the derived class type. They could be the same thing.
                #define START_STACK_SIZE 1000
                
                class BaseEnt;
                template< class B, class D >
                class Reuse
                {
                	public:
                	Reuse( int = START_STACK_SIZE );
                	~Reuse();
                	void empty();
                
                	B* tNew( BaseEnt* = NULL ); // create a new object. Optionally pass the parent in.
                	void tDelete( B* );
                
                	private:
                	vector< B* > stack;
                };
                
                template< class B, class D >
           5 -> void Reuse< B, D >::empty()
                {
                	for( int i=0; i<stack.size(); i++ )
                	{
                		delete stack[i];
                	}
                	stack.clear();
                }
                
                template< class B, class D >
           3 -> Reuse< B, D >::~Reuse()
                {
                	empty();
                }
                
                template< class B, class D >
           3 -> Reuse< B, D >::Reuse( int inSize )
                {
                	//stack.resize( inSize );
                	for( int i=0; i< START_STACK_SIZE; i++ )
                	{
                		stack.push_back( new D );
                	}
                }
                
                
                template< class B, class D >
         953 -> void Reuse< B, D >::tDelete( B *inVal )
                {
                	// THIS IS THE REAL FUNCTION
                	stack.push_back( inVal );
                	// this is for debugging
                	//delete inVal;
                }
                
                template< class B, class D >
       17556 -> B* Reuse< B, D >::tNew( BaseEnt *inParent )
                {
                	B *ptr;
                	if( stack.size() > 0 )
                	{
                		ptr = stack[ stack.size() - 1 ];
                		stack.pop_back();
                	}
                	else
                	{
                		ptr = new D;
                		if( ptr == NULL ) // if the allocation failed
                		{
                			cout << "Couldn't allocate more memory" << endl;
                			exit( 0 );
                		}
                	}
                	ptr->constructor( inParent );
                	return( ptr );
                }
                
                #endif


Top 10 Lines:

     Line      Count

       73      17556
       64        953
       37          5
       47          3
       53          3

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

    18520   Total number of line executions
  3704.00   Average executions per line


*** File /home/tyler/Desktop/fland2/tyler.h:
                #ifndef _TYLER_H
                #define _TYLER_H
                
                #include <iostream>
                #include <math.h>
                #include <stdlib.h>
                #include <string>
                #include <cassert>
                
                using namespace std;
                
                const double pi = 3.14159265;
                const double PI = pi;
                const double PI2 = PI * 2.0;
                const double PI_D_2 = PI / 2.0;
                const double PI_D_180 = PI / 180.0;
                
                inline double distance( double x1, double x2, double y1, double y2, double z1, double z2 );
                inline double distance( double x, double y, double z );
                string indent( int num );
                string pBool( bool inVal );
                void aBool( string val, bool& b );
                
                template <class T>
       42753 -> int normalize(T &x, T &y, T &z)
                {
                	T length = sqrt(x*x + y*y + z*z);
                	// if the length of each side is 0, its going to mess up anyway.
                	if( !length )
                	{
                		length = 1.0;
                		//cout << __FILE__ << " " << __LINE__ << " normalize calculation messed up." << endl;
                		return 0;
                	}
                    T oneOverL = 1.0 / length;
                	x = (x * oneOverL);
                	y = (y * oneOverL);
                	z = (z * oneOverL);
                	return 1;
                } //normalize
                
                template <class I, class O>
                void calcNormal(I x1, I y1, I z1, I x2, I y2, I z2,
       15480 -> 				I x3, I y3, I z3, O &nx, O &ny, O &nz)
                {
                	I ax, ay, az, bx, by, bz;
                	ax = x1 - x2;
                	ay = y1 - y2;
                	az = z1 - z2;
                
                	bx = x1 - x3;
                	by = y1 - y3;
                	bz = z1 - z3;
                
                	nx = (O)(ay*bz-by*az);
                	ny = (O)(-ax*bz+bx*az);
                	nz = (O)(ax*by-bx*ay);
                	normalize( nx, ny, nz );
                } // calcNormal
                
                
                // storing of colors
                class Color
                {
                	public:
                	float red, green, blue;
                	Color();
                };
                
                // storing 3d points
                class Point3D
                {
                	public:
                	double x, y, z;
                	Point3D();
                	Point3D( double ix, double iy, double iz );
                };
                
                inline int tRand();
                inline void tSrand( int seed );
                inline double rnd();
                void pause( int x );
                
                
       73882 -> inline double rnd()
                {
                	return( (double)tRand() / (double)RAND_MAX );
                }
                // Abstract in case we want to use a different algorithm later.
       91433 -> inline int tRand()
                {
                	return( rand() );
                }
                
                
                
     1891801 -> inline double distance( double x, double y, double z )
                {
                	return( sqrt( x*x + y*y + z*z ) );
                }
                
     1891801 -> inline double distance( double x1, double x2, double y1, double y2, double z1, double z2 )
                {
                	return( distance( x1 - x2, y1 - y2, z1 - z2 ) );
                }
                
                
                // abstract in case we want to use a different algorithm later.
        1982 -> inline void tSrand( int seed )
                {
                	srand( seed );
                }
                
                // a speedy assert. This assert can be removed from production code.
                //#define sassert( val ) assert( val );
                // seg fault if assert fails. then bt in dgb will work.
                #define sassert( val ) if( !(val) ){ cout << "ASSERTION FAILED " << endl;LN int* a=NULL; *a=0; }
                
                // NOTE: T has to be a float or double, if an int this function wont work.
                template< class T >
       17551 -> T convertRange1ToRange2( T range1, T inMin, T inMax, T outMin, T outMax )
                {
                	// clamp the value
                	if( range1 <= inMin )
                		return outMin;
                	else if( range1 >= inMax )
                		return outMax;
                
                	T sizeIn = inMax - inMin;
                	T sizeOut = outMax - outMin;
                	T outRatio = sizeOut / sizeIn;
                
                	return( ( range1 - inMin ) * outRatio + outMin );
                }
                
                #endif
                


Top 10 Lines:

     Line      Count

       97    1891801
      102    1891801
       90      91433
       85      73882
       25      42753
      121      17551
       44      15480
      109       1982

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

  4026683   Total number of line executions
503335.38   Average executions per line


*** File /home/tyler/Desktop/fland2/meshseed.h:
                #ifndef MESHSEED_H
                #define MESHSEED_H
                
                using namespace std;
                
                #include "baseent.h"
                #include "vertex.h"
                #include "templates.h"
                #include "defines.h"
                
                
                // creates a new mesh as the child of this entity.
                class MeshSeed : public BaseEnt
        2000 -> {
                	private:
                	QUARD_TYPE x, y, z;
                	DIS_TYPE size;
                
                	public:
                	static Reuse< BaseEnt, MeshSeed >reuse;
                	void setMeshParams( QUARD_TYPE, QUARD_TYPE, QUARD_TYPE, DIS_TYPE );
                
                	// storing this may be unnecessary because the verticies are stored in the normal child list.
                	Vertex *vChild[4];
                
                	// after the constructor call this to create the mesh.
                	virtual void split();
                	virtual void unSplit();
                
                	virtual int constructor( BaseEnt *parent );
                	virtual void destructor( bool willDelete = false );
                	virtual bool specialUnSplitCheck();
                
                	virtual void draw();
                	void attachVertexNeighbors();
                };
                
                #endif
                


Top 10 Lines:

     Line      Count

       14       2000

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

     2000   Total number of line executions
  2000.00   Average executions per line


*** File /home/tyler/Desktop/fland2/baserule.h:
                #ifndef BASERULE_H
                #define BASERULE_H
                
                using namespace std;
                
                #include "defines.h"
                #include <string>
                
                class BaseEnt;
                class FmlParser;
                class GroupR;
                class BaseRule
          29 -> {
                	public:
                
                	// The number of iterations deep this rule applies, until it spawns into
                	// a new rule type, or goes away.
                	int numPropogates;
                
                	// The intensity of a rule. When 1.0 this rule's effects will apply 100%.
                	// When the intensity of a rule gets to zero, the rule should no longer propogate.
                	intensityType intensity;
                
                	// When this rule is done propogating, a copy of one of these will be propogated.
                	// this rule comes from the FmlParser, and is coded in with FML.
                	BaseRule* childRule;
                
                	virtual void destructor( bool willDelete = false );
                
                	// These makes the rule do it's thing. Call it and pass the entity that
                	// is using the rule (client), and the rule will alter the appropriate attributes
                	// of the client.
                	virtual void goCalcMe( BaseEnt *inClient, intensityType );
                
                	// This is for possible future use, a 'stud hanging out of the wall'.
                	// If I ever have a rule that needs to create a copy of itself instead of just using the
                	// FML version, it should return a pointer to the new rule in this function.
                	// All normal rules just return a pointer to themselves.
                	virtual BaseRule* startUse();
                	// this rule goes with the one above. If this rule had created a copy of itself,
                	// this function will delete that copy.
                	virtual void endUse();
                
                	// this function is called from a rule who's entity is being split. It is called once for each of
                	// that entity's children.
                	// It inserts the pointers to rules into the new entity's list of rules.
                	// it inserts either the same rule, or the new child rules.
                	// remainingPropogates is the number of propogates the PARENT has left. the new ent will subtrsct 1 from this.
                	void propogateRules( BaseEnt* newEnt, int remainingPropogates, intensityType nIntensity );
                
                	// When a rule is done propogating and it's child(ren, in the case of descriminatory rules)
                	// should be passed on, this rule inserts the new child(ren) into the newEnt's rule list.
                	virtual void propogateChildren( BaseEnt* newEnt, intensityType nIntensity );
                
                	// assigns attributes from the fmlparse functions
                	// returns an error string, if there is an error
                	// NOTE: the FmlParser pointer is for certain rule types, such as groupr,
                	// where we are assigning a pointer out of the nameMap hash. It needs access
                	// to the nameMap hash.
                	virtual string assignValue( string valueType, istringstream *value, FmlParser* fPtr );
                
                	BaseRule();
                
       ##### -> 	virtual string getType(){};
                
                	#if( DEBUG )
                	virtual string toString( int );
                	string fmlName; // the name of the rule in the fml nameMap
                	bool fmlRule; // was I created by the fml parser, or through a makeMe?
                	#endif
                };
                
                
                #endif


Top 10 Lines:

     Line      Count

       13         29

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

       29   Total number of line executions
    14.50   Average executions per line


*** File /home/tyler/Desktop/fland2/camera.h:
                #ifndef CAMERA_H
                #define CAMERA_H
                
                #include <string>
                #include "tyler.h"
                
                // This is the data class Fland uses to keep track of the camera location,
                // and to test if a point is visible to the camera.
                class Camera
                {
                	public:
                	double x, y, z, rotY, rotX, rotZ;
                	double viewAngle;
                	double near, far;
                	double farPercentage;
                	double speed; // forward and backward speed
                	double vertSpeed; // up and down speed
                	double sideSpeed; // side to side
                   double frustum[6][4]; // this is calculated in calcFrustum. Used in frustrum culling.
                   float fogColor[4];
                
                	Camera();
                	void updateGlView();
                	void updateLocation();
                	void calcFrustum();
                	bool pointInFrustum( double inX, double inY, double inZ );
                	template< class T >
                	inline bool sphereInFrustum( T x, T y, T z, T radius );
                	double calcVisibility( double, double, double );
                	void setNearFarPlanes();
                	void resetView();
                	void printFrustum();
                	string toString( int );
                	void setNearFarPlanes( double nearest, double farthest );
                
                };
                template< class T >
     1891801 -> inline bool Camera::sphereInFrustum( T inX, T inY, T inZ, T radius )
                {
                	inX -= x;
                	inY -= y;
                	inZ -= z;
                	// Dont check for the near clip planes.
                   for( int p = 0; p < 5; p++ )
                      if( frustum[p][0] * inX + frustum[p][1] * inY + frustum[p][2] * inZ + frustum[p][3] <= -radius )
                         return false;
                   return true;
                }
                
                #endif


Top 10 Lines:

     Line      Count

       38    1891801

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

  1891801   Total number of line executions
1891801.00   Average executions per line


*** File /usr/lib/gcc/i486-linux-gnu/4.1.2/../../../../include/c++/4.1.2/bits/stl_construct.h:
                // nonstandard construct and destroy functions -*- C++ -*-
                
                // Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 2, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // You should have received a copy of the GNU General Public License along
                // with this library; see the file COPYING.  If not, write to the Free
                // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
                // USA.
                
                // As a special exception, you may use this file as part of a free software
                // library without restriction.  Specifically, if other files instantiate
                // templates or use macros or inline functions from this file, or you compile
                // this file and link it with other files to produce an executable, this
                // file does not by itself cause the resulting executable to be covered by
                // the GNU General Public License.  This exception does not however
                // invalidate any other reasons why the executable file might be covered by
                // the GNU General Public License.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file stl_construct.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _STL_CONSTRUCT_H
                #define _STL_CONSTRUCT_H 1
                
                #include <bits/cpp_type_traits.h>
                #include <new>
                
                namespace std
                {
                  /**
                   * @if maint
                   * Constructs an object in existing memory by invoking an allocated
                   * object's constructor with an initializer.
                   * @endif
                   */
                  template<typename _T1, typename _T2>
                    inline void
       32767 ->     _Construct(_T1* __p, const _T2& __value)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 402. wrong new expression in [some_]allocator::construct
                      ::new(static_cast<void*>(__p)) _T1(__value);
                    }
                
                  /**
                   * @if maint
                   * Constructs an object in existing memory by invoking an allocated
                   * object's default constructor (no initializers).
                   * @endif
                   */
                  template<typename _T1>
                    inline void
                    _Construct(_T1* __p)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 402. wrong new expression in [some_]allocator::construct
                      ::new(static_cast<void*>(__p)) _T1();
                    }
                
                  /**
                   * @if maint
                   * Destroy the object pointed to by a pointer type.
                   * @endif
                   */
                  template<typename _Tp>
                    inline void
     1925105 ->     _Destroy(_Tp* __pointer)
                    { __pointer->~_Tp(); }
                
                  /**
                   * @if maint
                   * Destroy a range of objects with nontrivial destructors.
                   *
                   * This is a helper function used only by _Destroy().
                   * @endif
                   */
                  template<typename _ForwardIterator>
                    inline void
                    __destroy_aux(_ForwardIterator __first, _ForwardIterator __last,
       55084 -> 		  __false_type)
                    {
                      for (; __first != __last; ++__first)
                	std::_Destroy(&*__first);
                    }
                
                  /**
                   * @if maint
                   * Destroy a range of objects with trivial destructors.  Since the destructors
                   * are trivial, there's nothing to do and hopefully this function will be
                   * entirely optimized away.
                   *
                   * This is a helper function used only by _Destroy().
                   * @endif
                   */
                  template<typename _ForwardIterator>
                    inline void
       48390 ->     __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type)
                    { }
                
                  /**
                   * @if maint
                   * Destroy a range of objects.  If the value_type of the object has
                   * a trivial destructor, the compiler should optimize all of this
                   * away, otherwise the objects' destructors must be invoked.
                   * @endif
                   */
                  template<typename _ForwardIterator>
                    inline void
      103474 ->     _Destroy(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                                       _Value_type;
                      typedef typename std::__is_scalar<_Value_type>::__type
                	               _Has_trivial_destructor;
                
                      std::__destroy_aux(__first, __last, _Has_trivial_destructor());
                    }
                
                  /**
                   * @if maint
                   * Destroy a range of objects using the supplied allocator.  For
                   * nondefault allocators we do not optimize away invocation of 
                   * destroy() even if _Tp has a trivial destructor.
                   * @endif
                   */
                
                  template <typename _Tp> class allocator;
                
                  template<typename _ForwardIterator, typename _Allocator>
                    void
                    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
                	     _Allocator __alloc)
                    {
                      for (; __first != __last; ++__first)
                	__alloc.destroy(&*__first);
                    }
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      103474 -> 	     allocator<_Tp>)
                    {
                      _Destroy(__first, __last);
                    }
                   
                
                } // namespace std
                
                #endif /* _STL_CONSTRUCT_H */
                


Top 10 Lines:

     Line      Count

      106    1925105
      148     103474
      180     103474
      119      55084
      136      48390
       77      32767

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

  2268294   Total number of line executions
378049.00   Average executions per line


*** File /usr/lib/gcc/i486-linux-gnu/4.1.2/../../../../include/c++/4.1.2/bits/stl_iterator.h:
                // Iterators -*- C++ -*-
                
                // Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 2, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // You should have received a copy of the GNU General Public License along
                // with this library; see the file COPYING.  If not, write to the Free
                // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
                // USA.
                
                // As a special exception, you may use this file as part of a free software
                // library without restriction.  Specifically, if other files instantiate
                // templates or use macros or inline functions from this file, or you compile
                // this file and link it with other files to produce an executable, this
                // file does not by itself cause the resulting executable to be covered by
                // the GNU General Public License.  This exception does not however
                // invalidate any other reasons why the executable file might be covered by
                // the GNU General Public License.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file stl_iterator.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 *
                 *  This file implements reverse_iterator, back_insert_iterator,
                 *  front_insert_iterator, insert_iterator, __normal_iterator, and their
                 *  supporting functions and overloaded operators.
                 */
                
                #ifndef _ITERATOR_H
                #define _ITERATOR_H 1
                
                #include <bits/cpp_type_traits.h>
                
                namespace std
                {
                  // 24.4.1 Reverse iterators
                  /**
                   *  "Bidirectional and random access iterators have corresponding reverse
                   *  %iterator adaptors that iterate through the data structure in the
                   *  opposite direction.  They have the same signatures as the corresponding
                   *  iterators.  The fundamental relation between a reverse %iterator and its
                   *  corresponding %iterator @c i is established by the identity:
                   *  @code
                   *      &*(reverse_iterator(i)) == &*(i - 1)
                   *  @endcode
                   *
                   *  This mapping is dictated by the fact that while there is always a
                   *  pointer past the end of an array, there might not be a valid pointer
                   *  before the beginning of an array." [24.4.1]/1,2
                   *
                   *  Reverse iterators can be tricky and surprising at first.  Their
                   *  semantics make sense, however, and the trickiness is a side effect of
                   *  the requirement that the iterators must be safe.
                  */
                  template<typename _Iterator>
                    class reverse_iterator
                    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                		      typename iterator_traits<_Iterator>::value_type,
                		      typename iterator_traits<_Iterator>::difference_type,
                		      typename iterator_traits<_Iterator>::pointer,
                                      typename iterator_traits<_Iterator>::reference>
                    {
                    protected:
                      _Iterator current;
                
                    public:
                      typedef _Iterator					       iterator_type;
                      typedef typename iterator_traits<_Iterator>::difference_type
                							       difference_type;
                      typedef typename iterator_traits<_Iterator>::reference   reference;
                      typedef typename iterator_traits<_Iterator>::pointer     pointer;
                
                    public:
                      /**
                       *  The default constructor default-initializes member @p current.
                       *  If it is a pointer, that means it is zero-initialized.
                      */
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 235 No specification of default ctor for reverse_iterator
                      reverse_iterator() : current() { }
                
                      /**
                       *  This %iterator will move in the opposite direction that @p x does.
                      */
                      explicit
                      reverse_iterator(iterator_type __x) : current(__x) { }
                
                      /**
                       *  The copy constructor is normal.
                      */
                      reverse_iterator(const reverse_iterator& __x)
                      : current(__x.current) { }
                
                      /**
                       *  A reverse_iterator across other types can be copied in the normal
                       *  fashion.
                      */
                      template<typename _Iter>
                        reverse_iterator(const reverse_iterator<_Iter>& __x)
                	: current(__x.base()) { }
                
                      /**
                       *  @return  @c current, the %iterator used for underlying work.
                      */
                      iterator_type
                      base() const
                      { return current; }
                
                      /**
                       *  @return  TODO
                       *
                       *  @doctodo
                      */
                      reference
                      operator*() const
                      {
                	_Iterator __tmp = current;
                	return *--__tmp;
                      }
                
                      /**
                       *  @return  TODO
                       *
                       *  @doctodo
                      */
                      pointer
                      operator->() const
                      { return &(operator*()); }
                
                      /**
                       *  @return  TODO
                       *
                       *  @doctodo
                      */
                      reverse_iterator&
                      operator++()
                      {
                	--current;
                	return *this;
                      }
                
                      /**
                       *  @return  TODO
                       *
                       *  @doctodo
                      */
                      reverse_iterator
                      operator++(int)
                      {
                	reverse_iterator __tmp = *this;
                	--current;
                	return __tmp;
                      }
                
                      /**
                       *  @return  TODO
                       *
                       *  @doctodo
                      */
                      reverse_iterator&
                      operator--()
                      {
                	++current;
                	return *this;
                      }
                
                      /**
                       *  @return  TODO
                       *
                       *  @doctodo
                      */
                      reverse_iterator
                      operator--(int)
                      {
                	reverse_iterator __tmp = *this;
                	++current;
                	return __tmp;
                      }
                
                      /**
                       *  @return  TODO
                       *
                       *  @doctodo
                      */
                      reverse_iterator
                      operator+(difference_type __n) const
                      { return reverse_iterator(current - __n); }
                
                      /**
                       *  @return  TODO
                       *
                       *  @doctodo
                      */
                      reverse_iterator&
                      operator+=(difference_type __n)
                      {
                	current -= __n;
                	return *this;
                      }
                
                      /**
                       *  @return  TODO
                       *
                       *  @doctodo
                      */
                      reverse_iterator
                      operator-(difference_type __n) const
                      { return reverse_iterator(current + __n); }
                
                      /**
                       *  @return  TODO
                       *
                       *  @doctodo
                      */
                      reverse_iterator&
                      operator-=(difference_type __n)
                      {
                	current += __n;
                	return *this;
                      }
                
                      /**
                       *  @return  TODO
                       *
                       *  @doctodo
                      */
                      reference
                      operator[](difference_type __n) const
                      { return *(*this + __n); }
                    };
                
                  //@{
                  /**
                   *  @param  x  A %reverse_iterator.
                   *  @param  y  A %reverse_iterator.
                   *  @return  A simple bool.
                   *
                   *  Reverse iterators forward many operations to their underlying base()
                   *  iterators.  Others are implemented in terms of one another.
                   *
                  */
                  template<typename _Iterator>
                    inline bool
                    operator==(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _Iterator>
                    inline bool
                    operator<(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y.base() < __x.base(); }
                
                  template<typename _Iterator>
                    inline bool
                    operator!=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__x == __y); }
                
                  template<typename _Iterator>
                    inline bool
                    operator>(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y < __x; }
                
                  template<typename _Iterator>
                    inline bool
                    operator<=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__y < __x); }
                
                  template<typename _Iterator>
                    inline bool
                    operator>=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__x < __y); }
                
                  template<typename _Iterator>
                    inline typename reverse_iterator<_Iterator>::difference_type
                    operator-(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y.base() - __x.base(); }
                
                  template<typename _Iterator>
                    inline reverse_iterator<_Iterator>
                    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
                	      const reverse_iterator<_Iterator>& __x)
                    { return reverse_iterator<_Iterator>(__x.base() - __n); }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 280. Comparison of reverse_iterator to const reverse_iterator.
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator==(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator<(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    { return __y.base() < __x.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator!=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return !(__x == __y); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator>(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    { return __y < __x; }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator<=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return !(__y < __x); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline bool
                    operator>=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return !(__x < __y); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline typename reverse_iterator<_IteratorL>::difference_type
                    operator-(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    { return __y.base() - __x.base(); }
                  //@}
                
                  // 24.4.2.2.1 back_insert_iterator
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator appends it to the container using
                   *  push_back.
                   *
                   *  Tip:  Using the back_inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class back_insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                    protected:
                      _Container* container;
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                
                      /// The only way to create this %iterator is with a container.
                      explicit
                      back_insert_iterator(_Container& __x) : container(&__x) { }
                
                      /**
                       *  @param  value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator doesn't really have a "position" in the
                       *  container (you can think of the position as being permanently at
                       *  the end, if you like).  Assigning a value to the %iterator will
                       *  always append the value to the end of the container.
                      */
                      back_insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	container->push_back(__value);
                	return *this;
                      }
                
                      /// Simply returns *this.
                      back_insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not "move".)
                      back_insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not "move".)
                      back_insert_iterator
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param  x  A container of arbitrary type.
                   *  @return  An instance of back_insert_iterator working on @p x.
                   *
                   *  This wrapper function helps in creating back_insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                  template<typename _Container>
                    inline back_insert_iterator<_Container>
                    back_inserter(_Container& __x)
                    { return back_insert_iterator<_Container>(__x); }
                
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator prepends it to the container using
                   *  push_front.
                   *
                   *  Tip:  Using the front_inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class front_insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                    protected:
                      _Container* container;
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                
                      /// The only way to create this %iterator is with a container.
                      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
                
                      /**
                       *  @param  value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator doesn't really have a "position" in the
                       *  container (you can think of the position as being permanently at
                       *  the front, if you like).  Assigning a value to the %iterator will
                       *  always prepend the value to the front of the container.
                      */
                      front_insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	container->push_front(__value);
                	return *this;
                      }
                
                      /// Simply returns *this.
                      front_insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not "move".)
                      front_insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not "move".)
                      front_insert_iterator
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param  x  A container of arbitrary type.
                   *  @return  An instance of front_insert_iterator working on @p x.
                   *
                   *  This wrapper function helps in creating front_insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                  template<typename _Container>
                    inline front_insert_iterator<_Container>
                    front_inserter(_Container& __x)
                    { return front_insert_iterator<_Container>(__x); }
                
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator inserts it in the container at the
                   *  %iterator's position, rather than overwriting the value at that
                   *  position.
                   *
                   *  (Sequences will actually insert a @e copy of the value before the
                   *  %iterator's position.)
                   *
                   *  Tip:  Using the inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                    protected:
                      _Container* container;
                      typename _Container::iterator iter;
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                
                      /**
                       *  The only way to create this %iterator is with a container and an
                       *  initial position (a normal %iterator into the container).
                      */
                      insert_iterator(_Container& __x, typename _Container::iterator __i)
                      : container(&__x), iter(__i) {}
                
                      /**
                       *  @param  value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator maintains its own position in the
                       *  container.  Assigning a value to the %iterator will insert the
                       *  value into the container at the place before the %iterator.
                       *
                       *  The position is maintained such that subsequent assignments will
                       *  insert values immediately after one another.  For example,
                       *  @code
                       *     // vector v contains A and Z
                       *
                       *     insert_iterator i (v, ++v.begin());
                       *     i = 1;
                       *     i = 2;
                       *     i = 3;
                       *
                       *     // vector v contains A, 1, 2, 3, and Z
                       *  @endcode
                      */
                      insert_iterator&
                      operator=(const typename _Container::const_reference __value)
                      {
                	iter = container->insert(iter, __value);
                	++iter;
                	return *this;
                      }
                
                      /// Simply returns *this.
                      insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not "move".)
                      insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not "move".)
                      insert_iterator&
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param  x  A container of arbitrary type.
                   *  @return  An instance of insert_iterator working on @p x.
                   *
                   *  This wrapper function helps in creating insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                  template<typename _Container, typename _Iterator>
                    inline insert_iterator<_Container>
                    inserter(_Container& __x, _Iterator __i)
                    {
                      return insert_iterator<_Container>(__x,
                					 typename _Container::iterator(__i));
                    }
                } // namespace std
                
                namespace __gnu_cxx
                {
                  // This iterator adapter is 'normal' in the sense that it does not
                  // change the semantics of any of the operators of its iterator
                  // parameter.  Its primary purpose is to convert an iterator that is
                  // not a class, e.g. a pointer, into an iterator that is a class.
                  // The _Container parameter exists solely so that different containers
                  // using this template can instantiate different types, even if the
                  // _Iterator parameter is the same.
                  using std::iterator_traits;
                  using std::iterator;
                  template<typename _Iterator, typename _Container>
                    class __normal_iterator
                    {
                    protected:
                      _Iterator _M_current;
                
                    public:
                      typedef typename iterator_traits<_Iterator>::iterator_category
                                                                             iterator_category;
                      typedef typename iterator_traits<_Iterator>::value_type  value_type;
                      typedef typename iterator_traits<_Iterator>::difference_type
                                                                             difference_type;
                      typedef typename iterator_traits<_Iterator>::reference reference;
                      typedef typename iterator_traits<_Iterator>::pointer   pointer;
                
                      __normal_iterator() : _M_current(_Iterator()) { }
                
                      explicit
    54267192 ->       __normal_iterator(const _Iterator& __i) : _M_current(__i) { }
                
                      // Allow iterator to const_iterator conversion
                      template<typename _Iter>
                        __normal_iterator(const __normal_iterator<_Iter,
                			  typename std::__enable_if<_Container,
                			  (std::__are_same<_Iter,
                			   typename _Container::pointer>::__value)
                			  >::__type>& __i)
                        : _M_current(__i.base()) { }
                
                      // Forward iterator requirements
                      reference
    13506540 ->       operator*() const
                      { return *_M_current; }
                
                      pointer
                      operator->() const
                      { return _M_current; }
                
                      __normal_iterator&
      124711 ->       operator++()
                      {
                	++_M_current;
                	return *this;
                      }
                
                      __normal_iterator
                      operator++(int)
                      { return __normal_iterator(_M_current++); }
                
                      // Bidirectional iterator requirements
                      __normal_iterator&
                      operator--()
                      {
                	--_M_current;
                	return *this;
                      }
                
                      __normal_iterator
                      operator--(int)
                      { return __normal_iterator(_M_current--); }
                
                      // Random access iterator requirements
                      reference
                      operator[](const difference_type& __n) const
                      { return _M_current[__n]; }
                
                      __normal_iterator&
                      operator+=(const difference_type& __n)
                      { _M_current += __n; return *this; }
                
                      __normal_iterator
    13408239 ->       operator+(const difference_type& __n) const
                      { return __normal_iterator(_M_current + __n); }
                
                      __normal_iterator&
                      operator-=(const difference_type& __n)
                      { _M_current -= __n; return *this; }
                
                      __normal_iterator
                      operator-(const difference_type& __n) const
                      { return __normal_iterator(_M_current - __n); }
                
                      const _Iterator&
    27667840 ->       base() const
                      { return _M_current; }
                    };
                
                  // Note: In what follows, the left- and right-hand-side iterators are
                  // allowed to vary in types (conceptually in cv-qualification) so that
                  // comparaison between cv-qualified and non-cv-qualified iterators be
                  // valid.  However, the greedy and unfriendly operators in std::rel_ops
                  // will make overload resolution ambiguous (when in scope) if we don't
                  // provide overloads whose operands are of the same type.  Can someone
                  // remind me what generic programming is about? -- Gaby
                
                  // Forward iterator requirements
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    { return __lhs.base() == __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    { return __lhs.base() == __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    { return __lhs.base() != __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
      115391 -> 	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    { return __lhs.base() != __rhs.base(); }
                
                  // Random access iterator requirements
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                    { return __lhs.base() < __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    { return __lhs.base() < __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                    { return __lhs.base() > __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    { return __lhs.base() > __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    { return __lhs.base() <= __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    { return __lhs.base() <= __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    { return __lhs.base() >= __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    { return __lhs.base() >= __rhs.base(); }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // According to the resolution of DR179 not only the various comparison
                  // operators but also operator- must accept mixed iterator/const_iterator
                  // parameters.
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
                    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
    13636336 -> 	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                    { return __lhs.base() - __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline __normal_iterator<_Iterator, _Container>
                    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
                	      __n, const __normal_iterator<_Iterator, _Container>& __i)
                    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
                } // namespace __gnu_cxx
                
                #endif
                
                // Local Variables:
                // mode:C++
                // End:


Top 10 Lines:

     Line      Count

      650   54267192
      715   27667840
      808   13636336
      663   13506540
      703   13408239
      671     124711
      749     115391

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

122726249   Total number of line executions
17532321.29   Average executions per line


*** File /usr/lib/gcc/i486-linux-gnu/4.1.2/../../../../include/c++/4.1.2/bits/vector.tcc:
                // Vector implementation (out of line) -*- C++ -*-
                
                // Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 2, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // You should have received a copy of the GNU General Public License along
                // with this library; see the file COPYING.  If not, write to the Free
                // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
                // USA.
                
                // As a special exception, you may use this file as part of a free software
                // library without restriction.  Specifically, if other files instantiate
                // templates or use macros or inline functions from this file, or you compile
                // this file and link it with other files to produce an executable, this
                // file does not by itself cause the resulting executable to be covered by
                // the GNU General Public License.  This exception does not however
                // invalidate any other reasons why the executable file might be covered by
                // the GNU General Public License.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this  software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file vector.tcc
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _VECTOR_TCC
                #define _VECTOR_TCC 1
                
                namespace _GLIBCXX_STD
                {
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    reserve(size_type __n)
                    {
                      if (__n > this->max_size())
                	__throw_length_error(__N("vector::reserve"));
                      if (this->capacity() < __n)
                	{
                	  const size_type __old_size = size();
                	  pointer __tmp = _M_allocate_and_copy(__n,
                					       this->_M_impl._M_start,
                					       this->_M_impl._M_finish);
                	  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			_M_get_Tp_allocator());
                	  _M_deallocate(this->_M_impl._M_start,
                			this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_start);
                	  this->_M_impl._M_start = __tmp;
                	  this->_M_impl._M_finish = __tmp + __old_size;
                	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                	}
                    }
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                    insert(iterator __position, const value_type& __x)
                    {
                      const size_type __n = __position - begin();
                      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
                	  && __position == end())
                	{
                	  this->_M_impl.construct(this->_M_impl._M_finish, __x);
                	  ++this->_M_impl._M_finish;
                	}
                      else
                        _M_insert_aux(__position, __x);
                      return begin() + __n;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                    erase(iterator __position)
                    {
                      if (__position + 1 != end())
                        std::copy(__position + 1, end(), __position);
                      --this->_M_impl._M_finish;
                      this->_M_impl.destroy(this->_M_impl._M_finish);
                      return __position;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                    erase(iterator __first, iterator __last)
                    {
                      iterator __i(std::copy(__last, end(), __first));
                      std::_Destroy(__i, end(), _M_get_Tp_allocator());
                      this->_M_impl._M_finish = this->_M_impl._M_finish - (__last - __first);
                      return __first;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    vector<_Tp, _Alloc>&
                    vector<_Tp, _Alloc>::
                    operator=(const vector<_Tp, _Alloc>& __x)
                    {
                      if (&__x != this)
                	{
                	  const size_type __xlen = __x.size();
                	  if (__xlen > capacity())
                	    {
                	      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
                						   __x.end());
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __tmp;
                	      this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
                	    }
                	  else if (size() >= __xlen)
                	    {
                	      iterator __i(std::copy(__x.begin(), __x.end(), begin()));
                	      std::_Destroy(__i, end(), _M_get_Tp_allocator());
                	    }
                	  else
                	    {
                	      std::copy(__x.begin(), __x.begin() + size(),
                			this->_M_impl._M_start);
                	      std::__uninitialized_copy_a(__x.begin() + size(),
                					  __x.end(), this->_M_impl._M_finish,
                					  _M_get_Tp_allocator());
                	    }
                	  this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
                	}
                      return *this;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_fill_assign(size_t __n, const value_type& __val)
                    {
                      if (__n > capacity())
                	{
                	  vector __tmp(__n, __val, _M_get_Tp_allocator());
                	  __tmp.swap(*this);
                	}
                      else if (__n > size())
                	{
                	  std::fill(begin(), end(), __val);
                	  std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
                					__n - size(), __val,
                					_M_get_Tp_allocator());
                	  this->_M_impl._M_finish += __n - size();
                	}
                      else
                        erase(std::fill_n(begin(), __n, __val), end());
                    }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _InputIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_assign_aux(_InputIterator __first, _InputIterator __last,
                		    std::input_iterator_tag)
                      {
                	iterator __cur(begin());
                	for (; __first != __last && __cur != end(); ++__cur, ++__first)
                	  *__cur = *__first;
                	if (__first == __last)
                	  erase(__cur, end());
                	else
                	  insert(end(), __first, __last);
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		    std::forward_iterator_tag)
                      {
                	const size_type __len = std::distance(__first, __last);
                
                	if (__len > capacity())
                	  {
                	    pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
                	    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			  _M_get_Tp_allocator());
                	    _M_deallocate(this->_M_impl._M_start,
                			  this->_M_impl._M_end_of_storage
                			  - this->_M_impl._M_start);
                	    this->_M_impl._M_start = __tmp;
                	    this->_M_impl._M_finish = this->_M_impl._M_start + __len;
                	    this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
                	  }
                	else if (size() >= __len)
                	  {
                	    iterator __new_finish(std::copy(__first, __last,
                				       this->_M_impl._M_start));
                	    std::_Destroy(__new_finish, end(), _M_get_Tp_allocator());
                	    this->_M_impl._M_finish = __new_finish.base();
                	  }
                	else
                	  {
                	    _ForwardIterator __mid = __first;
                	    std::advance(__mid, size());
                	    std::copy(__first, __mid, this->_M_impl._M_start);
                	    this->_M_impl._M_finish =
                	      std::__uninitialized_copy_a(__mid, __last,
                					  this->_M_impl._M_finish,
                					  _M_get_Tp_allocator());
                	  }
                      }
                
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
       26410 ->     _M_insert_aux(iterator __position, const _Tp& __x)
                    {
                      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	{
                	  this->_M_impl.construct(this->_M_impl._M_finish,
                				  *(this->_M_impl._M_finish - 1));
                	  ++this->_M_impl._M_finish;
                	  _Tp __x_copy = __x;
                	  std::copy_backward(__position,
                			     iterator(this->_M_impl._M_finish-2),
                			     iterator(this->_M_impl._M_finish-1));
                	  *__position = __x_copy;
                	}
                      else
                	{
                	  const size_type __old_size = size();
                	  if (__old_size == this->max_size())
                	    __throw_length_error(__N("vector::_M_insert_aux"));
                
                	  // When sizeof(value_type) == 1 and __old_size > size_type(-1)/2
                	  // __len overflows: if we don't notice and _M_allocate doesn't
                	  // throw we crash badly later.
                	  size_type __len = __old_size != 0 ? 2 * __old_size : 1;	  
                	  if (__len < __old_size)
                	    __len = this->max_size();
                
                	  iterator __new_start(this->_M_allocate(__len));
                	  iterator __new_finish(__new_start);
                	  try
                	    {
                	      __new_finish =
                		std::__uninitialized_copy_a(iterator(this->_M_impl._M_start),
                					    __position,
                					    __new_start,
                					    _M_get_Tp_allocator());
                	      this->_M_impl.construct(__new_finish.base(), __x);
                	      ++__new_finish;
                	      __new_finish =
                		std::__uninitialized_copy_a(__position,
                					    iterator(this->_M_impl._M_finish),
                					    __new_finish,
                					    _M_get_Tp_allocator());
                	    }
                	  catch(...)
                	    {
                	      std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
                	      _M_deallocate(__new_start.base(),__len);
                	      __throw_exception_again;
                	    }
                	  std::_Destroy(begin(), end(), _M_get_Tp_allocator());
                	  _M_deallocate(this->_M_impl._M_start,
                			this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_start);
                	  this->_M_impl._M_start = __new_start.base();
                	  this->_M_impl._M_finish = __new_finish.base();
                	  this->_M_impl._M_end_of_storage = __new_start.base() + __len;
                	}
                    }
                
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
                    {
                      if (__n != 0)
                	{
                	  if (size_type(this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_finish) >= __n)
                	    {
                	      value_type __x_copy = __x;
                	      const size_type __elems_after = end() - __position;
                	      iterator __old_finish(this->_M_impl._M_finish);
                	      if (__elems_after > __n)
                		{
                		  std::__uninitialized_copy_a(this->_M_impl._M_finish - __n,
                					      this->_M_impl._M_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish += __n;
                		  std::copy_backward(__position, __old_finish - __n,
                				     __old_finish);
                		  std::fill(__position, __position + __n, __x_copy);
                		}
                	      else
                		{
                		  std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
                						__n - __elems_after,
                						__x_copy,
                						_M_get_Tp_allocator());
                		  this->_M_impl._M_finish += __n - __elems_after;
                		  std::__uninitialized_copy_a(__position, __old_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish += __elems_after;
                		  std::fill(__position, __old_finish, __x_copy);
                		}
                	    }
                	  else
                	    {
                	      const size_type __old_size = size();
                	      if (this->max_size() - __old_size < __n)
                		__throw_length_error(__N("vector::_M_fill_insert"));
                	      
                	      // See _M_insert_aux above.
                	      size_type __len = __old_size + std::max(__old_size, __n);
                	      if (__len < __old_size)
                		__len = this->max_size();
                
                	      iterator __new_start(this->_M_allocate(__len));
                	      iterator __new_finish(__new_start);
                	      try
                		{
                		  __new_finish =
                		    std::__uninitialized_copy_a(begin(), __position,
                						__new_start,
                						_M_get_Tp_allocator());
                		  std::__uninitialized_fill_n_a(__new_finish, __n, __x,
                						_M_get_Tp_allocator());
                		  __new_finish += __n;
                		  __new_finish =
                		    std::__uninitialized_copy_a(__position, end(), __new_finish,
                						_M_get_Tp_allocator());
                		}
                	      catch(...)
                		{
                		  std::_Destroy(__new_start, __new_finish,
                				_M_get_Tp_allocator());
                		  _M_deallocate(__new_start.base(), __len);
                		  __throw_exception_again;
                		}
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __new_start.base();
                	      this->_M_impl._M_finish = __new_finish.base();
                	      this->_M_impl._M_end_of_storage = __new_start.base() + __len;
                	    }
                	}
                    }
                
                  template<typename _Tp, typename _Alloc> template<typename _InputIterator>
                    void
                    vector<_Tp, _Alloc>::
                    _M_range_insert(iterator __pos, _InputIterator __first,
                		    _InputIterator __last, std::input_iterator_tag)
                    {
                      for (; __first != __last; ++__first)
                	{
                	  __pos = insert(__pos, *__first);
                	  ++__pos;
                	}
                    }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_range_insert(iterator __position, _ForwardIterator __first,
                		      _ForwardIterator __last, std::forward_iterator_tag)
                      {
                	if (__first != __last)
                	  {
                	    const size_type __n = std::distance(__first, __last);
                	    if (size_type(this->_M_impl._M_end_of_storage
                			  - this->_M_impl._M_finish) >= __n)
                	      {
                		const size_type __elems_after = end() - __position;
                		iterator __old_finish(this->_M_impl._M_finish);
                		if (__elems_after > __n)
                		  {
                		    std::__uninitialized_copy_a(this->_M_impl._M_finish - __n,
                						this->_M_impl._M_finish,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __n;
                		    std::copy_backward(__position, __old_finish - __n,
                				       __old_finish);
                		    std::copy(__first, __last, __position);
                		  }
                		else
                		  {
                		    _ForwardIterator __mid = __first;
                		    std::advance(__mid, __elems_after);
                		    std::__uninitialized_copy_a(__mid, __last,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __n - __elems_after;
                		    std::__uninitialized_copy_a(__position, __old_finish,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __elems_after;
                		    std::copy(__first, __mid, __position);
                		  }
                	      }
                	    else
                	      {
                		const size_type __old_size = size();
                		if (this->max_size() - __old_size < __n)
                		  __throw_length_error(__N("vector::_M_range_insert"));	
                
                		// See _M_insert_aux above.
                		size_type __len = __old_size + std::max(__old_size, __n);
                		if (__len < __old_size)
                		  __len = this->max_size();
                
                		iterator __new_start(this->_M_allocate(__len));
                		iterator __new_finish(__new_start);
                		try
                		  {
                		    __new_finish =
                		      std::__uninitialized_copy_a(iterator(this->_M_impl._M_start),
                						  __position,
                						  __new_start,
                						  _M_get_Tp_allocator());
                		    __new_finish =
                		      std::__uninitialized_copy_a(__first, __last, __new_finish,
                						  _M_get_Tp_allocator());
                		    __new_finish =
                		      std::__uninitialized_copy_a(__position,
                						  iterator(this->_M_impl._M_finish),
                						  __new_finish,
                						  _M_get_Tp_allocator());
                		  }
                		catch(...)
                		  {
                		    std::_Destroy(__new_start,__new_finish,
                				  _M_get_Tp_allocator());
                		    _M_deallocate(__new_start.base(), __len);
                		    __throw_exception_again;
                		  }
                		std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			      _M_get_Tp_allocator());
                		_M_deallocate(this->_M_impl._M_start,
                			      this->_M_impl._M_end_of_storage
                			      - this->_M_impl._M_start);
                		this->_M_impl._M_start = __new_start.base();
                		this->_M_impl._M_finish = __new_finish.base();
                		this->_M_impl._M_end_of_storage = __new_start.base() + __len;
                	      }
                	  }
                      }
                } // namespace std
                
                #endif /* _VECTOR_TCC */


Top 10 Lines:

     Line      Count

      249      26410

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

    26410   Total number of line executions
 26410.00   Average executions per line


*** File /usr/lib/gcc/i486-linux-gnu/4.1.2/../../../../include/c++/4.1.2/bits/stl_uninitialized.h:
                // Raw memory manipulators -*- C++ -*-
                
                // Copyright (C) 2001, 2004, 2005 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 2, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // You should have received a copy of the GNU General Public License along
                // with this library; see the file COPYING.  If not, write to the Free
                // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
                // USA.
                
                // As a special exception, you may use this file as part of a free software
                // library without restriction.  Specifically, if other files instantiate
                // templates or use macros or inline functions from this file, or you compile
                // this file and link it with other files to produce an executable, this
                // file does not by itself cause the resulting executable to be covered by
                // the GNU General Public License.  This exception does not however
                // invalidate any other reasons why the executable file might be covered by
                // the GNU General Public License.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file stl_uninitialized.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _STL_UNINITIALIZED_H
                #define _STL_UNINITIALIZED_H 1
                
                #include <cstring>
                
                namespace std
                {
                  // uninitialized_copy
                  template<typename _InputIterator, typename _ForwardIterator>
                    inline _ForwardIterator
                    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
                			     _ForwardIterator __result,
       19582 -> 			     __true_type)
                    { return std::copy(__first, __last, __result); }
                
                  template<typename _InputIterator, typename _ForwardIterator>
                    inline _ForwardIterator
                    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
                			     _ForwardIterator __result,
       33238 -> 			     __false_type)
                    {
                      _ForwardIterator __cur = __result;
                      try
                	{
                	  for (; __first != __last; ++__first, ++__cur)
                	    std::_Construct(&*__cur, *__first);
                	  return __cur;
                	}
                      catch(...)
                	{
                	  std::_Destroy(__result, __cur);
                	  __throw_exception_again;
                	}
                    }
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @param  first  An input iterator.
                   *  @param  last   An input iterator.
                   *  @param  result An output iterator.
                   *  @return   result + (first - last)
                   *
                   *  Like copy(), but does not require an initialized output range.
                  */
                  template<typename _InputIterator, typename _ForwardIterator>
                    inline _ForwardIterator
                    uninitialized_copy(_InputIterator __first, _InputIterator __last,
       52820 -> 		       _ForwardIterator __result)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
                      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
                      return std::__uninitialized_copy_aux(__first, __last, __result,
                					   _Is_POD());
                    }
                
                  inline char*
                  uninitialized_copy(const char* __first, const char* __last, char* __result)
                  {
                    std::memmove(__result, __first, __last - __first);
                    return __result + (__last - __first);
                  }
                
                  inline wchar_t*
                  uninitialized_copy(const wchar_t* __first, const wchar_t* __last,
                		     wchar_t* __result)
                  {
                    std::memmove(__result, __first, sizeof(wchar_t) * (__last - __first));
                    return __result + (__last - __first);
                  }
                
                  // Valid if copy construction is equivalent to assignment, and if the
                  // destructor is trivial.
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    __uninitialized_fill_aux(_ForwardIterator __first,
                			     _ForwardIterator __last,
                			     const _Tp& __x, __true_type)
                    { std::fill(__first, __last, __x); }
                
                  template<typename _ForwardIterator, typename _Tp>
                    void
                    __uninitialized_fill_aux(_ForwardIterator __first, _ForwardIterator __last,
                			     const _Tp& __x, __false_type)
                    {
                      _ForwardIterator __cur = __first;
                      try
                	{
                	  for (; __cur != __last; ++__cur)
                	    std::_Construct(&*__cur, __x);
                	}
                      catch(...)
                	{
                	  std::_Destroy(__first, __cur);
                	  __throw_exception_again;
                	}
                    }
                
                  /**
                   *  @brief Copies the value x into the range [first,last).
                   *  @param  first  An input iterator.
                   *  @param  last   An input iterator.
                   *  @param  x      The source value.
                   *  @return   Nothing.
                   *
                   *  Like fill(), but does not require an initialized output range.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
                		       const _Tp& __x)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
                      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
                      std::__uninitialized_fill_aux(__first, __last, __x, _Is_POD());
                    }
                
                  // Valid if copy construction is equivalent to assignment, and if the
                  //  destructor is trivial.
                  template<typename _ForwardIterator, typename _Size, typename _Tp>
                    inline void
                    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
                			       const _Tp& __x, __true_type)
                    { std::fill_n(__first, __n, __x); }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp>
                    void
                    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
                			       const _Tp& __x, __false_type)
                    {
                      _ForwardIterator __cur = __first;
                      try
                	{
                	  for (; __n > 0; --__n, ++__cur)
                	    std::_Construct(&*__cur, __x);
                	}
                      catch(...)
                	{
                	  std::_Destroy(__first, __cur);
                	  __throw_exception_again;
                	}
                    }
                
                  /**
                   *  @brief Copies the value x into the range [first,first+n).
                   *  @param  first  An input iterator.
                   *  @param  n      The number of copies to make.
                   *  @param  x      The source value.
                   *  @return   Nothing.
                   *
                   *  Like fill_n(), but does not require an initialized output range.
                  */
                  template<typename _ForwardIterator, typename _Size, typename _Tp>
                    inline void
                    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
                      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
                      std::__uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());
                    }
                
                  // Extensions: versions of uninitialized_copy, uninitialized_fill,
                  //  and uninitialized_fill_n that take an allocator parameter.
                  //  We dispatch back to the standard versions when we're given the
                  //  default allocator.  For nondefault allocators we do not use 
                  //  any of the POD optimizations.
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    _ForwardIterator
                    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result,
                			   _Allocator __alloc)
                    {
                      _ForwardIterator __cur = __result;
                      try
                	{
                	  for (; __first != __last; ++__first, ++__cur)
                	    __alloc.construct(&*__cur, *__first);
                	  return __cur;
                	}
                      catch(...)
                	{
                	  std::_Destroy(__result, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
                    inline _ForwardIterator
                    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result,
       52820 -> 			   allocator<_Tp>)
                    {
                      return std::uninitialized_copy(__first, __last, __result);
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
                    void
                    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
                			   const _Tp& __x, _Allocator __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      try
                	{
                	  for (; __cur != __last; ++__cur)
                	    __alloc.construct(&*__cur, __x);
                	}
                      catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
                    inline void
                    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
                			   const _Tp& __x, allocator<_Tp2>)
                    {
                      std::uninitialized_fill(__first, __last, __x);
                    }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp,
                	   typename _Allocator>
                    void
                    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
                			     const _Tp& __x,
                			     _Allocator __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      try
                	{
                	  for (; __n > 0; --__n, ++__cur)
                	    __alloc.construct(&*__cur, __x);
                	}
                      catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp,
                	   typename _Tp2>
                    void
                    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
                			     const _Tp& __x,
                			     allocator<_Tp2>)
                    {
                      std::uninitialized_fill_n(__first, __n, __x);
                    }
                
                
                  // Extensions: __uninitialized_copy_copy, __uninitialized_copy_fill,
                  // __uninitialized_fill_copy.  All of these algorithms take a user-
                  // supplied allocator, which is used for construction and destruction.
                
                  // __uninitialized_copy_copy
                  // Copies [first1, last1) into [result, result + (last1 - first1)), and
                  //  copies [first2, last2) into
                  //  [result, result + (last1 - first1) + (last2 - first2)).
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _ForwardIterator, typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_copy_copy(_InputIterator1 __first1,
                			      _InputIterator1 __last1,
                			      _InputIterator2 __first2,
                			      _InputIterator2 __last2,
                			      _ForwardIterator __result,
                			      _Allocator __alloc)
                    {
                      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
                							   __result,
                							   __alloc);
                      try
                	{
                	  return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
                	}
                      catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  // __uninitialized_fill_copy
                  // Fills [result, mid) with x, and copies [first, last) into
                  //  [mid, mid + (last - first)).
                  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_fill_copy(_ForwardIterator __result, _ForwardIterator __mid,
                			      const _Tp& __x, _InputIterator __first,
                			      _InputIterator __last,
                			      _Allocator __alloc)
                    {
                      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
                      try
                	{
                	  return std::__uninitialized_copy_a(__first, __last, __mid, __alloc);
                	}
                      catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  // __uninitialized_copy_fill
                  // Copies [first1, last1) into [first2, first2 + (last1 - first1)), and
                  //  fills [first2 + (last1 - first1), last2) with x.
                  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
                	   typename _Allocator>
                    inline void
                    __uninitialized_copy_fill(_InputIterator __first1, _InputIterator __last1,
                			      _ForwardIterator __first2,
                			      _ForwardIterator __last2, const _Tp& __x,
                			      _Allocator __alloc)
                    {
                      _ForwardIterator __mid2 = std::__uninitialized_copy_a(__first1, __last1,
                							    __first2,
                							    __alloc);
                      try
                	{
                	  std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
                	}
                      catch(...)
                	{
                	  std::_Destroy(__first2, __mid2, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                } // namespace std
                
                #endif /* _STL_UNINITIALIZED_H */


Top 10 Lines:

     Line      Count

      108      52820
      252      52820
       80      33238
       73      19582

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

   158460   Total number of line executions
 39615.00   Average executions per line


*** File /usr/lib/gcc/i486-linux-gnu/4.1.2/../../../../include/c++/4.1.2/ext/new_allocator.h:
                // Allocator that wraps operator new -*- C++ -*-
                
                // Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 2, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // You should have received a copy of the GNU General Public License along
                // with this library; see the file COPYING.  If not, write to the Free
                // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
                // USA.
                
                // As a special exception, you may use this file as part of a free software
                // library without restriction.  Specifically, if other files instantiate
                // templates or use macros or inline functions from this file, or you compile
                // this file and link it with other files to produce an executable, this
                // file does not by itself cause the resulting executable to be covered by
                // the GNU General Public License.  This exception does not however
                // invalidate any other reasons why the executable file might be covered by
                // the GNU General Public License.
                
                /** @file ext/new_allocator.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _NEW_ALLOCATOR_H
                #define _NEW_ALLOCATOR_H 1
                
                #include <new>
                #include <bits/functexcept.h>
                
                namespace __gnu_cxx
                {
                  /**
                   *  @brief  An allocator that uses global new, as per [20.4].
                   *
                   *  This is precisely the allocator defined in the C++ Standard. 
                   *    - all allocation calls operator new
                   *    - all deallocation calls operator delete
                   */
                  template<typename _Tp>
                    class new_allocator
                    {
                    public:
                      typedef size_t     size_type;
                      typedef ptrdiff_t  difference_type;
                      typedef _Tp*       pointer;
                      typedef const _Tp* const_pointer;
                      typedef _Tp&       reference;
                      typedef const _Tp& const_reference;
                      typedef _Tp        value_type;
                
                      template<typename _Tp1>
                        struct rebind
                        { typedef new_allocator<_Tp1> other; };
                
       37284 ->       new_allocator() throw() { }
                
      193519 ->       new_allocator(const new_allocator&) throw() { }
                
                      template<typename _Tp1>
                        new_allocator(const new_allocator<_Tp1>&) throw() { }
                
      197584 ->       ~new_allocator() throw() { }
                
                      pointer
                      address(reference __x) const { return &__x; }
                
                      const_pointer
                      address(const_reference __x) const { return &__x; }
                
                      // NB: __n is permitted to be 0.  The C++ standard says nothing
                      // about what the return value is when __n == 0.
                      pointer
       26439 ->       allocate(size_type __n, const void* = 0)
                      { 
                	if (__builtin_expect(__n > this->max_size(), false))
                	  std::__throw_bad_alloc();
                
                	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
                      }
                
                      // __p is not permitted to be a null pointer.
                      void
        7862 ->       deallocate(pointer __p, size_type)
                      { ::operator delete(__p); }
                
                      size_type
       26439 ->       max_size() const throw() 
                      { return size_t(-1) / sizeof(_Tp); }
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 402. wrong new expression in [some_] allocator::construct
                      void 
    12095913 ->       construct(pointer __p, const _Tp& __val) 
                      { ::new(__p) _Tp(__val); }
                
                      void 
        1983 ->       destroy(pointer __p) { __p->~_Tp(); }
                    };
                
                  template<typename _Tp>
                    inline bool
                    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
                    { return true; }
                  
                  template<typename _Tp>
                    inline bool
                    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
                    { return false; }
                } // namespace __gnu_cxx
                
                #endif


Top 10 Lines:

     Line      Count

      103   12095913
       72     197584
       67     193519
       65      37284
       83      26439
       97      26439
       93       7862
      107       1983

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

 12587023   Total number of line executions
1573377.88   Average executions per line


*** File /usr/lib/gcc/i486-linux-gnu/4.1.2/../../../../include/c++/4.1.2/bits/allocator.h:
                // Allocators -*- C++ -*-
                
                // Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 2, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // You should have received a copy of the GNU General Public License along
                // with this library; see the file COPYING.  If not, write to the Free
                // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
                // USA.
                
                // As a special exception, you may use this file as part of a free software
                // library without restriction.  Specifically, if other files instantiate
                // templates or use macros or inline functions from this file, or you compile
                // this file and link it with other files to produce an executable, this
                // file does not by itself cause the resulting executable to be covered by
                // the GNU General Public License.  This exception does not however
                // invalidate any other reasons why the executable file might be covered by
                // the GNU General Public License.
                
                /*
                 * Copyright (c) 1996-1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file allocator.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _ALLOCATOR_H
                #define _ALLOCATOR_H 1
                
                // Define the base class to std::allocator.
                #include <bits/c++allocator.h>
                
                namespace std
                {
                  template<typename _Tp>
                    class allocator;
                
                  /// allocator<void> specialization.
                  template<>
                    class allocator<void>
                    {
                    public:
                      typedef size_t      size_type;
                      typedef ptrdiff_t   difference_type;
                      typedef void*       pointer;
                      typedef const void* const_pointer;
                      typedef void        value_type;
                
                      template<typename _Tp1>
                        struct rebind
                        { typedef allocator<_Tp1> other; };
                    };
                
                  /**
                   * @brief  The "standard" allocator, as per [20.4].
                   *
                   *  Further details:
                   *  http://gcc.gnu.org/onlinedocs/libstdc++/20_util/allocator.html
                   */
                  template<typename _Tp>
                    class allocator: public __glibcxx_base_allocator<_Tp>
                    {
                   public:
                      typedef size_t     size_type;
                      typedef ptrdiff_t  difference_type;
                      typedef _Tp*       pointer;
                      typedef const _Tp* const_pointer;
                      typedef _Tp&       reference;
                      typedef const _Tp& const_reference;
                      typedef _Tp        value_type;
                
                      template<typename _Tp1>
                        struct rebind
                        { typedef allocator<_Tp1> other; };
                
       37225 ->       allocator() throw() { }
                
      193519 ->       allocator(const allocator& __a) throw()
                      : __glibcxx_base_allocator<_Tp>(__a) { }
                
                      template<typename _Tp1>
          59 ->         allocator(const allocator<_Tp1>&) throw() { }
                
      197584 ->       ~allocator() throw() { }
                
                      // Inherit everything else.
                    };
                
                  template<typename _T1, typename _T2>
                    inline bool
                    operator==(const allocator<_T1>&, const allocator<_T2>&)
                    { return true; }
                
                  template<typename _T1, typename _T2>
                    inline bool
                    operator!=(const allocator<_T1>&, const allocator<_T2>&)
                    { return false; }
                
                  // Inhibit implicit instantiations for required instantiations,
                  // which are defined via explicit instantiations elsewhere.
                  // NB: This syntax is a GNU extension.
                #if _GLIBCXX_EXTERN_TEMPLATE
                  extern template class allocator<char>;
                  extern template class allocator<wchar_t>;
                #endif
                
                  // Undefine.
                #undef __glibcxx_base_allocator
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

      105     197584
       99     193519
       97      37225
      103         59

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

   428387   Total number of line executions
107096.75   Average executions per line


*** File /home/tyler/Desktop/fland2/rendervertex.h:
                // Render Vertex. An object that is drawn onscreen.
                #ifndef RENDER_VERTEX_H
                #define RENDER_VERTEX_H
                
                using namespace std;
                
                #include <string>
                #include <GL/glut.h>
                #include "defines.h"
                #include "camera.h"
                #include "fland.h"
                
                class BoundSphere
                {
                	public:
                	QUARD_TYPE x, y, z;
                
                	// a bounding sphere, this is the radius. The center is the location, above.
                	DIS_TYPE radius;
                	inline void initalize();
                	BoundSphere();
                };
       54760 -> inline void BoundSphere::initalize()
                {
                	x = y = z = 0.0;
                	radius = 1.0;
                }
                
                class RenderVertex
     1924151 -> {
                	public:
                	GLfloat x, y, z;
                	GLfloat red, green, blue;
                	GLfloat nx, ny, nz; // normals
                	//bool isDeleted; // debug
                
                	RenderVertex();
                	//void operator=( const RenderVertex& );
                	inline void initalize();
                
                //	void printVertex();
                	inline void interpolate( const RenderVertex &start, const RenderVertex &end, double amount);
                	inline RenderVertex operator*( double );
                	inline void operator+=( const RenderVertex& );
                	inline void drawNormal( float );
                	string toString( int = 0 );
                };
                
                
                
     1631799 -> inline void RenderVertex::interpolate( const RenderVertex &start, const RenderVertex &end, double amount )
                {
                	// set up an inverse amount.
                	double invAmount = (double)1.0 - amount;
                
                	x = start.x * invAmount + end.x * amount;
                	y = start.y * invAmount + end.y * amount;
                	z = start.z * invAmount + end.z * amount;
                
                	nx = start.nx * invAmount + end.nx * amount;
                	ny = start.ny * invAmount + end.ny * amount;
                	nz = start.nz * invAmount + end.nz * amount;
                
                	red = start.red * invAmount + end.red * amount;
                	blue = start.blue * invAmount + end.blue * amount;
                	green = start.green * invAmount + end.green * amount;
                }
                
      149189 -> inline void RenderVertex::initalize()
                {
                	x = y = z = 0.0;
                	nx = ny = nz = 0.0;
                	red = green = blue = 0.0;
                }
                
                inline void RenderVertex::drawNormal( float length )
                {
                	glNormal3f( 0.0, 0.0, 0.0 );
                	glColor3f( 1.0, 1.0, 1.0 );
                	glBegin( GL_LINES );
                		glVertex3f( x, y, z );
                		glVertex3f( x+(nx*length), y+(ny*length), z+(nz*length) );
                	glEnd();
                }
                
       25295 -> inline void RenderVertex::operator+=( const RenderVertex &addVert )
                {
                	x += addVert.x;
                	y += addVert.y;
                	z += addVert.z;
                
                	nx += addVert.nx;
                	ny += addVert.ny;
                	nz += addVert.nz;
                
                	red += addVert.red;
                	green += addVert.green;
                	blue += addVert.blue;
                }
                
       46718 -> inline RenderVertex RenderVertex::operator*( double mulBy )
                {
                	RenderVertex ret;
                	ret.x = x * mulBy;
                	ret.y = y * mulBy;
                	ret.z = z * mulBy;
                
                	ret.nx = nx * mulBy;
                	ret.ny = ny * mulBy;
                	ret.nz = nz * mulBy;
                
                	ret.red = red * mulBy;
                	ret.green = green * mulBy;
                	ret.blue = blue * mulBy;
                
                	return ret;
                }
                
                
                #endif
                


Top 10 Lines:

     Line      Count

       30    1924151
       51    1631799
       69     149189
       23      54760
      101      46718
       86      25295

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

  3831912   Total number of line executions
638652.00   Average executions per line


*** File /home/tyler/Desktop/fland2/vertex.h:
                // every vertex in a mesh
                #ifndef VERTEX_H
                #define VERTEX_H
                
                // NOTE: A vertex's children will be stored in the child vector, along with
                // in the vChild array.
                
                using namespace std;
                
                #include <math.h>
                #include "rendervertex.h"
                #include "baseent.h"
                #include "templates.h"
                #include "main.h"
                
                #define NUM_AFFECT_VERTICIES 4
                
                extern vector<RenderVertex> vertexArray;
                extern vector<GLuint> vertexArrayIndexList;
                
                //#define LEFT 0;
                //#define RIGHT 1;
                
                class Vertex : public BaseEnt
       16602 -> {
                	public:
                
                	// Pointer to each child this entity has. NULL is used if the children dont exist.
                	//BaseEnt *vChild[9];
                	Vertex *vChild[9];
                
                	// Pointer to each neighbor. Ourself is included, just to make it easier to use.
                	// NULL if not exist.
                	Vertex *neighbor[9];
                
                	// This keeps track of which child of our parent's we are.
                	// from 0 to 8
                	// -1 means we dont have a parent vertex - our parent is the mesh
                	int vChildNum;
                
                	RenderVertex trueVertex; // where the vertex really is
                	RenderVertex startMorphVertex; // where we start morphing.
                	RenderVertex morphVertex; // current morph location
                
                
                	// This is for the rules. It keeps track of which neighboring verticies affect us
                	// and by how much.
                	BaseEnt* affectVertex[NUM_AFFECT_VERTICIES];
                	double affectAmount[NUM_AFFECT_VERTICIES];
                
                    GLuint vertexArrayIndex;
                
                	///////////////////////////////////////////////////////////////////////////
                	// the functions
                
                
                	// EXTRAS. These parameters dont apply to the actual workings of the vertex, but
                	// how some rules (will) work with them.
                	// Certain rules (will) use these values
                	//QUARD_TYPE u, v;
                	inline QUARD_TYPE getAltitude();
                    inline QUARD_TYPE getX();
                    inline QUARD_TYPE getY();
                    inline QUARD_TYPE getZ();
                	inline float getSlope();
                	//QUARD_TYPE slope;
                
                	// calculate a vertex's children's normals, based on the vertex's neighbors.
                	void calcNormals();
                
                	virtual int constructor( BaseEnt *parent );
                
                	virtual void destructor( bool willDelete = false );
                
                	// used in the destructor to clear neighbor's pointers to me.
                	void clearNeighborPointersToMe();
                
                	virtual void draw();
                
                	virtual void split();
                
                	// checks a vertex's neighbors.
                	virtual bool specialUnSplitCheck();
                
                	//virtual int calculateMe();
                
                	virtual bool canUnSplit();
                
                	virtual void calcMorph( double );
                
                	#if( DEBUG )
                	virtual void dump( ostream&, int );
                	virtual string toString( int );
                	virtual void printType();
                	virtual string getType();
                	void recursiveCheck();
                	#endif
                	static Reuse< BaseEnt, Vertex > reuse;
                
                	// FROM MESH
                	// The recursive function that draws the triangles.
                	// returns 1 if something went wrong.
                	// Takes three vertexes and tritype is either LEFT or RIGHT
                	//int drawTri( BaseEnt*, BaseEnt*, BaseEnt*, int );
                	int drawLeft( BaseEnt*, BaseEnt*, BaseEnt* );
                	int drawRight( BaseEnt*, BaseEnt*, BaseEnt* );
                
                
                	void teapot();
                	private:
                	bool isEdge; // if this vertex lies on the edge of a mesh.
                					 // Different split logic applies
                	bool isCorner; // if on a corner of more then one mesh. WAY different logic.
                
                	// This makes sure that a vertex's neighbors are all split to at least the same
                	// depth as she is.
                	int assertNeighborsSplit();
                
                	// This function creates the children and points us to them, and them to us.
                	int createChildren();
                
                	// points the children at thier neighbors.
                	int pointChildrenAtNeighbors();
                
                	// sets the affect verticies and how much affect they have on EVERY vChild.
                	int calcAffectVerticies();
                
                	// calculate the starting morph location, colors, etc...
                	// of a vertex's newly created children
                	void calcStartMorph();
                
                    inline void addIndexToVertexArrayIndexList();
                
                };
                
                
       ##### -> float Vertex::getSlope(){ return acos( trueVertex.ny ) * ( 1.0 / ( PI / 2.0 ) ); }
       ##### -> QUARD_TYPE Vertex::getAltitude() { return trueVertex.y; }
       17551 -> QUARD_TYPE Vertex::getX() { return trueVertex.x; }
       17551 -> QUARD_TYPE Vertex::getY() { return trueVertex.y; }
       17551 -> QUARD_TYPE Vertex::getZ() { return trueVertex.z; }
                
    10165410 -> void Vertex::addIndexToVertexArrayIndexList()
                {
                    vertexArrayIndexList.push_back( vertexArrayIndex );
                }
                
                #endif
                


Top 10 Lines:

     Line      Count

      143   10165410
      139      17551
      140      17551
      141      17551
       25      16602

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

 10234665   Total number of line executions
1462095.00   Average executions per line


*** File /usr/lib/gcc/i486-linux-gnu/4.1.2/../../../../include/c++/4.1.2/bits/stl_map.h:
                // Map implementation -*- C++ -*-
                
                // Copyright (C) 2001, 2002, 2004, 2005 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 2, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // You should have received a copy of the GNU General Public License along
                // with this library; see the file COPYING.  If not, write to the Free
                // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
                // USA.
                
                // As a special exception, you may use this file as part of a free software
                // library without restriction.  Specifically, if other files instantiate
                // templates or use macros or inline functions from this file, or you compile
                // this file and link it with other files to produce an executable, this
                // file does not by itself cause the resulting executable to be covered by
                // the GNU General Public License.  This exception does not however
                // invalidate any other reasons why the executable file might be covered by
                // the GNU General Public License.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file stl_map.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _MAP_H
                #define _MAP_H 1
                
                #include <bits/functexcept.h>
                #include <bits/concept_check.h>
                
                namespace _GLIBCXX_STD
                {
                  /**
                   *  @brief A standard container made up of (key,value) pairs, which can be
                   *  retrieved based on a key, in logarithmic time.
                   *
                   *  @ingroup Containers
                   *  @ingroup Assoc_containers
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and an
                   *  <a href="tables.html#69">associative container</a> (using unique keys).
                   *  For a @c map<Key,T> the key_type is Key, the mapped_type is T, and the
                   *  value_type is std::pair<const Key,T>.
                   *
                   *  Maps support bidirectional iterators.
                   *
                   *  @if maint
                   *  The private tree data is declared exactly the same way for map and
                   *  multimap; the distinction is made entirely in how the tree functions are
                   *  called (*_unique versus *_equal, same as the standard).
                   *  @endif
                  */
                  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
                            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
                    class map
           1 ->     {
                    public:
                      typedef _Key                                          key_type;
                      typedef _Tp                                           mapped_type;
                      typedef std::pair<const _Key, _Tp>                    value_type;
                      typedef _Compare                                      key_compare;
                      typedef _Alloc                                        allocator_type;
                
                    private:
                      // concept requirements
                      typedef typename _Alloc::value_type                   _Alloc_value_type;
                      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
                      __glibcxx_class_requires4(_Compare, bool, _Key, _Key,
                				_BinaryFunctionConcept)
                      __glibcxx_class_requires2(value_type, _Alloc_value_type, _SameTypeConcept)
                
                    public:
                      class value_compare
                      : public std::binary_function<value_type, value_type, bool>
                      {
                	friend class map<_Key, _Tp, _Compare, _Alloc>;
                      protected:
                	_Compare comp;
                
                	value_compare(_Compare __c)
                	: comp(__c) { }
                
                      public:
                	bool operator()(const value_type& __x, const value_type& __y) const
                	{ return comp(__x.first, __y.first); }
                      };
                
                    private:
                      /// @if maint  This turns a red-black tree into a [multi]map.  @endif
                      typedef typename _Alloc::template rebind<value_type>::other 
                        _Pair_alloc_type;
                
                      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
                		       key_compare, _Pair_alloc_type> _Rep_type;
                
                      /// @if maint  The actual tree structure.  @endif
                      _Rep_type _M_t;
                
                    public:
                      // many of these are specified differently in ISO, but the following are
                      // "functionally equivalent"
                      typedef typename _Pair_alloc_type::pointer         pointer;
                      typedef typename _Pair_alloc_type::const_pointer   const_pointer;
                      typedef typename _Pair_alloc_type::reference       reference;
                      typedef typename _Pair_alloc_type::const_reference const_reference;
                      typedef typename _Rep_type::iterator               iterator;
                      typedef typename _Rep_type::const_iterator         const_iterator;
                      typedef typename _Rep_type::size_type              size_type;
                      typedef typename _Rep_type::difference_type        difference_type;
                      typedef typename _Rep_type::reverse_iterator       reverse_iterator;
                      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
                
                      // [23.3.1.1] construct/copy/destroy
                      // (get_allocator() is normally listed in this section, but seems to have
                      // been accidentally omitted in the printed standard)
                      /**
                       *  @brief  Default constructor creates no elements.
                       */
           1 ->       map()
                      : _M_t(_Compare(), allocator_type()) { }
                
                      // for some reason this was made a separate function
                      /**
                       *  @brief  Default constructor creates no elements.
                       */
                      explicit
                      map(const _Compare& __comp, const allocator_type& __a = allocator_type())
                      : _M_t(__comp, __a) { }
                
                      /**
                       *  @brief  Map copy constructor.
                       *  @param  x  A %map of identical element and allocator types.
                       *
                       *  The newly-created %map uses a copy of the allocation object used
                       *  by @a x.
                       */
                      map(const map& __x)
                      : _M_t(__x._M_t) { }
                
                      /**
                       *  @brief  Builds a %map from a range.
                       *  @param  first  An input iterator.
                       *  @param  last  An input iterator.
                       *
                       *  Create a %map consisting of copies of the elements from [first,last).
                       *  This is linear in N if the range is already sorted, and NlogN
                       *  otherwise (where N is distance(first,last)).
                       */
                      template <typename _InputIterator>
                        map(_InputIterator __first, _InputIterator __last)
                	: _M_t(_Compare(), allocator_type())
                        { _M_t.insert_unique(__first, __last); }
                
                      /**
                       *  @brief  Builds a %map from a range.
                       *  @param  first  An input iterator.
                       *  @param  last  An input iterator.
                       *  @param  comp  A comparison functor.
                       *  @param  a  An allocator object.
                       *
                       *  Create a %map consisting of copies of the elements from [first,last).
                       *  This is linear in N if the range is already sorted, and NlogN
                       *  otherwise (where N is distance(first,last)).
                       */
                      template <typename _InputIterator>
                        map(_InputIterator __first, _InputIterator __last,
                	    const _Compare& __comp, const allocator_type& __a = allocator_type())
                	: _M_t(__comp, __a)
                        { _M_t.insert_unique(__first, __last); }
                
                      // FIXME There is no dtor declared, but we should have something generated
                      // by Doxygen.  I don't know what tags to add to this paragraph to make
                      // that happen:
                      /**
                       *  The dtor only erases the elements, and note that if the elements
                       *  themselves are pointers, the pointed-to memory is not touched in any
                       *  way.  Managing the pointer is the user's responsibilty.
                       */
                
                      /**
                       *  @brief  Map assignment operator.
                       *  @param  x  A %map of identical element and allocator types.
                       *
                       *  All the elements of @a x are copied, but unlike the copy constructor,
                       *  the allocator object is not copied.
                       */
                      map&
                      operator=(const map& __x)
                      {
                	_M_t = __x._M_t;
                	return *this;
                      }
                
                      /// Get a copy of the memory allocation object.
                      allocator_type
                      get_allocator() const
                      { return _M_t.get_allocator(); }
                
                      // iterators
                      /**
                       *  Returns a read/write iterator that points to the first pair in the
                       *  %map.
                       *  Iteration is done in ascending order according to the keys.
                       */
                      iterator
           1 ->       begin()
                      { return _M_t.begin(); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the first pair
                       *  in the %map.  Iteration is done in ascending order according to the
                       *  keys.
                       */
                      const_iterator
                      begin() const
                      { return _M_t.begin(); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last pair in
                       *  the %map.  Iteration is done in ascending order according to the keys.
                       */
                      iterator
         123 ->       end()
                      { return _M_t.end(); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the last
                       *  pair in the %map.  Iteration is done in ascending order according to
                       *  the keys.
                       */
                      const_iterator
                      end() const
                      { return _M_t.end(); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the last pair in
                       *  the %map.  Iteration is done in descending order according to the
                       *  keys.
                       */
                      reverse_iterator
                      rbegin()
                      { return _M_t.rbegin(); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points to the
                       *  last pair in the %map.  Iteration is done in descending order
                       *  according to the keys.
                       */
                      const_reverse_iterator
                      rbegin() const
                      { return _M_t.rbegin(); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one before the
                       *  first pair in the %map.  Iteration is done in descending order
                       *  according to the keys.
                       */
                      reverse_iterator
                      rend()
                      { return _M_t.rend(); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points to one
                       *  before the first pair in the %map.  Iteration is done in descending
                       *  order according to the keys.
                       */
                      const_reverse_iterator
                      rend() const
                      { return _M_t.rend(); }
                
                      // capacity
                      /** Returns true if the %map is empty.  (Thus begin() would equal
                       *  end().)
                      */
                      bool
                      empty() const
                      { return _M_t.empty(); }
                
                      /** Returns the size of the %map.  */
                      size_type
                      size() const
                      { return _M_t.size(); }
                
                      /** Returns the maximum size of the %map.  */
                      size_type
                      max_size() const
                      { return _M_t.max_size(); }
                
                      // [23.3.1.2] element access
                      /**
                       *  @brief  Subscript ( @c [] ) access to %map data.
                       *  @param  k  The key for which data should be retrieved.
                       *  @return  A reference to the data of the (key,data) %pair.
                       *
                       *  Allows for easy lookup with the subscript ( @c [] ) operator.  Returns
                       *  data associated with the key specified in subscript.  If the key does
                       *  not exist, a pair with that key is created using default values, which
                       *  is then returned.
                       *
                       *  Lookup requires logarithmic time.
                       */
                      mapped_type&
          93 ->       operator[](const key_type& __k)
                      {
                	// concept requirements
                	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)
                
                	iterator __i = lower_bound(__k);
                	// __i->first is greater than or equivalent to __k.
                	if (__i == end() || key_comp()(__k, (*__i).first))
                          __i = insert(__i, value_type(__k, mapped_type()));
                	return (*__i).second;
                      }
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 464. Suggestion for new member functions in standard containers.
                      /**
                       *  @brief  Access to %map data.
                       *  @param  k  The key for which data should be retrieved.
                       *  @return  A reference to the data whose key is equivalent to @a k, if
                       *           such a data is present in the %map.
                       *  @throw  std::out_of_range  If no such data is present.
                       */
                      mapped_type&
                      at(const key_type& __k)
                      {
                	iterator __i = lower_bound(__k);
                	if (__i == end() || key_comp()(__k, (*__i).first))
                	  __throw_out_of_range(__N("map::at"));
                	return (*__i).second;
                      }
                
                      const mapped_type&
                      at(const key_type& __k) const
                      {
                	const_iterator __i = lower_bound(__k);
                	if (__i == end() || key_comp()(__k, (*__i).first))
                	  __throw_out_of_range(__N("map::at"));
                	return (*__i).second;
                      }
                
                      // modifiers
                      /**
                       *  @brief Attempts to insert a std::pair into the %map.
                       *  @param  x  Pair to be inserted (see std::make_pair for easy creation of
                       *             pairs).
                       *  @return  A pair, of which the first element is an iterator that points
                       *           to the possibly inserted pair, and the second is a bool that
                       *           is true if the pair was actually inserted.
                       *
                       *  This function attempts to insert a (key, value) %pair into the %map.
                       *  A %map relies on unique keys and thus a %pair is only inserted if its
                       *  first element (the key) is not already present in the %map.
                       *
                       *  Insertion requires logarithmic time.
                       */
                      std::pair<iterator,bool>
                      insert(const value_type& __x)
                      { return _M_t.insert_unique(__x); }
                
                      /**
                       *  @brief Attempts to insert a std::pair into the %map.
                       *  @param  position  An iterator that serves as a hint as to where the
                       *                    pair should be inserted.
                       *  @param  x  Pair to be inserted (see std::make_pair for easy creation of
                       *             pairs).
                       *  @return  An iterator that points to the element with key of @a x (may
                       *           or may not be the %pair passed in).
                       *
                       *  This function is not concerned about whether the insertion took place,
                       *  and thus does not return a boolean like the single-argument
                       *  insert() does.  Note that the first parameter is only a hint and can
                       *  potentially improve the performance of the insertion process.  A bad
                       *  hint would cause no gains in efficiency.
                       *
                       *  See http://gcc.gnu.org/onlinedocs/libstdc++/23_containers/howto.html#4
                       *  for more on "hinting".
                       *
                       *  Insertion requires logarithmic time (if the hint is not taken).
                       */
                      iterator
          29 ->       insert(iterator position, const value_type& __x)
                      { return _M_t.insert_unique(position, __x); }
                
                      /**
                       *  @brief A template function that attemps to insert a range of elements.
                       *  @param  first  Iterator pointing to the start of the range to be
                       *                 inserted.
                       *  @param  last  Iterator pointing to the end of the range.
                       *
                       *  Complexity similar to that of the range constructor.
                       */
                      template <typename _InputIterator>
                        void
                        insert(_InputIterator __first, _InputIterator __last)
                        { _M_t.insert_unique(__first, __last); }
                
                      /**
                       *  @brief Erases an element from a %map.
                       *  @param  position  An iterator pointing to the element to be erased.
                       *
                       *  This function erases an element, pointed to by the given iterator,
                       *  from a %map.  Note that this function only erases the element, and
                       *  that if the element is itself a pointer, the pointed-to memory is not
                       *  touched in any way.  Managing the pointer is the user's responsibilty.
                       */
                      void
                      erase(iterator __position)
                      { _M_t.erase(__position); }
                
                      /**
                       *  @brief Erases elements according to the provided key.
                       *  @param  x  Key of element to be erased.
                       *  @return  The number of elements erased.
                       *
                       *  This function erases all the elements located by the given key from
                       *  a %map.
                       *  Note that this function only erases the element, and that if
                       *  the element is itself a pointer, the pointed-to memory is not touched
                       *  in any way.  Managing the pointer is the user's responsibilty.
                       */
                      size_type
                      erase(const key_type& __x)
                      { return _M_t.erase(__x); }
                
                      /**
                       *  @brief Erases a [first,last) range of elements from a %map.
                       *  @param  first  Iterator pointing to the start of the range to be
                       *                 erased.
                       *  @param  last  Iterator pointing to the end of the range to be erased.
                       *
                       *  This function erases a sequence of elements from a %map.
                       *  Note that this function only erases the element, and that if
                       *  the element is itself a pointer, the pointed-to memory is not touched
                       *  in any way.  Managing the pointer is the user's responsibilty.
                       */
                      void
                      erase(iterator __first, iterator __last)
                      { _M_t.erase(__first, __last); }
                
                      /**
                       *  @brief  Swaps data with another %map.
                       *  @param  x  A %map of the same element and allocator types.
                       *
                       *  This exchanges the elements between two maps in constant time.
                       *  (It is only swapping a pointer, an integer, and an instance of
                       *  the @c Compare type (which itself is often stateless and empty), so it
                       *  should be quite fast.)
                       *  Note that the global std::swap() function is specialized such that
                       *  std::swap(m1,m2) will feed to this function.
                       */
                      void
                      swap(map& __x)
                      { _M_t.swap(__x._M_t); }
                
                      /**
                       *  Erases all elements in a %map.  Note that this function only erases
                       *  the elements, and that if the elements themselves are pointers, the
                       *  pointed-to memory is not touched in any way.  Managing the pointer is
                       *  the user's responsibilty.
                       */
                      void
                      clear()
                      { _M_t.clear(); }
                
                      // observers
                      /**
                       *  Returns the key comparison object out of which the %map was
                       *  constructed.
                       */
                      key_compare
          91 ->       key_comp() const
                      { return _M_t.key_comp(); }
                
                      /**
                       *  Returns a value comparison object, built from the key comparison
                       *  object out of which the %map was constructed.
                       */
                      value_compare
                      value_comp() const
                      { return value_compare(_M_t.key_comp()); }
                
                      // [23.3.1.3] map operations
                      /**
                       *  @brief Tries to locate an element in a %map.
                       *  @param  x  Key of (key, value) %pair to be located.
                       *  @return  Iterator pointing to sought-after element, or end() if not
                       *           found.
                       *
                       *  This function takes a key and tries to locate the element with which
                       *  the key matches.  If successful the function returns an iterator
                       *  pointing to the sought after %pair.  If unsuccessful it returns the
                       *  past-the-end ( @c end() ) iterator.
                       */
                      iterator
                      find(const key_type& __x)
                      { return _M_t.find(__x); }
                
                      /**
                       *  @brief Tries to locate an element in a %map.
                       *  @param  x  Key of (key, value) %pair to be located.
                       *  @return  Read-only (constant) iterator pointing to sought-after
                       *           element, or end() if not found.
                       *
                       *  This function takes a key and tries to locate the element with which
                       *  the key matches.  If successful the function returns a constant
                       *  iterator pointing to the sought after %pair. If unsuccessful it
                       *  returns the past-the-end ( @c end() ) iterator.
                       */
                      const_iterator
                      find(const key_type& __x) const
                      { return _M_t.find(__x); }
                
                      /**
                       *  @brief  Finds the number of elements with given key.
                       *  @param  x  Key of (key, value) pairs to be located.
                       *  @return  Number of elements with specified key.
                       *
                       *  This function only makes sense for multimaps; for map the result will
                       *  either be 0 (not present) or 1 (present).
                       */
                      size_type
                      count(const key_type& __x) const
                      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
                
                      /**
                       *  @brief Finds the beginning of a subsequence matching given key.
                       *  @param  x  Key of (key, value) pair to be located.
                       *  @return  Iterator pointing to first element equal to or greater
                       *           than key, or end().
                       *
                       *  This function returns the first element of a subsequence of elements
                       *  that matches the given key.  If unsuccessful it returns an iterator
                       *  pointing to the first element that has a greater value than given key
                       *  or end() if no such element exists.
                       */
                      iterator
          93 ->       lower_bound(const key_type& __x)
                      { return _M_t.lower_bound(__x); }
                
                      /**
                       *  @brief Finds the beginning of a subsequence matching given key.
                       *  @param  x  Key of (key, value) pair to be located.
                       *  @return  Read-only (constant) iterator pointing to first element
                       *           equal to or greater than key, or end().
                       *
                       *  This function returns the first element of a subsequence of elements
                       *  that matches the given key.  If unsuccessful it returns an iterator
                       *  pointing to the first element that has a greater value than given key
                       *  or end() if no such element exists.
                       */
                      const_iterator
                      lower_bound(const key_type& __x) const
                      { return _M_t.lower_bound(__x); }
                
                      /**
                       *  @brief Finds the end of a subsequence matching given key.
                       *  @param  x  Key of (key, value) pair to be located.
                       *  @return Iterator pointing to the first element
                       *          greater than key, or end().
                       */
                      iterator
                      upper_bound(const key_type& __x)
                      { return _M_t.upper_bound(__x); }
                
                      /**
                       *  @brief Finds the end of a subsequence matching given key.
                       *  @param  x  Key of (key, value) pair to be located.
                       *  @return  Read-only (constant) iterator pointing to first iterator
                       *           greater than key, or end().
                       */
                      const_iterator
                      upper_bound(const key_type& __x) const
                      { return _M_t.upper_bound(__x); }
                
                      /**
                       *  @brief Finds a subsequence matching given key.
                       *  @param  x  Key of (key, value) pairs to be located.
                       *  @return  Pair of iterators that possibly points to the subsequence
                       *           matching given key.
                       *
                       *  This function is equivalent to
                       *  @code
                       *    std::make_pair(c.lower_bound(val),
                       *                   c.upper_bound(val))
                       *  @endcode
                       *  (but is faster than making the calls separately).
                       *
                       *  This function probably only makes sense for multimaps.
                       */
                      std::pair<iterator, iterator>
                      equal_range(const key_type& __x)
                      { return _M_t.equal_range(__x); }
                
                      /**
                       *  @brief Finds a subsequence matching given key.
                       *  @param  x  Key of (key, value) pairs to be located.
                       *  @return  Pair of read-only (constant) iterators that possibly points
                       *           to the subsequence matching given key.
                       *
                       *  This function is equivalent to
                       *  @code
                       *    std::make_pair(c.lower_bound(val),
                       *                   c.upper_bound(val))
                       *  @endcode
                       *  (but is faster than making the calls separately).
                       *
                       *  This function probably only makes sense for multimaps.
                       */
                      std::pair<const_iterator, const_iterator>
                      equal_range(const key_type& __x) const
                      { return _M_t.equal_range(__x); }
                
                      template <typename _K1, typename _T1, typename _C1, typename _A1>
                        friend bool
                        operator== (const map<_K1, _T1, _C1, _A1>&,
                		    const map<_K1, _T1, _C1, _A1>&);
                
                      template <typename _K1, typename _T1, typename _C1, typename _A1>
                        friend bool
                        operator< (const map<_K1, _T1, _C1, _A1>&,
                		   const map<_K1, _T1, _C1, _A1>&);
                    };
                
                  /**
                   *  @brief  Map equality comparison.
                   *  @param  x  A %map.
                   *  @param  y  A %map of the same type as @a x.
                   *  @return  True iff the size and elements of the maps are equal.
                   *
                   *  This is an equivalence relation.  It is linear in the size of the
                   *  maps.  Maps are considered equivalent if their sizes are equal,
                   *  and if corresponding elements compare equal.
                  */
                  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
                    inline bool
                    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
                               const map<_Key, _Tp, _Compare, _Alloc>& __y)
                    { return __x._M_t == __y._M_t; }
                
                  /**
                   *  @brief  Map ordering relation.
                   *  @param  x  A %map.
                   *  @param  y  A %map of the same type as @a x.
                   *  @return  True iff @a x is lexicographically less than @a y.
                   *
                   *  This is a total ordering relation.  It is linear in the size of the
                   *  maps.  The elements must be comparable with @c <.
                   *
                   *  See std::lexicographical_compare() for how the determination is made.
                  */
                  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
                    inline bool
                    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
                              const map<_Key, _Tp, _Compare, _Alloc>& __y)
                    { return __x._M_t < __y._M_t; }
                
                  /// Based on operator==
                  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
                    inline bool
                    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
                               const map<_Key, _Tp, _Compare, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  /// Based on operator<
                  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
                    inline bool
                    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
                              const map<_Key, _Tp, _Compare, _Alloc>& __y)
                    { return __y < __x; }
                
                  /// Based on operator<
                  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
                    inline bool
                    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
                               const map<_Key, _Tp, _Compare, _Alloc>& __y)
                    { return !(__y < __x); }
                
                  /// Based on operator<
                  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
                    inline bool
                    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
                               const map<_Key, _Tp, _Compare, _Alloc>& __y)
                    { return !(__x < __y); }
                
                  /// See std::map::swap().
                  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
                    inline void
                    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
                	 map<_Key, _Tp, _Compare, _Alloc>& __y)
                    { __x.swap(__y); }
                } // namespace std
                
                #endif /* _MAP_H */


Top 10 Lines:

     Line      Count

      260        123
      340         93
      575         93
      509         91
      419         29
       93          1
      156          1
      243          1

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

      432   Total number of line executions
    54.00   Average executions per line


*** File /usr/lib/gcc/i486-linux-gnu/4.1.2/../../../../include/c++/4.1.2/bits/stl_algobase.h:
                // Bits and pieces used in algorithms -*- C++ -*-
                
                // Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 2, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // You should have received a copy of the GNU General Public License along
                // with this library; see the file COPYING.  If not, write to the Free
                // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
                // USA.
                
                // As a special exception, you may use this file as part of a free software
                // library without restriction.  Specifically, if other files instantiate
                // templates or use macros or inline functions from this file, or you compile
                // this file and link it with other files to produce an executable, this
                // file does not by itself cause the resulting executable to be covered by
                // the GNU General Public License.  This exception does not however
                // invalidate any other reasons why the executable file might be covered by
                // the GNU General Public License.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file stl_algobase.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _ALGOBASE_H
                #define _ALGOBASE_H 1
                
                #include <bits/c++config.h>
                #include <cstring>
                #include <climits>
                #include <cstdlib>
                #include <cstddef>
                #include <iosfwd>
                #include <bits/stl_pair.h>
                #include <bits/cpp_type_traits.h>
                #include <bits/stl_iterator_base_types.h>
                #include <bits/stl_iterator_base_funcs.h>
                #include <bits/stl_iterator.h>
                #include <bits/concept_check.h>
                #include <debug/debug.h>
                
                namespace std
                {
                
                  /**
                   *  @brief Swaps two values.
                   *  @param  a  A thing of arbitrary type.
                   *  @param  b  Another thing of arbitrary type.
                   *  @return   Nothing.
                   *
                   *  This is the simple classic generic implementation.  It will work on
                   *  any type which has a copy constructor and an assignment operator.
                  */
                  template<typename _Tp>
                    inline void
                    swap(_Tp& __a, _Tp& __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
                
                      _Tp __tmp = __a;
                      __a = __b;
                      __b = __tmp;
                    }
                
                  // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a
                  // nutshell, we are partially implementing the resolution of DR 187,
                  // when it's safe, i.e., the value_types are equal.
                  template<bool _BoolType>
                    struct __iter_swap
                    {
                      template<typename _ForwardIterator1, typename _ForwardIterator2>
                        static void
                        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                        {
                          typedef typename iterator_traits<_ForwardIterator1>::value_type
                            _ValueType1;
                          _ValueType1 __tmp = *__a;
                          *__a = *__b;
                          *__b = __tmp; 
                	}
                    };
                
                  template<>
                    struct __iter_swap<true>
                    {
                      template<typename _ForwardIterator1, typename _ForwardIterator2>
                        static void 
                        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                        {
                          swap(*__a, *__b);
                        }
                    };
                
                  /**
                   *  @brief Swaps the contents of two iterators.
                   *  @param  a  An iterator.
                   *  @param  b  Another iterator.
                   *  @return   Nothing.
                   *
                   *  This function swaps the values pointed to by two iterators, not the
                   *  iterators themselves.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    inline void
                    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                    {
                      typedef typename iterator_traits<_ForwardIterator1>::value_type
                	_ValueType1;
                      typedef typename iterator_traits<_ForwardIterator2>::value_type
                	_ValueType2;
                
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator1>)
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator2>)
                      __glibcxx_function_requires(_ConvertibleConcept<_ValueType1,
                				  _ValueType2>)
                      __glibcxx_function_requires(_ConvertibleConcept<_ValueType2,
                				  _ValueType1>)
                
                      typedef typename iterator_traits<_ForwardIterator1>::reference
                	_ReferenceType1;
                      typedef typename iterator_traits<_ForwardIterator2>::reference
                	_ReferenceType2;
                      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value &&
                	__are_same<_ValueType1 &, _ReferenceType1>::__value &&
                	__are_same<_ValueType2 &, _ReferenceType2>::__value>::
                	iter_swap(__a, __b);
                    }
                
                  #undef min
                  #undef max
                
                  /**
                   *  @brief This does what you think it does.
                   *  @param  a  A thing of arbitrary type.
                   *  @param  b  Another thing of arbitrary type.
                   *  @return   The lesser of the parameters.
                   *
                   *  This is the simple classic generic implementation.  It will work on
                   *  temporary expressions, since they are only evaluated once, unlike a
                   *  preprocessor macro.
                  */
                  template<typename _Tp>
                    inline const _Tp&
                    min(const _Tp& __a, const _Tp& __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                      //return __b < __a ? __b : __a;
                      if (__b < __a)
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @param  a  A thing of arbitrary type.
                   *  @param  b  Another thing of arbitrary type.
                   *  @return   The greater of the parameters.
                   *
                   *  This is the simple classic generic implementation.  It will work on
                   *  temporary expressions, since they are only evaluated once, unlike a
                   *  preprocessor macro.
                  */
                  template<typename _Tp>
                    inline const _Tp&
                    max(const _Tp& __a, const _Tp& __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                      //return  __a < __b ? __b : __a;
                      if (__a < __b)
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @param  a  A thing of arbitrary type.
                   *  @param  b  Another thing of arbitrary type.
                   *  @param  comp  A @link s20_3_3_comparisons comparison functor@endlink.
                   *  @return   The lesser of the parameters.
                   *
                   *  This will work on temporary expressions, since they are only evaluated
                   *  once, unlike a preprocessor macro.
                  */
                  template<typename _Tp, typename _Compare>
                    inline const _Tp&
                    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
                    {
                      //return __comp(__b, __a) ? __b : __a;
                      if (__comp(__b, __a))
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @param  a  A thing of arbitrary type.
                   *  @param  b  Another thing of arbitrary type.
                   *  @param  comp  A @link s20_3_3_comparisons comparison functor@endlink.
                   *  @return   The greater of the parameters.
                   *
                   *  This will work on temporary expressions, since they are only evaluated
                   *  once, unlike a preprocessor macro.
                  */
                  template<typename _Tp, typename _Compare>
                    inline const _Tp&
                    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
                    {
                      //return __comp(__a, __b) ? __b : __a;
                      if (__comp(__a, __b))
                	return __b;
                      return __a;
                    }
                
                  // All of these auxiliary structs serve two purposes.  (1) Replace
                  // calls to copy with memmove whenever possible.  (Memmove, not memcpy,
                  // because the input and output ranges are permitted to overlap.)
                  // (2) If we're using random access iterators, then write the loop as
                  // a for loop with an explicit count.
                
                  template<bool, typename>
                    struct __copy
                    {
                      template<typename _II, typename _OI>
                        static _OI
                        copy(_II __first, _II __last, _OI __result)
                        {
                	  for (; __first != __last; ++__result, ++__first)
                	    *__result = *__first;
                	  return __result;
                	}
                    };
                
                  template<bool _BoolType>
                    struct __copy<_BoolType, random_access_iterator_tag>
                    {
                      template<typename _II, typename _OI>
                        static _OI
                        copy(_II __first, _II __last, _OI __result)
                        { 
                	  typedef typename iterator_traits<_II>::difference_type _Distance;
                	  for(_Distance __n = __last - __first; __n > 0; --__n)
                	    {
                	      *__result = *__first;
                	      ++__first;
                	      ++__result;
                	    }
                	  return __result;
                	}
                    };
                
                  template<>
                    struct __copy<true, random_access_iterator_tag>
                    {
                      template<typename _Tp>
                        static _Tp*
       19582 ->         copy(const _Tp* __first, const _Tp* __last, _Tp* __result)
                        { 
                	  std::memmove(__result, __first, sizeof(_Tp) * (__last - __first));
                	  return __result + (__last - __first);
                	}
                    };
                
                  template<typename _II, typename _OI>
                    inline _OI
       19582 ->     __copy_aux(_II __first, _II __last, _OI __result)
                    {
                      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
                      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
                      typedef typename iterator_traits<_II>::iterator_category _Category;
                      const bool __simple = (__is_scalar<_ValueTypeI>::__value
                	                     && __is_pointer<_II>::__value
                	                     && __is_pointer<_OI>::__value
                			     && __are_same<_ValueTypeI, _ValueTypeO>::__value);
                
                      return std::__copy<__simple, _Category>::copy(__first, __last, __result);
                    }
                
                  template<bool, bool>
                    struct __copy_normal
                    {
                      template<typename _II, typename _OI>
                        static _OI
                        copy_n(_II __first, _II __last, _OI __result)
                        { return std::__copy_aux(__first, __last, __result); }
                    };
                
                  template<>
                    struct __copy_normal<true, false>
                    {
                      template<typename _II, typename _OI>
                        static _OI
                        copy_n(_II __first, _II __last, _OI __result)
                        { return std::__copy_aux(__first.base(), __last.base(), __result); }
                    };
                
                  template<>
                    struct __copy_normal<false, true>
                    {
                      template<typename _II, typename _OI>
                        static _OI
                        copy_n(_II __first, _II __last, _OI __result)
                        { return _OI(std::__copy_aux(__first, __last, __result.base())); }
                    };
                
                  template<>
                    struct __copy_normal<true, true>
                    {
                      template<typename _II, typename _OI>
                        static _OI
       19582 ->         copy_n(_II __first, _II __last, _OI __result)
                        { return _OI(std::__copy_aux(__first.base(), __last.base(),
                				     __result.base())); }
                    };
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @param  first  An input iterator.
                   *  @param  last   An input iterator.
                   *  @param  result An output iterator.
                   *  @return   result + (first - last)
                   *
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).  Result may not be contained within
                   *  [first,last); the copy_backward function should be used instead.
                   *
                   *  Note that the end of the output range is permitted to be contained
                   *  within [first,last).
                  */
                  template<typename _InputIterator, typename _OutputIterator>
                    inline _OutputIterator
                    copy(_InputIterator __first, _InputIterator __last,
       19582 -> 	 _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                       const bool __in = __is_normal_iterator<_InputIterator>::__value;
                       const bool __out = __is_normal_iterator<_OutputIterator>::__value;
                       return std::__copy_normal<__in, __out>::copy_n(__first, __last,
                						      __result);
                    }
                  
                  template<bool, typename>
                    struct __copy_backward
                    {
                      template<typename _BI1, typename _BI2>
                        static _BI2
                        copy_b(_BI1 __first, _BI1 __last, _BI2 __result)
                        { 
                	  while (__first != __last)
                	    *--__result = *--__last;
                	  return __result;
                	}
                    };
                
                  template<bool _BoolType>
                    struct __copy_backward<_BoolType, random_access_iterator_tag>
                    {
                      template<typename _BI1, typename _BI2>
                        static _BI2
       ##### ->         copy_b(_BI1 __first, _BI1 __last, _BI2 __result)
                        { 
                	  typename iterator_traits<_BI1>::difference_type __n;
                	  for (__n = __last - __first; __n > 0; --__n)
                	    *--__result = *--__last;
                	  return __result;
                	}
                    };
                
                  template<>
                    struct __copy_backward<true, random_access_iterator_tag>
                    {
                      template<typename _Tp>
                        static _Tp*
       ##### ->         copy_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
                        { 
                	  const ptrdiff_t _Num = __last - __first;
                	  std::memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
                	  return __result - _Num;
                	}
                    };
                
                  template<typename _BI1, typename _BI2>
                    inline _BI2
       ##### ->     __copy_backward_aux(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
                      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
                      typedef typename iterator_traits<_BI1>::iterator_category _Category;
                      const bool __simple = (__is_scalar<_ValueType1>::__value
                	                     && __is_pointer<_BI1>::__value
                	                     && __is_pointer<_BI2>::__value
                			     && __are_same<_ValueType1, _ValueType2>::__value);
                
                      return std::__copy_backward<__simple, _Category>::copy_b(__first, __last,
                							       __result);
                    }
                
                  template<bool, bool>
                    struct __copy_backward_normal
                    {
                      template<typename _BI1, typename _BI2>
                        static _BI2
                        copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
                        { return std::__copy_backward_aux(__first, __last, __result); }
                    };
                
                  template<>
                    struct __copy_backward_normal<true, false>
                    {
                      template<typename _BI1, typename _BI2>
                        static _BI2
                        copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
                        { return std::__copy_backward_aux(__first.base(), __last.base(),
                					  __result); }
                    };
                
                  template<>
                    struct __copy_backward_normal<false, true>
                    {
                      template<typename _BI1, typename _BI2>
                        static _BI2
                        copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
                        { return _BI2(std::__copy_backward_aux(__first, __last,
                					       __result.base())); }
                    };
                
                  template<>
                    struct __copy_backward_normal<true, true>
                    {
                      template<typename _BI1, typename _BI2>
                        static _BI2
       ##### ->         copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
                        { return _BI2(std::__copy_backward_aux(__first.base(), __last.base(),
                					       __result.base())); }
                    };
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @param  first  A bidirectional iterator.
                   *  @param  last   A bidirectional iterator.
                   *  @param  result A bidirectional iterator.
                   *  @return   result - (first - last)
                   *
                   *  The function has the same effect as copy, but starts at the end of the
                   *  range and works its way to the start, returning the start of the result.
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).
                   *
                   *  Result may not be in the range [first,last).  Use copy instead.  Note
                   *  that the start of the output range may overlap [first,last).
                  */
                  template <typename _BI1, typename _BI2>
                    inline _BI2
       ##### ->     copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
                      __glibcxx_function_requires(_ConvertibleConcept<
                	    typename iterator_traits<_BI1>::value_type,
                	    typename iterator_traits<_BI2>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      const bool __bi1 = __is_normal_iterator<_BI1>::__value;
                      const bool __bi2 = __is_normal_iterator<_BI2>::__value;
                      return std::__copy_backward_normal<__bi1, __bi2>::copy_b_n(__first, __last,
                								 __result);
                    }
                
                  template<bool>
                    struct __fill
                    {
                      template<typename _ForwardIterator, typename _Tp>
                        static void
                        fill(_ForwardIterator __first, _ForwardIterator __last,
                	     const _Tp& __value)
                        {
                	  for (; __first != __last; ++__first)
                	    *__first = __value;
                	}
                    };
                
                  template<>
                    struct __fill<true>
                    {
                      template<typename _ForwardIterator, typename _Tp>
                        static void
                        fill(_ForwardIterator __first, _ForwardIterator __last,
                	     const _Tp& __value)
                        {
                	  const _Tp __tmp = __value;
                	  for (; __first != __last; ++__first)
                	    *__first = __tmp;
                	}
                    };
                
                  /**
                   *  @brief Fills the range [first,last) with copies of value.
                   *  @param  first  A forward iterator.
                   *  @param  last   A forward iterator.
                   *  @param  value  A reference-to-const of arbitrary type.
                   *  @return   Nothing.
                   *
                   *  This function fills a range with copies of the same value.  For one-byte
                   *  types filling contiguous areas of memory, this becomes an inline call to
                   *  @c memset.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    void
                    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      const bool __scalar = __is_scalar<_Tp>::__value;
                      std::__fill<__scalar>::fill(__first, __last, __value);
                    }
                
                  // Specialization: for one-byte types we can use memset.
                  inline void
                  fill(unsigned char* __first, unsigned char* __last, const unsigned char& __c)
                  {
                    __glibcxx_requires_valid_range(__first, __last);
                    const unsigned char __tmp = __c;
                    std::memset(__first, __tmp, __last - __first);
                  }
                
                  inline void
                  fill(signed char* __first, signed char* __last, const signed char& __c)
                  {
                    __glibcxx_requires_valid_range(__first, __last);
                    const signed char __tmp = __c;
                    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
                  }
                
                  inline void
                  fill(char* __first, char* __last, const char& __c)
                  {
                    __glibcxx_requires_valid_range(__first, __last);
                    const char __tmp = __c;
                    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
                  }
                
                  template<bool>
                    struct __fill_n
                    {
                      template<typename _OutputIterator, typename _Size, typename _Tp>
                        static _OutputIterator
                        fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
                        {
                	  for (; __n > 0; --__n, ++__first)
                	    *__first = __value;
                	  return __first;
                	}
                    };
                
                  template<>
                    struct __fill_n<true>
                    {
                      template<typename _OutputIterator, typename _Size, typename _Tp>
                        static _OutputIterator
                        fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
                        {
                	  const _Tp __tmp = __value;
                	  for (; __n > 0; --__n, ++__first)
                	    *__first = __tmp;
                	  return __first;	  
                	}
                    };
                
                  /**
                   *  @brief Fills the range [first,first+n) with copies of value.
                   *  @param  first  An output iterator.
                   *  @param  n      The count of copies to perform.
                   *  @param  value  A reference-to-const of arbitrary type.
                   *  @return   The iterator at first+n.
                   *
                   *  This function fills a range with copies of the same value.  For one-byte
                   *  types filling contiguous areas of memory, this becomes an inline call to
                   *  @c memset.
                  */
                  template<typename _OutputIterator, typename _Size, typename _Tp>
                    _OutputIterator
                    fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator, _Tp>)
                
                      const bool __scalar = __is_scalar<_Tp>::__value;
                      return std::__fill_n<__scalar>::fill_n(__first, __n, __value);
                    }
                
                  template<typename _Size>
                    inline unsigned char*
                    fill_n(unsigned char* __first, _Size __n, const unsigned char& __c)
                    {
                      std::fill(__first, __first + __n, __c);
                      return __first + __n;
                    }
                
                  template<typename _Size>
                    inline signed char*
                    fill_n(char* __first, _Size __n, const signed char& __c)
                    {
                      std::fill(__first, __first + __n, __c);
                      return __first + __n;
                    }
                
                  template<typename _Size>
                    inline char*
                    fill_n(char* __first, _Size __n, const char& __c)
                    {
                      std::fill(__first, __first + __n, __c);
                      return __first + __n;
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @param  first1  An input iterator.
                   *  @param  last1   An input iterator.
                   *  @param  first2  An input iterator.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using @c == and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2>
                    pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      while (__first1 != __last1 && *__first1 == *__first2)
                        {
                	  ++__first1;
                	  ++__first2;
                        }
                      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @param  first1  An input iterator.
                   *  @param  last1   An input iterator.
                   *  @param  first2  An input iterator.
                   *  @param  binary_pred  A binary predicate @link s20_3_1_base functor@endlink.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      while (__first1 != __last1 && __binary_pred(*__first1, *__first2))
                        {
                	  ++__first1;
                	  ++__first2;
                        }
                      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
                    }
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @param  first1  An input iterator.
                   *  @param  last1   An input iterator.
                   *  @param  first2  An input iterator.
                   *  @return   A boolean true or false.
                   *
                   *  This compares the elements of two ranges using @c == and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2>
                    inline bool
                    equal(_InputIterator1 __first1, _InputIterator1 __last1,
                	  _InputIterator2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      
                      for (; __first1 != __last1; ++__first1, ++__first2)
                	if (!(*__first1 == *__first2))
                	  return false;
                      return true;
                    }
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @param  first1  An input iterator.
                   *  @param  last1   An input iterator.
                   *  @param  first2  An input iterator.
                   *  @param  binary_pred  A binary predicate @link s20_3_1_base functor@endlink.
                   *  @return   A boolean true or false.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    inline bool
                    equal(_InputIterator1 __first1, _InputIterator1 __last1,
                	  _InputIterator2 __first2,
                	  _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, ++__first2)
                	if (!__binary_pred(*__first1, *__first2))
                	  return false;
                      return true;
                    }
                
                  /**
                   *  @brief Performs "dictionary" comparison on ranges.
                   *  @param  first1  An input iterator.
                   *  @param  last1   An input iterator.
                   *  @param  first2  An input iterator.
                   *  @param  last2   An input iterator.
                   *  @return   A boolean true or false.
                   *
                   *  "Returns true if the sequence of elements defined by the range
                   *  [first1,last1) is lexicographically less than the sequence of elements
                   *  defined by the range [first2,last2).  Returns false otherwise."
                   *  (Quoted from [25.3.8]/1.)  If the iterators are all character pointers,
                   *  then this is an inline call to @c memcmp.
                  */
                  template<typename _InputIterator1, typename _InputIterator2>
                    bool
                    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                			    _InputIterator2 __first2, _InputIterator2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      for (; __first1 != __last1 && __first2 != __last2;
                	   ++__first1, ++__first2)
                	{
                	  if (*__first1 < *__first2)
                	    return true;
                	  if (*__first2 < *__first1)
                	    return false;
                	}
                      return __first1 == __last1 && __first2 != __last2;
                    }
                
                  /**
                   *  @brief Performs "dictionary" comparison on ranges.
                   *  @param  first1  An input iterator.
                   *  @param  last1   An input iterator.
                   *  @param  first2  An input iterator.
                   *  @param  last2   An input iterator.
                   *  @param  comp  A @link s20_3_3_comparisons comparison functor@endlink.
                   *  @return   A boolean true or false.
                   *
                   *  The same as the four-parameter @c lexigraphical_compare, but uses the
                   *  comp parameter instead of @c <.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _Compare>
                    bool
                    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                			    _InputIterator2 __first2, _InputIterator2 __last2,
                			    _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      for (; __first1 != __last1 && __first2 != __last2;
                	   ++__first1, ++__first2)
                	{
                	  if (__comp(*__first1, *__first2))
                	    return true;
                	  if (__comp(*__first2, *__first1))
                	    return false;
                	}
                      return __first1 == __last1 && __first2 != __last2;
                    }
                
                  inline bool
                  lexicographical_compare(const unsigned char* __first1,
                			  const unsigned char* __last1,
                			  const unsigned char* __first2,
                			  const unsigned char* __last2)
                  {
                    __glibcxx_requires_valid_range(__first1, __last1);
                    __glibcxx_requires_valid_range(__first2, __last2);
                
                    const size_t __len1 = __last1 - __first1;
                    const size_t __len2 = __last2 - __first2;
                    const int __result = std::memcmp(__first1, __first2,
                				     std::min(__len1, __len2));
                    return __result != 0 ? __result < 0 : __len1 < __len2;
                  }
                
                  inline bool
                  lexicographical_compare(const char* __first1, const char* __last1,
                			  const char* __first2, const char* __last2)
                  {
                    __glibcxx_requires_valid_range(__first1, __last1);
                    __glibcxx_requires_valid_range(__first2, __last2);
                
                #if CHAR_MAX == SCHAR_MAX
                    return std::lexicographical_compare((const signed char*) __first1,
                					(const signed char*) __last1,
                					(const signed char*) __first2,
                					(const signed char*) __last2);
                #else /* CHAR_MAX == SCHAR_MAX */
                    return std::lexicographical_compare((const unsigned char*) __first1,
                					(const unsigned char*) __last1,
                					(const unsigned char*) __first2,
                					(const unsigned char*) __last2);
                #endif /* CHAR_MAX == SCHAR_MAX */
                  }
                
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

      298      19582
      307      19582
      352      19582
      376      19582

Execution Summary:

        9   Executable lines in this file
        9   Lines executed
   100.00   Percent of the file executed

    78328   Total number of line executions
  8703.11   Average executions per line


*** File /usr/lib/gcc/i486-linux-gnu/4.1.2/../../../../include/c++/4.1.2/bits/stl_vector.h:
                // Vector implementation -*- C++ -*-
                
                // Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 2, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // You should have received a copy of the GNU General Public License along
                // with this library; see the file COPYING.  If not, write to the Free
                // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
                // USA.
                
                // As a special exception, you may use this file as part of a free software
                // library without restriction.  Specifically, if other files instantiate
                // templates or use macros or inline functions from this file, or you compile
                // this file and link it with other files to produce an executable, this
                // file does not by itself cause the resulting executable to be covered by
                // the GNU General Public License.  This exception does not however
                // invalidate any other reasons why the executable file might be covered by
                // the GNU General Public License.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this  software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file stl_vector.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _VECTOR_H
                #define _VECTOR_H 1
                
                #include <bits/stl_iterator_base_funcs.h>
                #include <bits/functexcept.h>
                #include <bits/concept_check.h>
                
                namespace _GLIBCXX_STD
                {
                  /**
                   *  @if maint
                   *  See bits/stl_deque.h's _Deque_base for an explanation.
                   *  @endif
                  */
                  template<typename _Tp, typename _Alloc>
                    struct _Vector_base
                    {
                      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;
                
                      struct _Vector_impl 
                      : public _Tp_alloc_type
        4005 ->       {
                	_Tp*           _M_start;
                	_Tp*           _M_finish;
                	_Tp*           _M_end_of_storage;
       37224 -> 	_Vector_impl(_Tp_alloc_type const& __a)
                	: _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
                	{ }
                      };
                      
                    public:
                      typedef _Alloc allocator_type;
                
                      _Tp_alloc_type&
      156294 ->       _M_get_Tp_allocator()
                      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
                
                      const _Tp_alloc_type&
                      _M_get_Tp_allocator() const
                      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
                
                      allocator_type
                      get_allocator() const
                      { return _M_get_Tp_allocator(); }
                
       37224 ->       _Vector_base(const allocator_type& __a)
                      : _M_impl(__a)
                      { }
                
                      _Vector_base(size_t __n, const allocator_type& __a)
                      : _M_impl(__a)
                      {
                	this->_M_impl._M_start = this->_M_allocate(__n);
                	this->_M_impl._M_finish = this->_M_impl._M_start;
                	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                      }
                
        4005 ->       ~_Vector_base()
                      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
                		      - this->_M_impl._M_start); }
                
                    public:
                      _Vector_impl _M_impl;
                
                      _Tp*
       26410 ->       _M_allocate(size_t __n)
                      { return _M_impl.allocate(__n); }
                
                      void
       30415 ->       _M_deallocate(_Tp* __p, size_t __n)
                      {
                	if (__p)
                	  _M_impl.deallocate(__p, __n);
                      }
                    };
                
                
                  /**
                   *  @brief A standard container which offers fixed time access to
                   *  individual elements in any order.
                   *
                   *  @ingroup Containers
                   *  @ingroup Sequences
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>, including the
                   *  <a href="tables.html#68">optional sequence requirements</a> with the
                   *  %exception of @c push_front and @c pop_front.
                   *
                   *  In some terminology a %vector can be described as a dynamic
                   *  C-style array, it offers fast and efficient access to individual
                   *  elements in any order and saves the user from worrying about
                   *  memory and size allocation.  Subscripting ( @c [] ) access is
                   *  also provided as with C-style arrays.
                  */
                  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
                    class vector : protected _Vector_base<_Tp, _Alloc>
                    {
                      // Concept requirements.
                      typedef typename _Alloc::value_type                _Alloc_value_type;
                      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
                      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
                      
                      typedef _Vector_base<_Tp, _Alloc>			 _Base;
                      typedef vector<_Tp, _Alloc>			 vector_type;
                      typedef typename _Base::_Tp_alloc_type		 _Tp_alloc_type;
                
                    public:
                      typedef _Tp					 value_type;
                      typedef typename _Tp_alloc_type::pointer           pointer;
                      typedef typename _Tp_alloc_type::const_pointer     const_pointer;
                      typedef typename _Tp_alloc_type::reference         reference;
                      typedef typename _Tp_alloc_type::const_reference   const_reference;
                      typedef __gnu_cxx::__normal_iterator<pointer, vector_type> iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, vector_type>
                      const_iterator;
                      typedef std::reverse_iterator<const_iterator>  const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		 reverse_iterator;
                      typedef size_t					 size_type;
                      typedef ptrdiff_t					 difference_type;
                      typedef _Alloc                        		 allocator_type;
                
                    protected:
                      /** @if maint
                       *  These two functions and three data members are all from the
                       *  base class.  They should be pretty self-explanatory, as
                       *  %vector uses a simple contiguous allocation scheme.  @endif
                       */
                      using _Base::_M_allocate;
                      using _Base::_M_deallocate;
                      using _Base::_M_impl;
                      using _Base::_M_get_Tp_allocator;
                
                    public:
                      // [23.2.4.1] construct/copy/destroy
                      // (assign() and get_allocator() are also listed in this section)
                      /**
                       *  @brief  Default constructor creates no elements.
                       */
                      explicit
       37224 ->       vector(const allocator_type& __a = allocator_type())
                      : _Base(__a)
                      { }
                
                      /**
                       *  @brief  Create a %vector with copies of an exemplar element.
                       *  @param  n  The number of elements to initially create.
                       *  @param  value  An element to copy.
                       *
                       *  This constructor fills the %vector with @a n copies of @a value.
                       */
                      explicit
                      vector(size_type __n, const value_type& __value = value_type(),
                	     const allocator_type& __a = allocator_type())
                      : _Base(__n, __a)
                      {
                	std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
                				      _M_get_Tp_allocator());
                	this->_M_impl._M_finish = this->_M_impl._M_start + __n;
                      }
                
                      /**
                       *  @brief  %Vector copy constructor.
                       *  @param  x  A %vector of identical element and allocator types.
                       *
                       *  The newly-created %vector uses a copy of the allocation
                       *  object used by @a x.  All the elements of @a x are copied,
                       *  but any extra memory in
                       *  @a x (for fast expansion) will not be copied.
                       */
                      vector(const vector& __x)
                      : _Base(__x.size(), __x.get_allocator())
                      { this->_M_impl._M_finish =
                	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                				      this->_M_impl._M_start,
                				      _M_get_Tp_allocator());
                      }
                
                      /**
                       *  @brief  Builds a %vector from a range.
                       *  @param  first  An input iterator.
                       *  @param  last  An input iterator.
                       *
                       *  Create a %vector consisting of copies of the elements from
                       *  [first,last).
                       *
                       *  If the iterators are forward, bidirectional, or
                       *  random-access, then this will call the elements' copy
                       *  constructor N times (where N is distance(first,last)) and do
                       *  no memory reallocation.  But if only input iterators are
                       *  used, then this will do at most 2N calls to the copy
                       *  constructor, and logN memory reallocations.
                       */
                      template<typename _InputIterator>
                        vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_initialize_dispatch(__first, __last, _Integral());
                	}
                
                      /**
                       *  The dtor only erases the elements, and note that if the
                       *  elements themselves are pointers, the pointed-to memory is
                       *  not touched in any way.  Managing the pointer is the user's
                       *  responsibilty.
                       */
        4005 ->       ~vector()
                      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                		      _M_get_Tp_allocator());
                      }
                
                      /**
                       *  @brief  %Vector assignment operator.
                       *  @param  x  A %vector of identical element and allocator types.
                       *
                       *  All the elements of @a x are copied, but any extra memory in
                       *  @a x (for fast expansion) will not be copied.  Unlike the
                       *  copy constructor, the allocator object is not copied.
                       */
                      vector&
                      operator=(const vector& __x);
                
                      /**
                       *  @brief  Assigns a given value to a %vector.
                       *  @param  n  Number of elements to be assigned.
                       *  @param  val  Value to be assigned.
                       *
                       *  This function fills a %vector with @a n copies of the given
                       *  value.  Note that the assignment completely changes the
                       *  %vector and that the resulting %vector's size is the same as
                       *  the number of elements assigned.  Old data may be lost.
                       */
                      void
                      assign(size_type __n, const value_type& __val)
                      { _M_fill_assign(__n, __val); }
                
                      /**
                       *  @brief  Assigns a range to a %vector.
                       *  @param  first  An input iterator.
                       *  @param  last   An input iterator.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  range [first,last).
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.  Old data may be lost.
                       */
                      template<typename _InputIterator>
                        void
                        assign(_InputIterator __first, _InputIterator __last)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_assign_dispatch(__first, __last, _Integral());
                	}
                
                      /// Get a copy of the memory allocation object.
                      using _Base::get_allocator;
                
                      // iterators
                      /**
                       *  Returns a read/write iterator that points to the first
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
    13434649 ->       begin()
                      { return iterator (this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
    13636336 ->       begin() const
                      { return const_iterator (this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
       52820 ->       end()
                      { return iterator (this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %vector.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
    13636336 ->       end() const
                      { return const_iterator (this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the
                       *  last element in the %vector.  Iteration is done in reverse
                       *  element order.
                       */
                      reverse_iterator
                      rbegin()
                      { return reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %vector.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one
                       *  before the first element in the %vector.  Iteration is done
                       *  in reverse element order.
                       */
                      reverse_iterator
                      rend()
                      { return reverse_iterator(begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %vector.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const
                      { return const_reverse_iterator(begin()); }
                
                      // [23.2.4.2] capacity
                      /**  Returns the number of elements in the %vector.  */
                      size_type
    13636336 ->       size() const
                      { return size_type(end() - begin()); }
                
                      /**  Returns the size() of the largest possible %vector.  */
                      size_type
       26410 ->       max_size() const
                      { return size_type(-1) / sizeof(value_type); }
                
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  new_size  Number of elements the %vector should contain.
                       *  @param  x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  the %vector is extended and new elements are populated with
                       *  given data.
                       */
                      void
                      resize(size_type __new_size, value_type __x = value_type())
                      {
                	if (__new_size < size())
                	  erase(begin() + __new_size, end());
                	else
                	  insert(end(), __new_size - size(), __x);
                      }
                
                      /**
                       *  Returns the total number of elements that the %vector can
                       *  hold before needing to allocate more memory.
                       */
                      size_type
                      capacity() const
                      { return size_type(const_iterator(this->_M_impl._M_end_of_storage)
                			 - begin()); }
                
                      /**
                       *  Returns true if the %vector is empty.  (Thus begin() would
                       *  equal end().)
                       */
                      bool
                      empty() const
                      { return begin() == end(); }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          elements.
                       *  @param  n  Number of elements required.
                       *  @throw  std::length_error  If @a n exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %vector to hold the specified number of elements.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the number of elements
                       *  that will be required, the user can reserve the memory in
                       *  %advance, and thus prevent a possible reallocation of memory
                       *  and copying of %vector data.
                       */
                      void
                      reserve(size_type __n);
                
                      // element access
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      reference
    13408239 ->       operator[](size_type __n)
                      { return *(begin() + __n); }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
                      operator[](size_type __n) const
                      { return *(begin() + __n); }
                
                    protected:
                      /// @if maint Safety check used only from at().  @endif
                      void
                      _M_range_check(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range(__N("vector::_M_range_check"));
                      }
                
                    public:
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      reference
                      at(size_type __n)
                      {
                	_M_range_check(__n);
                	return (*this)[__n]; 
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	_M_range_check(__n);
                	return (*this)[__n];
                      }
                
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %vector.
                       */
                      reference
                      front()
                      { return *begin(); }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %vector.
                       */
                      const_reference
                      front() const
                      { return *begin(); }
                
                      /**
                       *  Returns a read/write reference to the data at the last
                       *  element of the %vector.
                       */
                      reference
                      back()
                      { return *(end() - 1); }
                      
                      /**
                       *  Returns a read-only (constant) reference to the data at the
                       *  last element of the %vector.
                       */
                      const_reference
                      back() const
                      { return *(end() - 1); }
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 464. Suggestion for new member functions in standard containers.
                      // data access
                      /**
                       *   Returns a pointer such that [data(), data() + size()) is a valid
                       *   range.  For a non-empty %vector, data() == &front().
                       */
                      pointer
                      data()
                      { return pointer(this->_M_impl._M_start); }
                
                      const_pointer
                      data() const
                      { return const_pointer(this->_M_impl._M_start); }
                
                      // [23.2.4.3] modifiers
                      /**
                       *  @brief  Add data to the end of the %vector.
                       *  @param  x  Data to be added.
                       *
                       *  This is a typical stack operation.  The function creates an
                       *  element at the end of the %vector and assigns the given data
                       *  to it.  Due to the nature of a %vector this operation can be
                       *  done in constant time if the %vector has preallocated space
                       *  available.
                       */
                      void
    12095884 ->       push_back(const value_type& __x)
                      {
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  {
                	    this->_M_impl.construct(this->_M_impl._M_finish, __x);
                	    ++this->_M_impl._M_finish;
                	  }
                	else
                	  _M_insert_aux(end(), __x);
                      }
                
                      /**
                       *  @brief  Removes last element.
                       *
                       *  This is a typical stack operation. It shrinks the %vector by one.
                       *
                       *  Note that no data is returned, and if the last element's
                       *  data is needed, it should be retrieved before pop_back() is
                       *  called.
                       */
                      void
        1954 ->       pop_back()
                      {
                	--this->_M_impl._M_finish;
                	this->_M_impl.destroy(this->_M_impl._M_finish);
                      }
                
                      /**
                       *  @brief  Inserts given value into %vector before specified iterator.
                       *  @param  position  An iterator into the %vector.
                       *  @param  x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given value before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(iterator __position, const value_type& __x);
                
                      /**
                       *  @brief  Inserts a number of copies of given data into the %vector.
                       *  @param  position  An iterator into the %vector.
                       *  @param  n  Number of elements to be inserted.
                       *  @param  x  Data to be inserted.
                       *
                       *  This function will insert a specified number of copies of
                       *  the given data before the location specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      void
                      insert(iterator __position, size_type __n, const value_type& __x)
                      { _M_fill_insert(__position, __n, __x); }
                
                      /**
                       *  @brief  Inserts a range into the %vector.
                       *  @param  position  An iterator into the %vector.
                       *  @param  first  An input iterator.
                       *  @param  last   An input iterator.
                       *
                       *  This function will insert copies of the data in the range
                       *  [first,last) into the %vector before the location specified
                       *  by @a pos.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      template<typename _InputIterator>
                        void
                        insert(iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_insert_dispatch(__position, __first, __last, _Integral());
                	}
                
                      /**
                       *  @brief  Remove element at given position.
                       *  @param  position  Iterator pointing to element to be erased.
                       *  @return  An iterator pointing to the next element (or end()).
                       *
                       *  This function will erase the element at the given position and thus
                       *  shorten the %vector by one.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the element, and that if the element is itself a pointer,
                       *  the pointed-to memory is not touched in any way.  Managing
                       *  the pointer is the user's responsibilty.
                       */
                      iterator
                      erase(iterator __position);
                
                      /**
                       *  @brief  Remove a range of elements.
                       *  @param  first  Iterator pointing to the first element to be erased.
                       *  @param  last  Iterator pointing to one past the last element to be
                       *                erased.
                       *  @return  An iterator pointing to the element pointed to by @a last
                       *           prior to erasing (or end()).
                       *
                       *  This function will erase the elements in the range [first,last) and
                       *  shorten the %vector accordingly.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the elements, and that if the elements themselves are
                       *  pointers, the pointed-to memory is not touched in any way.
                       *  Managing the pointer is the user's responsibilty.
                       */
                      iterator
                      erase(iterator __first, iterator __last);
                
                      /**
                       *  @brief  Swaps data with another %vector.
                       *  @param  x  A %vector of the same element and allocator types.
                       *
                       *  This exchanges the elements between two vectors in constant time.
                       *  (Three pointers, so it should be quite fast.)
                       *  Note that the global std::swap() function is specialized such that
                       *  std::swap(v1,v2) will feed to this function.
                       */
                      void
                      swap(vector& __x)
                      {
                	std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
                	std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
                	std::swap(this->_M_impl._M_end_of_storage,
                		  __x._M_impl._M_end_of_storage);
                      }
                
                      /**
                       *  Erases all the elements.  Note that this function only erases the
                       *  elements, and that if the elements themselves are pointers, the
                       *  pointed-to memory is not touched in any way.  Managing the pointer is
                       *  the user's responsibilty.
                       */
                      void
       73059 ->       clear()
                      {
                	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                		      _M_get_Tp_allocator());
                	this->_M_impl._M_finish = this->_M_impl._M_start;
                      }
                
                    protected:
                      /**
                       *  @if maint
                       *  Memory expansion handler.  Uses the member allocation function to
                       *  obtain @a n bytes of memory, and then copies [first,last) into it.
                       *  @endif
                       */
                      template<typename _ForwardIterator>
                        pointer
                        _M_allocate_and_copy(size_type __n,
                			     _ForwardIterator __first, _ForwardIterator __last)
                        {
                	  pointer __result = this->_M_allocate(__n);
                	  try
                	    {
                	      std::__uninitialized_copy_a(__first, __last, __result,
                					  _M_get_Tp_allocator());
                	      return __result;
                	    }
                	  catch(...)
                	    {
                	      _M_deallocate(__result, __n);
                	      __throw_exception_again;
                	    }
                	}
                
                
                      // Internal constructor functions follow.
                
                      // Called by the range constructor to implement [23.1.1]/9
                      template<typename _Integer>
                        void
                        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
                        {
                	  this->_M_impl._M_start = _M_allocate(__n);
                	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
                					_M_get_Tp_allocator());
                	  this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
                	}
                
                      // Called by the range constructor to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                			       __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_range_initialize(__first, __last, _IterCategory());
                	}
                
                      // Called by the second initialize_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_range_initialize(_InputIterator __first,
                			    _InputIterator __last, std::input_iterator_tag)
                        {
                	  for (; __first != __last; ++__first)
                	    push_back(*__first);
                	}
                
                      // Called by the second initialize_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_range_initialize(_ForwardIterator __first,
                			    _ForwardIterator __last, std::forward_iterator_tag)
                        {
                	  const size_type __n = std::distance(__first, __last);
                	  this->_M_impl._M_start = this->_M_allocate(__n);
                	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                	  this->_M_impl._M_finish =
                	    std::__uninitialized_copy_a(__first, __last,
                					this->_M_impl._M_start,
                					_M_get_Tp_allocator());
                	}
                
                
                      // Internal assign functions follow.  The *_aux functions do the actual
                      // assignment work for the range versions.
                
                      // Called by the range assign to implement [23.1.1]/9
                      template<typename _Integer>
                        void
                        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
                        {
                	  _M_fill_assign(static_cast<size_type>(__n),
                			 static_cast<value_type>(__val));
                	}
                
                      // Called by the range assign to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
                			   __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_assign_aux(__first, __last, _IterCategory());
                	}
                
                      // Called by the second assign_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_assign_aux(_InputIterator __first, _InputIterator __last,
                		      std::input_iterator_tag);
                
                      // Called by the second assign_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		      std::forward_iterator_tag);
                
                      // Called by assign(n,t), and the range assign when it turns out
                      // to be the same thing.
                      void
                      _M_fill_assign(size_type __n, const value_type& __val);
                
                
                      // Internal insert functions follow.
                
                      // Called by the range insert to implement [23.1.1]/9
                      template<typename _Integer>
                        void
                        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
                			   __true_type)
                        {
                	  _M_fill_insert(__pos, static_cast<size_type>(__n),
                			 static_cast<value_type>(__val));
                	}
                
                      // Called by the range insert to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_insert_dispatch(iterator __pos, _InputIterator __first,
                			   _InputIterator __last, __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_range_insert(__pos, __first, __last, _IterCategory());
                	}
                
                      // Called by the second insert_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_range_insert(iterator __pos, _InputIterator __first,
                			_InputIterator __last, std::input_iterator_tag);
                
                      // Called by the second insert_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_range_insert(iterator __pos, _ForwardIterator __first,
                			_ForwardIterator __last, std::forward_iterator_tag);
                
                      // Called by insert(p,n,x), and the range insert when it turns out to be
                      // the same thing.
                      void
                      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
                
                      // Called by insert(p,x)
                      void
                      _M_insert_aux(iterator __position, const value_type& __x);
                    };
                
                
                  /**
                   *  @brief  Vector equality comparison.
                   *  @param  x  A %vector.
                   *  @param  y  A %vector of the same type as @a x.
                   *  @return  True iff the size and elements of the vectors are equal.
                   *
                   *  This is an equivalence relation.  It is linear in the size of the
                   *  vectors.  Vectors are considered equivalent if their sizes are equal,
                   *  and if corresponding elements compare equal.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return (__x.size() == __y.size()
                	      && std::equal(__x.begin(), __x.end(), __y.begin())); }
                
                  /**
                   *  @brief  Vector ordering relation.
                   *  @param  x  A %vector.
                   *  @param  y  A %vector of the same type as @a x.
                   *  @return  True iff @a x is lexicographically less than @a y.
                   *
                   *  This is a total ordering relation.  It is linear in the size of the
                   *  vectors.  The elements must be comparable with @c <.
                   *
                   *  See std::lexicographical_compare() for how the determination is made.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return std::lexicographical_compare(__x.begin(), __x.end(),
                					  __y.begin(), __y.end()); }
                
                  /// Based on operator==
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return __y < __x; }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__y < __x); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x < __y); }
                
                  /// See std::vector::swap().
                  template<typename _Tp, typename _Alloc>
                    inline void
                    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
                    { __x.swap(__y); }
                } // namespace std
                
                #endif /* _VECTOR_H */


Top 10 Lines:

     Line      Count

      341   13636336
      359   13636336
      401   13636336
      332   13434649
      479   13408239
      602   12095884
       95     156294
      748      73059
      350      52820
       86      37224

Execution Summary:

       19   Executable lines in this file
       19   Lines executed
   100.00   Percent of the file executed

 80338829   Total number of line executions
4228359.42   Average executions per line


*** File /usr/lib/gcc/i486-linux-gnu/4.1.2/../../../../include/c++/4.1.2/bits/stl_tree.h:
                // RB tree implementation -*- C++ -*-
                
                // Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 2, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // You should have received a copy of the GNU General Public License along
                // with this library; see the file COPYING.  If not, write to the Free
                // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
                // USA.
                
                // As a special exception, you may use this file as part of a free software
                // library without restriction.  Specifically, if other files instantiate
                // templates or use macros or inline functions from this file, or you compile
                // this file and link it with other files to produce an executable, this
                // file does not by itself cause the resulting executable to be covered by
                // the GNU General Public License.  This exception does not however
                // invalidate any other reasons why the executable file might be covered by
                // the GNU General Public License.
                
                /*
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 */
                
                /** @file stl_tree.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _TREE_H
                #define _TREE_H 1
                
                #include <bits/stl_algobase.h>
                #include <bits/allocator.h>
                #include <bits/stl_construct.h>
                #include <bits/stl_function.h>
                #include <bits/cpp_type_traits.h>
                
                namespace std
                {
                  // Red-black tree class, designed for use in implementing STL
                  // associative containers (set, multiset, map, and multimap). The
                  // insertion and deletion algorithms are based on those in Cormen,
                  // Leiserson, and Rivest, Introduction to Algorithms (MIT Press,
                  // 1990), except that
                  //
                  // (1) the header cell is maintained with links not only to the root
                  // but also to the leftmost node of the tree, to enable constant
                  // time begin(), and to the rightmost node of the tree, to enable
                  // linear time performance when used with the generic set algorithms
                  // (set_union, etc.)
                  // 
                  // (2) when a node being deleted has two children its successor node
                  // is relinked into its place, rather than copied, so that the only
                  // iterators invalidated are those referring to the deleted node.
                
                  enum _Rb_tree_color { _S_red = false, _S_black = true };
                
                  struct _Rb_tree_node_base
                  {
                    typedef _Rb_tree_node_base* _Base_ptr;
                    typedef const _Rb_tree_node_base* _Const_Base_ptr;
                
                    _Rb_tree_color	_M_color;
                    _Base_ptr		_M_parent;
                    _Base_ptr		_M_left;
                    _Base_ptr		_M_right;
                
                    static _Base_ptr
                    _S_minimum(_Base_ptr __x)
                    {
                      while (__x->_M_left != 0) __x = __x->_M_left;
                      return __x;
                    }
                
                    static _Const_Base_ptr
                    _S_minimum(_Const_Base_ptr __x)
                    {
                      while (__x->_M_left != 0) __x = __x->_M_left;
                      return __x;
                    }
                
                    static _Base_ptr
                    _S_maximum(_Base_ptr __x)
                    {
                      while (__x->_M_right != 0) __x = __x->_M_right;
                      return __x;
                    }
                
                    static _Const_Base_ptr
                    _S_maximum(_Const_Base_ptr __x)
                    {
                      while (__x->_M_right != 0) __x = __x->_M_right;
                      return __x;
                    }
                  };
                
                  template<typename _Val>
                    struct _Rb_tree_node : public _Rb_tree_node_base
                    {
                      typedef _Rb_tree_node<_Val>* _Link_type;
                      _Val _M_value_field;
                    };
                
                  _Rb_tree_node_base*
                  _Rb_tree_increment(_Rb_tree_node_base* __x);
                
                  const _Rb_tree_node_base*
                  _Rb_tree_increment(const _Rb_tree_node_base* __x);
                
                  _Rb_tree_node_base*
                  _Rb_tree_decrement(_Rb_tree_node_base* __x);
                
                  const _Rb_tree_node_base*
                  _Rb_tree_decrement(const _Rb_tree_node_base* __x);
                
                  template<typename _Tp>
                    struct _Rb_tree_iterator
                    {
                      typedef _Tp  value_type;
                      typedef _Tp& reference;
                      typedef _Tp* pointer;
                
                      typedef bidirectional_iterator_tag iterator_category;
                      typedef ptrdiff_t                  difference_type;
                
                      typedef _Rb_tree_iterator<_Tp>        _Self;
                      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
                      typedef _Rb_tree_node<_Tp>*           _Link_type;
                
           1 ->       _Rb_tree_iterator()
                      : _M_node() { }
                
                      explicit
         248 ->       _Rb_tree_iterator(_Link_type __x)
                      : _M_node(__x) { }
                
                      reference
         184 ->       operator*() const
                      { return static_cast<_Link_type>(_M_node)->_M_value_field; }
                
                      pointer
          58 ->       operator->() const
                      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }
                
                      _Self&
          29 ->       operator++()
                      {
                	_M_node = _Rb_tree_increment(_M_node);
                	return *this;
                      }
                
                      _Self
                      operator++(int)
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_increment(_M_node);
                	return __tmp;
                      }
                
                      _Self&
          23 ->       operator--()
                      {
                	_M_node = _Rb_tree_decrement(_M_node);
                	return *this;
                      }
                
                      _Self
                      operator--(int)
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_decrement(_M_node);
                	return __tmp;
                      }
                
                      bool
          94 ->       operator==(const _Self& __x) const
                      { return _M_node == __x._M_node; }
                
                      bool
          30 ->       operator!=(const _Self& __x) const
                      { return _M_node != __x._M_node; }
                
                      _Base_ptr _M_node;
                  };
                
                  template<typename _Tp>
                    struct _Rb_tree_const_iterator
                    {
                      typedef _Tp        value_type;
                      typedef const _Tp& reference;
                      typedef const _Tp* pointer;
                
                      typedef _Rb_tree_iterator<_Tp> iterator;
                
                      typedef bidirectional_iterator_tag iterator_category;
                      typedef ptrdiff_t                  difference_type;
                
                      typedef _Rb_tree_const_iterator<_Tp>        _Self;
                      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
                      typedef const _Rb_tree_node<_Tp>*           _Link_type;
                
                      _Rb_tree_const_iterator()
                      : _M_node() { }
                
                      explicit
                      _Rb_tree_const_iterator(_Link_type __x)
                      : _M_node(__x) { }
                
                      _Rb_tree_const_iterator(const iterator& __it)
                      : _M_node(__it._M_node) { }
                
                      reference
                      operator*() const
                      { return static_cast<_Link_type>(_M_node)->_M_value_field; }
                
                      pointer
                      operator->() const
                      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }
                
                      _Self&
                      operator++()
                      {
                	_M_node = _Rb_tree_increment(_M_node);
                	return *this;
                      }
                
                      _Self
                      operator++(int)
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_increment(_M_node);
                	return __tmp;
                      }
                
                      _Self&
                      operator--()
                      {
                	_M_node = _Rb_tree_decrement(_M_node);
                	return *this;
                      }
                
                      _Self
                      operator--(int)
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_decrement(_M_node);
                	return __tmp;
                      }
                
                      bool
                      operator==(const _Self& __x) const
                      { return _M_node == __x._M_node; }
                
                      bool
                      operator!=(const _Self& __x) const
                      { return _M_node != __x._M_node; }
                
                      _Base_ptr _M_node;
                    };
                
                  template<typename _Val>
                    inline bool
                    operator==(const _Rb_tree_iterator<_Val>& __x,
                               const _Rb_tree_const_iterator<_Val>& __y)
                    { return __x._M_node == __y._M_node; }
                
                  template<typename _Val>
                    inline bool
                    operator!=(const _Rb_tree_iterator<_Val>& __x,
                               const _Rb_tree_const_iterator<_Val>& __y)
                    { return __x._M_node != __y._M_node; }
                
                  void
                  _Rb_tree_rotate_left(_Rb_tree_node_base* const __x,
                                       _Rb_tree_node_base*& __root);
                
                  void
                  _Rb_tree_rotate_right(_Rb_tree_node_base* const __x,
                                        _Rb_tree_node_base*& __root);
                
                  void
                  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                                _Rb_tree_node_base* __x,
                                                _Rb_tree_node_base* __p,
                                                _Rb_tree_node_base& __header);
                
                  _Rb_tree_node_base*
                  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
                			       _Rb_tree_node_base& __header);
                
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc = allocator<_Val> >
                    class _Rb_tree
                    {
                      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other
                              _Node_allocator;
                
                    protected:
                      typedef _Rb_tree_node_base* _Base_ptr;
                      typedef const _Rb_tree_node_base* _Const_Base_ptr;
                      typedef _Rb_tree_node<_Val> _Rb_tree_node;
                
                    public:
                      typedef _Key key_type;
                      typedef _Val value_type;
                      typedef value_type* pointer;
                      typedef const value_type* const_pointer;
                      typedef value_type& reference;
                      typedef const value_type& const_reference;
                      typedef _Rb_tree_node* _Link_type;
                      typedef const _Rb_tree_node* _Const_Link_type;
                      typedef size_t size_type;
                      typedef ptrdiff_t difference_type;
                      typedef _Alloc allocator_type;
                
                      allocator_type 
          58 ->       get_allocator() const
                      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }
                
                    protected:
                      _Rb_tree_node*
          29 ->       _M_get_node()
                      { return _M_impl._Node_allocator::allocate(1); }
                
                      void
          29 ->       _M_put_node(_Rb_tree_node* __p)
                      { _M_impl._Node_allocator::deallocate(__p, 1); }
                
                      _Link_type
          29 ->       _M_create_node(const value_type& __x)
                      {
                	_Link_type __tmp = _M_get_node();
                	try
                	  { get_allocator().construct(&__tmp->_M_value_field, __x); }
                	catch(...)
                	  {
                	    _M_put_node(__tmp);
                	    __throw_exception_again;
                	  }
                	return __tmp;
                      }
                
                      _Link_type
                      _M_clone_node(_Const_Link_type __x)
                      {
                	_Link_type __tmp = _M_create_node(__x->_M_value_field);
                	__tmp->_M_color = __x->_M_color;
                	__tmp->_M_left = 0;
                	__tmp->_M_right = 0;
                	return __tmp;
                      }
                
                      void
          29 ->       destroy_node(_Link_type __p)
                      {
                	get_allocator().destroy(&__p->_M_value_field);
                	_M_put_node(__p);
                      }
                
                    protected:
                      template<typename _Key_compare, 
                	       bool _Is_pod_comparator = std::__is_pod<_Key_compare>::__value>
                        struct _Rb_tree_impl : public _Node_allocator
           1 ->         {
                	  _Key_compare		_M_key_compare;
                	  _Rb_tree_node_base 	_M_header;
                	  size_type 		_M_node_count; // Keeps track of size of tree.
                
                	  _Rb_tree_impl(const _Node_allocator& __a = _Node_allocator(),
           1 -> 			const _Key_compare& __comp = _Key_compare())
                	  : _Node_allocator(__a), _M_key_compare(__comp), _M_header(), 
                	    _M_node_count(0)
                	  {
                	    this->_M_header._M_color = _S_red;
                	    this->_M_header._M_parent = 0;
                	    this->_M_header._M_left = &this->_M_header;
                	    this->_M_header._M_right = &this->_M_header;
                	  }
                	};
                
                      // Specialization for _Comparison types that are not capable of
                      // being base classes / super classes.
                      template<typename _Key_compare>
                        struct _Rb_tree_impl<_Key_compare, true> : public _Node_allocator 
                	{
                	  _Key_compare 		_M_key_compare;
                	  _Rb_tree_node_base 	_M_header;
                	  size_type 		_M_node_count; // Keeps track of size of tree.
                
                	  _Rb_tree_impl(const _Node_allocator& __a = _Node_allocator(),
                			const _Key_compare& __comp = _Key_compare())
                	  : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
                	    _M_node_count(0)
                	  { 
                	    this->_M_header._M_color = _S_red;
                	    this->_M_header._M_parent = 0;
                	    this->_M_header._M_left = &this->_M_header;
                	    this->_M_header._M_right = &this->_M_header;
                	  }
                	};
                
                      _Rb_tree_impl<_Compare> _M_impl;
                
                    protected:
                      _Base_ptr&
                      _M_root()
                      { return this->_M_impl._M_header._M_parent; }
                
                      _Const_Base_ptr
                      _M_root() const
                      { return this->_M_impl._M_header._M_parent; }
                
                      _Base_ptr&
          35 ->       _M_leftmost()
                      { return this->_M_impl._M_header._M_left; }
                
                      _Const_Base_ptr
                      _M_leftmost() const
                      { return this->_M_impl._M_header._M_left; }
                
                      _Base_ptr&
           2 ->       _M_rightmost()
                      { return this->_M_impl._M_header._M_right; }
                
                      _Const_Base_ptr
                      _M_rightmost() const
                      { return this->_M_impl._M_header._M_right; }
                
                      _Link_type
          95 ->       _M_begin()
                      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }
                
                      _Const_Link_type
                      _M_begin() const
                      {
                	return static_cast<_Const_Link_type>
                	  (this->_M_impl._M_header._M_parent);
                      }
                
                      _Link_type
         137 ->       _M_end()
                      { return static_cast<_Link_type>(&this->_M_impl._M_header); }
                
                      _Const_Link_type
                      _M_end() const
                      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }
                
                      static const_reference
         398 ->       _S_value(_Const_Link_type __x)
                      { return __x->_M_value_field; }
                
                      static const _Key&
         398 ->       _S_key(_Const_Link_type __x)
                      { return _KeyOfValue()(_S_value(__x)); }
                
                      static _Link_type
         279 ->       _S_left(_Base_ptr __x)
                      { return static_cast<_Link_type>(__x->_M_left); }
                
                      static _Const_Link_type
                      _S_left(_Const_Base_ptr __x)
                      { return static_cast<_Const_Link_type>(__x->_M_left); }
                
                      static _Link_type
         200 ->       _S_right(_Base_ptr __x)
                      { return static_cast<_Link_type>(__x->_M_right); }
                
                      static _Const_Link_type
                      _S_right(_Const_Base_ptr __x)
                      { return static_cast<_Const_Link_type>(__x->_M_right); }
                
                      static const_reference
          64 ->       _S_value(_Const_Base_ptr __x)
                      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }
                
                      static const _Key&
          64 ->       _S_key(_Const_Base_ptr __x)
                      { return _KeyOfValue()(_S_value(__x)); }
                
                      static _Base_ptr
                      _S_minimum(_Base_ptr __x)
                      { return _Rb_tree_node_base::_S_minimum(__x); }
                
                      static _Const_Base_ptr
                      _S_minimum(_Const_Base_ptr __x)
                      { return _Rb_tree_node_base::_S_minimum(__x); }
                
                      static _Base_ptr
                      _S_maximum(_Base_ptr __x)
                      { return _Rb_tree_node_base::_S_maximum(__x); }
                
                      static _Const_Base_ptr
                      _S_maximum(_Const_Base_ptr __x)
                      { return _Rb_tree_node_base::_S_maximum(__x); }
                
                    public:
                      typedef _Rb_tree_iterator<value_type>       iterator;
                      typedef _Rb_tree_const_iterator<value_type> const_iterator;
                
                      typedef std::reverse_iterator<iterator>       reverse_iterator;
                      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
                
                    private:
                      iterator
                      _M_insert(_Base_ptr __x, _Base_ptr __y, const value_type& __v);
                
                      const_iterator
                      _M_insert(_Const_Base_ptr __x, _Const_Base_ptr __y,
                		const value_type& __v);
                
                      _Link_type
                      _M_copy(_Const_Link_type __x, _Link_type __p);
                
                      void
                      _M_erase(_Link_type __x);
                
                    public:
                      // allocation/deallocation
                      _Rb_tree()
                      { }
                
                      _Rb_tree(const _Compare& __comp)
                      : _M_impl(allocator_type(), __comp)
                      { }
                
           1 ->       _Rb_tree(const _Compare& __comp, const allocator_type& __a)
                      : _M_impl(__a, __comp)
                      { }
                
                      _Rb_tree(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
                      : _M_impl(__x.get_allocator(), __x._M_impl._M_key_compare)
                      {
                	if (__x._M_root() != 0)
                	  {
                	    _M_root() = _M_copy(__x._M_begin(), _M_end());
                	    _M_leftmost() = _S_minimum(_M_root());
                	    _M_rightmost() = _S_maximum(_M_root());
                	    _M_impl._M_node_count = __x._M_impl._M_node_count;
                	  }
                      }
                
           1 ->       ~_Rb_tree()
                      { _M_erase(_M_begin()); }
                
                      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
                      operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x);
                
                      // Accessors.
                      _Compare
          91 ->       key_comp() const
                      { return _M_impl._M_key_compare; }
                
                      iterator
           2 ->       begin()
                      { 
                	return iterator(static_cast<_Link_type>
                			(this->_M_impl._M_header._M_left));
                      }
                
                      const_iterator
                      begin() const
                      { 
                	return const_iterator(static_cast<_Const_Link_type>
                			      (this->_M_impl._M_header._M_left));
                      }
                
                      iterator
         123 ->       end()
                      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }
                
                      const_iterator
                      end() const
                      { 
                	return const_iterator(static_cast<_Const_Link_type>
                			      (&this->_M_impl._M_header));
                      }
                
                      reverse_iterator
                      rbegin()
                      { return reverse_iterator(end()); }
                
                      const_reverse_iterator
                      rbegin() const
                      { return const_reverse_iterator(end()); }
                
                      reverse_iterator
                      rend()
                      { return reverse_iterator(begin()); }
                
                      const_reverse_iterator
                      rend() const
                      { return const_reverse_iterator(begin()); }
                
                      bool
                      empty() const
                      { return _M_impl._M_node_count == 0; }
                
                      size_type
           2 ->       size() const
                      { return _M_impl._M_node_count; }
                
                      size_type
                      max_size() const
                      { return size_type(-1); }
                
                      void
                      swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t);
                
                      // Insert/erase.
                      pair<iterator,bool>
                      insert_unique(const value_type& __x);
                
                      iterator
                      insert_equal(const value_type& __x);
                
                      iterator
                      insert_unique(iterator __position, const value_type& __x);
                
                      const_iterator
                      insert_unique(const_iterator __position, const value_type& __x);
                
                      iterator
                      insert_equal(iterator __position, const value_type& __x);
                
                      const_iterator
                      insert_equal(const_iterator __position, const value_type& __x);
                
                      template<typename _InputIterator>
                        void
                        insert_unique(_InputIterator __first, _InputIterator __last);
                
                      template<typename _InputIterator>
                        void
                        insert_equal(_InputIterator __first, _InputIterator __last);
                
                      void
                      erase(iterator __position);
                
                      void
                      erase(const_iterator __position);
                
                      size_type
                      erase(const key_type& __x);
                
                      void
                      erase(iterator __first, iterator __last);
                
                      void
                      erase(const_iterator __first, const_iterator __last);
                
                      void
                      erase(const key_type* __first, const key_type* __last);
                
                      void
                      clear()
                      {
                        _M_erase(_M_begin());
                        _M_leftmost() = _M_end();
                        _M_root() = 0;
                        _M_rightmost() = _M_end();
                        _M_impl._M_node_count = 0;
                      }
                
                      // Set operations.
                      iterator
                      find(const key_type& __x);
                
                      const_iterator
                      find(const key_type& __x) const;
                
                      size_type
                      count(const key_type& __x) const;
                
                      iterator
                      lower_bound(const key_type& __x);
                
                      const_iterator
                      lower_bound(const key_type& __x) const;
                
                      iterator
                      upper_bound(const key_type& __x);
                
                      const_iterator
                      upper_bound(const key_type& __x) const;
                
                      pair<iterator,iterator>
                      equal_range(const key_type& __x);
                
                      pair<const_iterator, const_iterator>
                      equal_range(const key_type& __x) const;
                
                      // Debugging.
                      bool
                      __rb_verify() const;
                    };
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    {
                      return __x.size() == __y.size()
                	     && std::equal(__x.begin(), __x.end(), __y.begin());
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	      const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    {
                      return std::lexicographical_compare(__x.begin(), __x.end(), 
                					  __y.begin(), __y.end());
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	      const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { return __y < __x; }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { return !(__y < __x); }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { return !(__x < __y); }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline void
                    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	 _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { __x.swap(__y); }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
                    {
                      if (this != &__x)
                	{
                	  // Note that _Key may be a constant type.
                	  clear();
                	  _M_impl._M_key_compare = __x._M_impl._M_key_compare;
                	  if (__x._M_root() != 0)
                	    {
                	      _M_root() = _M_copy(__x._M_begin(), _M_end());
                	      _M_leftmost() = _S_minimum(_M_root());
                	      _M_rightmost() = _S_maximum(_M_root());
                	      _M_impl._M_node_count = __x._M_impl._M_node_count;
                	    }
                	}
                      return *this;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
          29 ->     _M_insert(_Base_ptr __x, _Base_ptr __p, const _Val& __v)
                    {
                      bool __insert_left = (__x != 0 || __p == _M_end()
                			    || _M_impl._M_key_compare(_KeyOfValue()(__v), 
                						      _S_key(__p)));
                
                      _Link_type __z = _M_create_node(__v);
                
                      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,  
                				    this->_M_impl._M_header);
                      ++_M_impl._M_node_count;
                      return iterator(__z);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_insert(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)
                    {
                      bool __insert_left = (__x != 0 || __p == _M_end()
                			    || _M_impl._M_key_compare(_KeyOfValue()(__v), 
                						      _S_key(__p)));
                
                      _Link_type __z = _M_create_node(__v);
                
                      _Rb_tree_insert_and_rebalance(__insert_left, __z,
                				    const_cast<_Base_ptr>(__p),  
                				    this->_M_impl._M_header);
                      ++_M_impl._M_node_count;
                      return const_iterator(__z);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    insert_equal(const _Val& __v)
                    {
                      _Link_type __x = _M_begin();
                      _Link_type __y = _M_end();
                      while (__x != 0)
                	{
                	  __y = __x;
                	  __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?
                	        _S_left(__x) : _S_right(__x);
                	}
                      return _M_insert(__x, __y, __v);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)
                    {
                      if (_M_root() == 0)
                      {
                	if (__t._M_root() != 0)
                	{
                	  _M_root() = __t._M_root();
                	  _M_leftmost() = __t._M_leftmost();
                	  _M_rightmost() = __t._M_rightmost();
                          _M_root()->_M_parent = _M_end();
                
                	  __t._M_root() = 0;
                	  __t._M_leftmost() = __t._M_end();
                	  __t._M_rightmost() = __t._M_end();
                	}
                      }
                      else if (__t._M_root() == 0)
                      {
                	__t._M_root() = _M_root();
                	__t._M_leftmost() = _M_leftmost();
                	__t._M_rightmost() = _M_rightmost();
                        __t._M_root()->_M_parent = __t._M_end();
                
                	_M_root() = 0;
                	_M_leftmost() = _M_end();
                	_M_rightmost() = _M_end();
                      }
                      else
                      {
                	std::swap(_M_root(),__t._M_root());
                	std::swap(_M_leftmost(),__t._M_leftmost());
                	std::swap(_M_rightmost(),__t._M_rightmost());
                
                	_M_root()->_M_parent = _M_end();
                	__t._M_root()->_M_parent = __t._M_end();
                      }
                      // No need to swap header's color as it does not change.
                      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
                      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::iterator, bool>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
           1 ->     insert_unique(const _Val& __v)
                    {
                      _Link_type __x = _M_begin();
                      _Link_type __y = _M_end();
                      bool __comp = true;
                      while (__x != 0)
                	{
                	  __y = __x;
                	  __comp = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x));
                	  __x = __comp ? _S_left(__x) : _S_right(__x);
                	}
                      iterator __j = iterator(__y);
                      if (__comp)
                	if (__j == begin())
                	  return pair<iterator,bool>(_M_insert(__x, __y, __v), true);
                	else
                	  --__j;
                      if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
                	return pair<iterator, bool>(_M_insert(__x, __y, __v), true);
                      return pair<iterator, bool>(__j, false);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
          29 ->     insert_unique(iterator __position, const _Val& __v)
                    {
                      // end()
                      if (__position._M_node == _M_end())
                	{
                	  if (size() > 0
                	      && _M_impl._M_key_compare(_S_key(_M_rightmost()), 
                					_KeyOfValue()(__v)))
                	    return _M_insert(0, _M_rightmost(), __v);
                	  else
                	    return insert_unique(__v).first;
                	}
                      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
                				      _S_key(__position._M_node)))
                	{
                	  // First, try before...
                	  iterator __before = __position;
                	  if (__position._M_node == _M_leftmost()) // begin()
                	    return _M_insert(_M_leftmost(), _M_leftmost(), __v);
                	  else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), 
                					  _KeyOfValue()(__v)))
                	    {
                	      if (_S_right(__before._M_node) == 0)
                		return _M_insert(0, __before._M_node, __v);
                	      else
                		return _M_insert(__position._M_node,
                				 __position._M_node, __v);
                	    }
                	  else
                	    return insert_unique(__v).first;
                	}
                      else if (_M_impl._M_key_compare(_S_key(__position._M_node),
                				      _KeyOfValue()(__v)))
                	{
                	  // ... then try after.
                	  iterator __after = __position;
                	  if (__position._M_node == _M_rightmost())
                	    return _M_insert(0, _M_rightmost(), __v);
                	  else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
                					  _S_key((++__after)._M_node)))
                	    {
                	      if (_S_right(__position._M_node) == 0)
                		return _M_insert(0, __position._M_node, __v);
                	      else
                		return _M_insert(__after._M_node, __after._M_node, __v);
                	    }
                	  else
                	    return insert_unique(__v).first;
                	}
                      else
                	return __position; // Equivalent keys.
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    insert_unique(const_iterator __position, const _Val& __v)
                    {
                      // end()
                      if (__position._M_node == _M_end())
                	{
                	  if (size() > 0
                	      && _M_impl._M_key_compare(_S_key(_M_rightmost()), 
                					_KeyOfValue()(__v)))
                	    return _M_insert(0, _M_rightmost(), __v);
                	  else
                	    return const_iterator(insert_unique(__v).first);
                	}
                      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
                				      _S_key(__position._M_node)))
                	{
                	  // First, try before...
                	  const_iterator __before = __position;
                	  if (__position._M_node == _M_leftmost()) // begin()
                	    return _M_insert(_M_leftmost(), _M_leftmost(), __v);
                	  else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), 
                					  _KeyOfValue()(__v)))
                	    {
                	      if (_S_right(__before._M_node) == 0)
                		return _M_insert(0, __before._M_node, __v);
                	      else
                		return _M_insert(__position._M_node,
                				 __position._M_node, __v);
                	    }
                	  else
                	    return const_iterator(insert_unique(__v).first);
                	}
                      else if (_M_impl._M_key_compare(_S_key(__position._M_node),
                				      _KeyOfValue()(__v)))
                	{
                	  // ... then try after.
                	  const_iterator __after = __position;
                	  if (__position._M_node == _M_rightmost())
                	    return _M_insert(0, _M_rightmost(), __v);
                	  else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
                					  _S_key((++__after)._M_node)))
                	    {
                	      if (_S_right(__position._M_node) == 0)
                		return _M_insert(0, __position._M_node, __v);
                	      else
                		return _M_insert(__after._M_node, __after._M_node, __v);
                	    }
                	  else
                	    return const_iterator(insert_unique(__v).first);
                	}
                      else
                	return __position; // Equivalent keys.
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    insert_equal(iterator __position, const _Val& __v)
                    {
                      // end()
                      if (__position._M_node == _M_end())
                	{
                	  if (size() > 0
                	      && !_M_impl._M_key_compare(_KeyOfValue()(__v),
                					 _S_key(_M_rightmost())))
                	    return _M_insert(0, _M_rightmost(), __v);
                	  else
                	    return insert_equal(__v);
                	}
                      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),
                				       _KeyOfValue()(__v)))
                	{
                	  // First, try before...
                	  iterator __before = __position;
                	  if (__position._M_node == _M_leftmost()) // begin()
                	    return _M_insert(_M_leftmost(), _M_leftmost(), __v);
                	  else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
                					   _S_key((--__before)._M_node)))
                	    {
                	      if (_S_right(__before._M_node) == 0)
                		return _M_insert(0, __before._M_node, __v);
                	      else
                		return _M_insert(__position._M_node,
                				 __position._M_node, __v);
                	    }
                	  else
                	    return insert_equal(__v);
                	}
                      else
                	{
                	  // ... then try after.  
                	  iterator __after = __position;
                	  if (__position._M_node == _M_rightmost())
                	    return _M_insert(0, _M_rightmost(), __v);
                	  else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),
                					   _KeyOfValue()(__v)))
                	    {
                	      if (_S_right(__position._M_node) == 0)
                		return _M_insert(0, __position._M_node, __v);
                	      else
                		return _M_insert(__after._M_node, __after._M_node, __v);
                	    }
                	  else
                	    return insert_equal(__v);
                	}
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    insert_equal(const_iterator __position, const _Val& __v)
                    {
                      // end()
                      if (__position._M_node == _M_end())
                	{
                	  if (size() > 0
                	      && !_M_impl._M_key_compare(_KeyOfValue()(__v),
                					 _S_key(_M_rightmost())))
                	    return _M_insert(0, _M_rightmost(), __v);
                	  else
                	    return const_iterator(insert_equal(__v));
                	}
                      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),
                				       _KeyOfValue()(__v)))
                	{
                	  // First, try before...
                	  const_iterator __before = __position;
                	  if (__position._M_node == _M_leftmost()) // begin()
                	    return _M_insert(_M_leftmost(), _M_leftmost(), __v);
                	  else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
                					   _S_key((--__before)._M_node)))
                	    {
                	      if (_S_right(__before._M_node) == 0)
                		return _M_insert(0, __before._M_node, __v);
                	      else
                		return _M_insert(__position._M_node,
                				 __position._M_node, __v);
                	    }
                	  else
                	    return const_iterator(insert_equal(__v));
                	}
                      else
                	{
                	  // ... then try after.  
                	  const_iterator __after = __position;
                	  if (__position._M_node == _M_rightmost())
                	    return _M_insert(0, _M_rightmost(), __v);
                	  else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),
                					   _KeyOfValue()(__v)))
                	    {
                	      if (_S_right(__position._M_node) == 0)
                		return _M_insert(0, __position._M_node, __v);
                	      else
                		return _M_insert(__after._M_node, __after._M_node, __v);
                	    }
                	  else
                	    return const_iterator(insert_equal(__v));
                	}
                    }
                
                  template<typename _Key, typename _Val, typename _KoV,
                           typename _Cmp, typename _Alloc>
                    template<class _II>
                      void
                      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
                      insert_equal(_II __first, _II __last)
                      {
                	for (; __first != __last; ++__first)
                	  insert_equal(end(), *__first);
                      }
                
                  template<typename _Key, typename _Val, typename _KoV,
                           typename _Cmp, typename _Alloc>
                    template<class _II>
                      void
                      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
                      insert_unique(_II __first, _II __last)
                      {
                	for (; __first != __last; ++__first)
                	  insert_unique(end(), *__first);
                      }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(iterator __position)
                    {
                      _Link_type __y =
                	static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
                				(__position._M_node,
                				 this->_M_impl._M_header));
                      destroy_node(__y);
                      --_M_impl._M_node_count;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(const_iterator __position)
                    {
                      _Link_type __y =
                	static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
                				(const_cast<_Base_ptr>(__position._M_node),
                				 this->_M_impl._M_header));
                      destroy_node(__y);
                      --_M_impl._M_node_count;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(const _Key& __x)
                    {
                      pair<iterator,iterator> __p = equal_range(__x);
                      size_type __n = std::distance(__p.first, __p.second);
                      erase(__p.first, __p.second);
                      return __n;
                    }
                
                  template<typename _Key, typename _Val, typename _KoV,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
                    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
                    _M_copy(_Const_Link_type __x, _Link_type __p)
                    {
                      // Structural copy.  __x and __p must be non-null.
                      _Link_type __top = _M_clone_node(__x);
                      __top->_M_parent = __p;
                
                      try
                	{
                	  if (__x->_M_right)
                	    __top->_M_right = _M_copy(_S_right(__x), __top);
                	  __p = __top;
                	  __x = _S_left(__x);
                
                	  while (__x != 0)
                	    {
                	      _Link_type __y = _M_clone_node(__x);
                	      __p->_M_left = __y;
                	      __y->_M_parent = __p;
                	      if (__x->_M_right)
                		__y->_M_right = _M_copy(_S_right(__x), __y);
                	      __p = __y;
                	      __x = _S_left(__x);
                	    }
                	}
                      catch(...)
                	{
                	  _M_erase(__top);
                	  __throw_exception_again;
                	}
                      return __top;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
           1 ->     _M_erase(_Link_type __x)
                    {
                      // Erase without rebalancing.
                      while (__x != 0)
                	{
                	  _M_erase(_S_right(__x));
                	  _Link_type __y = _S_left(__x);
                	  destroy_node(__x);
                	  __x = __y;
                	}
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(iterator __first, iterator __last)
                    {
                      if (__first == begin() && __last == end())
                	clear();
                      else
                	while (__first != __last)
                	  erase(__first++);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(const_iterator __first, const_iterator __last)
                    {
                      if (__first == begin() && __last == end())
                	clear();
                      else
                	while (__first != __last)
                	  erase(__first++);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(const _Key* __first, const _Key* __last)
                    {
                      while (__first != __last)
                	erase(*__first++);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    find(const _Key& __k)
                    {
                      _Link_type __x = _M_begin(); // Current node.
                      _Link_type __y = _M_end(); // Last node which is not less than __k.
                
                      while (__x != 0)
                	if (!_M_impl._M_key_compare(_S_key(__x), __k))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                
                      iterator __j = iterator(__y);
                      return (__j == end()
                	      || _M_impl._M_key_compare(__k,
                					_S_key(__j._M_node))) ? end() : __j;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    find(const _Key& __k) const
                    {
                      _Const_Link_type __x = _M_begin(); // Current node.
                      _Const_Link_type __y = _M_end(); // Last node which is not less than __k.
                
                     while (__x != 0)
                       {
                	 if (!_M_impl._M_key_compare(_S_key(__x), __k))
                	   __y = __x, __x = _S_left(__x);
                	 else
                	   __x = _S_right(__x);
                       }
                     const_iterator __j = const_iterator(__y);
                     return (__j == end()
                	     || _M_impl._M_key_compare(__k, 
                				       _S_key(__j._M_node))) ? end() : __j;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    count(const _Key& __k) const
                    {
                      pair<const_iterator, const_iterator> __p = equal_range(__k);
                      const size_type __n = std::distance(__p.first, __p.second);
                      return __n;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
          93 ->     lower_bound(const _Key& __k)
                    {
                      _Link_type __x = _M_begin(); // Current node.
                      _Link_type __y = _M_end(); // Last node which is not less than __k.
                
                      while (__x != 0)
                	if (!_M_impl._M_key_compare(_S_key(__x), __k))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                
                      return iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    lower_bound(const _Key& __k) const
                    {
                      _Const_Link_type __x = _M_begin(); // Current node.
                      _Const_Link_type __y = _M_end(); // Last node which is not less than __k.
                
                      while (__x != 0)
                	if (!_M_impl._M_key_compare(_S_key(__x), __k))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                
                      return const_iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    upper_bound(const _Key& __k)
                    {
                      _Link_type __x = _M_begin(); // Current node.
                      _Link_type __y = _M_end(); // Last node which is greater than __k.
                
                      while (__x != 0)
                	if (_M_impl._M_key_compare(__k, _S_key(__x)))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                
                      return iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    upper_bound(const _Key& __k) const
                    {
                      _Const_Link_type __x = _M_begin(); // Current node.
                      _Const_Link_type __y = _M_end(); // Last node which is greater than __k.
                
                      while (__x != 0)
                	if (_M_impl._M_key_compare(__k, _S_key(__x)))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                
                      return const_iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::iterator,
                	 typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    equal_range(const _Key& __k)
                    { return pair<iterator, iterator>(lower_bound(__k), upper_bound(__k)); }
                
                  template<typename _Key, typename _Val, typename _KoV,
                           typename _Compare, typename _Alloc>
                    inline
                    pair<typename _Rb_tree<_Key, _Val, _KoV,
                			   _Compare, _Alloc>::const_iterator,
                	 typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::const_iterator>
                    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
                    equal_range(const _Key& __k) const
                    { return pair<const_iterator, const_iterator>(lower_bound(__k),
                						  upper_bound(__k)); }
                
                  unsigned int
                  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                                       const _Rb_tree_node_base* __root);
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    bool
                    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
                    {
                      if (_M_impl._M_node_count == 0 || begin() == end())
                	return _M_impl._M_node_count == 0 && begin() == end()
                	       && this->_M_impl._M_header._M_left == _M_end()
                	       && this->_M_impl._M_header._M_right == _M_end();
                
                      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
                      for (const_iterator __it = begin(); __it != end(); ++__it)
                	{
                	  _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
                	  _Const_Link_type __L = _S_left(__x);
                	  _Const_Link_type __R = _S_right(__x);
                
                	  if (__x->_M_color == _S_red)
                	    if ((__L && __L->_M_color == _S_red)
                		|| (__R && __R->_M_color == _S_red))
                	      return false;
                
                	  if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
                	    return false;
                	  if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
                	    return false;
                
                	  if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
                	    return false;
                	}
                
                      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
                	return false;
                      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
                	return false;
                      return true;
                    }
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

      484        398
      488        398
      492        279
      168        248
      500        200
      172        184
      476        137
      603        123
      465         95
      210         94

Execution Summary:

       36   Executable lines in this file
       36   Lines executed
   100.00   Percent of the file executed

     2888   Total number of line executions
    80.22   Average executions per line


*** File /home/tyler/Desktop/fland2/vertex.cpp:
                // every vertex in a mesh
                #ifndef VERTEX_CPP
                #define VERTEX_CPP
                
                // NOTE: A vertex's children will be stored in the child vector, along with
                // in the vChild array.
                
                using namespace std;
                
                #include <sstream>
                #include <GL/glut.h>
                #include "tyler.h"
                #include "rendervertex.h"
                #include "baseent.h"
                #include "templates.h"
                #include "main.h"
                #include "vertex.h"
                #include "fland.h"
                #include "glutenv.h"
                
                
                extern vector<RenderVertex> vertexArray;
                extern vector<GLuint> vertexArrayIndex;
                
                // debugging help
       ##### -> void Vertex::teapot()
                {
                	Camera *cam = getFlandPtr()->camera;
                
                	glDisable( GL_DEPTH_TEST );
                
                	glPushMatrix();
                	glTranslatef( trueVertex.x - cam->x, trueVertex.y - cam->y, trueVertex.z - cam->z );
                	glColor4f( 1.0, 0.5, 0.5, 0.5 );
                	glutSolidSphere( bound.radius/ 10, 10, 5 );
                	glPopMatrix(  );
                
                	glPushMatrix();
                	glTranslatef( startMorphVertex.x - cam->x, startMorphVertex.y - cam->y, startMorphVertex.z - cam->z );
                	glColor4f( 0.5, 1.0, 0.5, 0.5 );
                	glutSolidSphere( bound.radius/ 15, 10, 5 );
                	glPopMatrix(  );
                
                	glPushMatrix();
                	glTranslatef( morphVertex.x - cam->x, morphVertex.y - cam->y, morphVertex.z - cam->z );
                	glColor4f( 0.5, 0.5, 1.0, 0.5 );
                	glutSolidSphere( bound.radius/ 20, 10, 5 );
                	glPopMatrix(  );
                
                	glEnable( GL_DEPTH_TEST );
                
                	//glPushMatrix();
                	//glTranslatef( morphVertex.x, morphVertex.y, morphVertex.z );
                	//glColor4f( 0.5, 0.5, 1.0, 0.5 );
                	//glDisable( GL_DEPTH_TEST );
                	//glutSolidSphere( bound.radius/10, 10, 5 );
                	//glEnable( GL_DEPTH_TEST );
                	//glPopMatrix(  );
                }
                
       ##### -> void Vertex::printType(){ cout << "Vertex" << endl;}
     5461930 -> string Vertex::getType(){ return "Vertex"; }
                
                #if DEBUG
                
       ##### -> void Vertex::recursiveCheck()
                {
                	if( morphVertex.x > .8 ||
                		 morphVertex.x < -.8 ||
                		 morphVertex.z > .8 ||
                		 morphVertex.z < -.8 )
                	{
                		cout << toString( 0 );
                	}
                	for( int i=0; i<9; i++ )
                	{
                		vChild[i]->recursiveCheck();
                	}
                }
                
       ##### -> void Vertex::dump( ostream& out, int depth )
                {
                	out << indent( depth ) << "Vertex\n";
                	//cout << "Neighbor[4] = " << neighbor[4];
                	BaseEnt::dump( out, depth );
                }
                
       ##### -> string Vertex::toString( int depth = 0 )
                {
                	ostringstream out;
                	string ind = indent( depth );
                
                	out << BaseEnt::toString( depth );
                
                	out << ind << "Vertex::\n";
                	for( int i=0; i<9; i++ )
                	{
                	out << ind << "vChild[" << i << "]         " << vChild[i] << endl;
                	}
                	for( int i=0; i<9; i++ )
                	{
                	out << ind << "neighbor[" << i << "]       " << neighbor[i] << endl;
                	}
                	out << ind << "vChildNum         " << vChildNum << endl;
                
                	for( int i=0; i<NUM_AFFECT_VERTICIES; i++ )
                	{
                		out << ind << "Affect Vertex[" << i << "]   " << affectVertex[i] << endl;
                		out << ind << "Affect Amount[" << i << "]   " << affectAmount[i] << endl;
                	}
                	out << ind << "trueVertex       " << trueVertex.toString() << endl;
                	out << ind << "startMorphVertex " << startMorphVertex.toString()<< endl;
                	out << ind << "morphVertex      " << morphVertex.toString()<< endl;
                
                	return out.str();
                }
                #endif
                
       ##### -> Reuse< BaseEnt, Vertex > Vertex::reuse;
                
        1982 -> void Vertex::split()
                {
                	// if this vertex is already split, send the message to split our kids.
                	if( isSplit )
                	{
                		// split our kids
                		BaseEnt::split();
                		// exit function
                	}
                	tSrand( seed );
                	// Make sure all our neighbors exist. If they dont, this function will
                	// split the aunt until they do exist.
                	assertNeighborsSplit();
                	createChildren();
                	pointChildrenAtNeighbors();
                	calcAffectVerticies();
                	calcNormals();
                	// This will create any other children.
                
                	// (THESE have to be in this order or the "STAR" bug occurs)
                	calcStartMorph();
                	BaseEnt::split();
                }
                
        1982 -> void Vertex::calcStartMorph()
                {
                	// children 1 through 7 are normal cases
                	for( int i=0; i<9; i++ )
                	{
                		if( vChild[i] )
                		{
                			//vChild[i]->startMorphVertex = VERT(this)->trueVertex * ( 1.0 - vChild[i]->createVisibility );
                			//vChild[i]->startMorphVertex += neighbor[i]->trueVertex * ( vChild[i]->createVisibility );
                			vChild[i]->startMorphVertex = VERT(this)->trueVertex * ( 2.0 / 3.0 );
                			vChild[i]->startMorphVertex += neighbor[i]->trueVertex * ( 1.0 / 3.0 );
                		}
                	}
                
                	// 0 and 8 are special, due to the orientation of the triangles being rendered.
                	if( vChild[0] )
                	{
                		vChild[0]->startMorphVertex = VERT(this)->trueVertex * ( vChild[0]->createVisibility );
                		vChild[0]->startMorphVertex += neighbor[1]->trueVertex * ( vChild[0]->createVisibility );
                		vChild[0]->startMorphVertex += neighbor[3]->trueVertex * ( vChild[0]->createVisibility );
                	}
                
                	if( vChild[8] )
                	{
                		vChild[8]->startMorphVertex = VERT(this)->trueVertex * ( vChild[8]->createVisibility );
                		vChild[8]->startMorphVertex += neighbor[5]->trueVertex * ( vChild[8]->createVisibility );
                		vChild[8]->startMorphVertex += neighbor[7]->trueVertex * ( vChild[8]->createVisibility );
                	}
                
                
                	//// DEBUG
                	//for( int i=0; i<9; i++ )
                	//{
                	//	if( vChild[i] )
                	//	{
                	//		if( abs( vChild[i]->startMorphVertex.x ) > .8 || abs( vChild[i]->startMorphVertex.z ) > .8 )
                	//		{
                	//			cout << i << endl;
                	//			cout << vChild[i]->startMorphVertex.toString(0) << endl;
                	//			cout << vChild[i]->createVisibility;LN
                	//			//cout << vChild[i]->toString(10);
                	//			sassert( 0 == 1 );
                	//		}
                	//	}
                	//}
                }
                
     1678396 -> void Vertex::calcMorph(double morphAmount )
                {
                	Fland* fl = getFlandPtr();
                
                	if( fl->env.keys[' '] == false )
                	{
                		if( morphAmount == 1.0 ) // dont spend our time interpolating if we dont need to
                		{
                			morphVertex = trueVertex;
                		}
                		else
                		{
                			morphVertex.interpolate( startMorphVertex, trueVertex, morphAmount );
                		}
                	}
                	else
                	{
                		morphVertex = trueVertex;
                	}
                }
                
        1982 -> void Vertex::calcNormals()
                {
                	// calcVertexNormal. Put the normal in v1.
                #define CVN( v1, v2, v3, store ) calcNormal( v2->trueVertex.x, v2->trueVertex.y, v2->trueVertex.z, v1->trueVertex.x, v1->trueVertex.y, v1->trueVertex.z, v3->trueVertex.x, v3->trueVertex.y, v3->trueVertex.z, VERT(store)->trueVertex.nx, VERT(store)->trueVertex.ny, VERT(store)->trueVertex.nz );
                	// Average 2 verticies and store the result.
                #define AV( in1, in2, store ) store->trueVertex.nx = ( in1->trueVertex.nx + in2->trueVertex.nx ); \
                											  store->trueVertex.ny = ( in1->trueVertex.ny + in2->trueVertex.ny ); \
                											  store->trueVertex.nz = ( in1->trueVertex.nz + in2->trueVertex.nz ); \
                											  normalize( store->trueVertex.nx, store->trueVertex.ny, store->trueVertex.nz );
                
                	if( neighbor[0] )
                	{
                		CVN( neighbor[3], neighbor[0], neighbor[4], vChild[3] );
                		CVN( neighbor[1], neighbor[4], neighbor[0], vChild[1] );
                		AV( vChild[3], vChild[1], vChild[0] );
                	}
                
                	if( neighbor[2] )
                	{
                		CVN( neighbor[1], neighbor[2], neighbor[4], vChild[1] );
                		CVN( neighbor[5], neighbor[4], neighbor[2], vChild[5] );
                		AV( vChild[1], vChild[5], vChild[2] );
                	}
                	if( neighbor[6] )
                	{
                		CVN( neighbor[7], neighbor[6], neighbor[4], vChild[7] );
                		CVN( neighbor[3], neighbor[4], neighbor[6], vChild[3] );
                		AV( vChild[7], vChild[3], vChild[6] );
                	}
                	if( neighbor[8] )
                	{
                		CVN( neighbor[5], neighbor[7], neighbor[4], vChild[5] );
                		CVN( neighbor[7], neighbor[4], neighbor[8], vChild[7] );
                		AV( vChild[7], vChild[5], vChild[8] );
                	}
                
                	for( int i=0; i<9; i++ )
                	{
                		if( i == 4 )
                			continue;
                		if( vChild[i] )
                		{
                			vChild[4]->trueVertex.nx += vChild[i]->trueVertex.nx;
                			vChild[4]->trueVertex.ny += vChild[i]->trueVertex.ny;
                			vChild[4]->trueVertex.nz += vChild[i]->trueVertex.nz;
                		}
                	}
                	normalize( vChild[4]->trueVertex.nx, vChild[4]->trueVertex.ny, vChild[4]->trueVertex.nz );
                
                	// TODO: this block shouldn't be necessary, and it slows things down. Fix the problem.
                	for( int i=0; i<9; i++ )
                	{
                		if( vChild[i] )
                		{
                			// This line messes up once if the file is loaded
                			if( !normalize( vChild[i]->trueVertex.nx, vChild[i]->trueVertex.ny, vChild[i]->trueVertex.nz ) )
                			{
                				//cout << i << endl;;LN
                				//vChild[i]->toString();
                			}
                		}
                	}
                
                
                }
                
                //////// taken care of in Vertex::draw()
                //void Vertex::addToVertexArray()
                //{
                //    vertexArrayIndex = vertexArray.size();
                //    vertexArray.push_back( morphVertex );
                
                //    if( isSplit ){
                //        for( int i=0; i<9; ++i ) {
                //            vChild[i].addToVertexArray();
                //        }
                //    }
                //}
                
        1982 -> int Vertex::calcAffectVerticies()
                {
                	/*
                	for( int c=0; c<9; c++ )
                	{
                		if( vChild[c] )
                		{
                			vChild[c]->affectVertex[0] = this;
                				vChild[c]->affectAmount[0] = 2.0 / 3.0;
                			vChild[c]->affectVertex[1] = neighbor[c];
                				vChild[c]->affectAmount[1] = 1.0 / 3.0;
                		}
                	}
                	return 0;
                	*/
                	// the old way
                	if( vChild[0] )
                	{
                		VERT(vChild[0])->affectVertex[0] = this;
                			VERT(vChild[0])->affectAmount[0] = 4.0 / 9.0;
                		VERT(vChild[0])->affectVertex[1] = neighbor[3];
                			VERT(vChild[0])->affectAmount[1] = 2.0 / 9.0;
                		VERT(vChild[0])->affectVertex[2] = neighbor[0];
                			VERT(vChild[0])->affectAmount[2] = 1.0 / 9.0;
                		VERT(vChild[0])->affectVertex[3] = neighbor[1];
                			VERT(vChild[0])->affectAmount[3] = 2.0 / 9.0;
                	}
                
                	if( vChild[1] )
                	{
                		VERT(vChild[1])->affectVertex[0] = this;
                			VERT(vChild[1])->affectAmount[0] = 6.0 / 9.0;
                		VERT(vChild[1])->affectVertex[1] = neighbor[1];
                			VERT(vChild[1])->affectAmount[1] = 3.0 / 9.0;
                	}
                
                	if( vChild[2] )
                	{
                		VERT(vChild[2])->affectVertex[0] = this;
                			VERT(vChild[2])->affectAmount[0] = 4.0 / 9.0;
                		VERT(vChild[2])->affectVertex[1] = neighbor[1];
                			VERT(vChild[2])->affectAmount[1] = 2.0 / 9.0;
                		VERT(vChild[2])->affectVertex[2] = neighbor[2];
                			VERT(vChild[2])->affectAmount[2] = 1.0 / 9.0;
                		VERT(vChild[2])->affectVertex[3] = neighbor[5];
                			VERT(vChild[2])->affectAmount[3] = 2.0 / 9.0;
                	}
                
                	if( vChild[3] )
                	{
                		VERT(vChild[3])->affectVertex[0] = this;
                			VERT(vChild[3])->affectAmount[0] = 6.0 / 9.0;
                		VERT(vChild[3])->affectVertex[1] = neighbor[3];
                			VERT(vChild[3])->affectAmount[1] = 3.0 / 9.0;
                	}
                
                	// vChild[4] will always exist
                	VERT(vChild[4])->affectVertex[0] = this;
                		VERT(vChild[4])->affectAmount[0] = 9.0 / 9.0;
                
                
                	if( vChild[5] )
                	{
                		VERT(vChild[5])->affectVertex[0] = this;
                			VERT(vChild[5])->affectAmount[0] = 6.0 / 9.0;
                		VERT(vChild[5])->affectVertex[1] = neighbor[5];
                			VERT(vChild[5])->affectAmount[1] = 3.0 / 9.0;
                	}
                
                	if( vChild[6] )
                	{
                		VERT(vChild[6])->affectVertex[0] = this;
                			VERT(vChild[6])->affectAmount[0] = 4.0 / 9.0;
                		VERT(vChild[6])->affectVertex[1] = neighbor[3];
                			VERT(vChild[6])->affectAmount[1] = 2.0 / 9.0;
                		VERT(vChild[6])->affectVertex[2] = neighbor[6];
                			VERT(vChild[6])->affectAmount[2] = 1.0 / 9.0;
                		VERT(vChild[6])->affectVertex[3] = neighbor[7];
                			VERT(vChild[6])->affectAmount[3] = 2.0 / 9.0;
                	}
                
                	if( vChild[7] )
                	{
                		VERT(vChild[7])->affectVertex[0] = this;
                			VERT(vChild[7])->affectAmount[0] = 6.0 / 9.0;
                		VERT(vChild[7])->affectVertex[1] = neighbor[7];
                			VERT(vChild[7])->affectAmount[1] = 3.0 / 9.0;
                	}
                
                	if( vChild[8] )
                	{
                		VERT(vChild[8])->affectVertex[0] = this;
                			VERT(vChild[8])->affectAmount[0] = 4.0 / 9.0;
                		VERT(vChild[8])->affectVertex[1] = neighbor[5];
                			VERT(vChild[8])->affectAmount[1] = 2.0 / 9.0;
                		VERT(vChild[8])->affectVertex[2] = neighbor[8];
                			VERT(vChild[8])->affectAmount[2] = 1.0 / 9.0;
                		VERT(vChild[8])->affectVertex[3] = neighbor[7];
                			VERT(vChild[8])->affectAmount[3] = 2.0 / 9.0;
                	}
                	return 0;
                }
                
        1982 -> int Vertex::createChildren()
                {
                	// loop through and create each vChild.
                	for( int i=0; i<9; i++ )
                	{
                		// Make sure the mesh extends in the direction of the vChild being created.
                		// This insures we dont create children that will be off the edge of the mesh.
                		if( neighbor[i] )
                		{
                			// create the vChild object
                			vChild[i] = VERT(reuse.tNew( this ));
                
                			// Set the bound radius to be a third of the parent's
                			vChild[i]->bound.radius = bound.radius / 3.0;
                			// If any rules change the bound radius, rerun this calulation!
                			vChild[i]->createVisibility = bound.radius / parent->bound.radius;
                
                			// add it to the children list
                			child.push_back( vChild[i] );
                
                			// set the vChildNum
                			VERT(vChild[i])->vChildNum = i;
                			// use the next random number for the child's seed.
                			vChild[i]->seed = tRand();
                		}
                	}
                	return 0;
                }
                
        1982 -> int Vertex::pointChildrenAtNeighbors()
                {
                
                	// first point the vChild at himself, otherwise things get messed up.
                	VERT(vChild[4])->neighbor[4] = vChild[4];
                
                	// point vChildren at their siblings
                	// NOTE: These setpointer commands are based on the corner verticies.
                	// if each corner exist it connects all the pointers in it's quadrant.
                	// some pointers will be connected twice, but this way is very simple.
                	if( vChild[0] ) // If we're on an edge, this vertex may not exist.
                	{
                		// corner vertex
                		VERT(vChild[0])->neighbor[5] = vChild[1];
                			VERT(vChild[1])->neighbor[3] = vChild[0];
                		VERT(vChild[0])->neighbor[7] = vChild[3];
                			VERT(vChild[3])->neighbor[1] = vChild[0];
                		VERT(vChild[0])->neighbor[8] = vChild[4];
                			VERT(vChild[4])->neighbor[0] = vChild[0];
                		// middle verticies
                		VERT(vChild[1])->neighbor[7] = vChild[4];
                			VERT(vChild[4])->neighbor[1] = vChild[1];
                		VERT(vChild[3])->neighbor[5] = vChild[4];
                			VERT(vChild[4])->neighbor[3] = vChild[3];
                		// diagnals
                		VERT(vChild[3])->neighbor[2] = vChild[1];
                			VERT(vChild[1])->neighbor[6] = vChild[3];
                	}
                
                	if( vChild[2] ) // If we're on an edge, this vertex may not exist.
                	{
                		// corner vertex
                		VERT(vChild[2])->neighbor[3] = vChild[1];
                			VERT(vChild[1])->neighbor[5] = vChild[2];
                		VERT(vChild[2])->neighbor[7] = vChild[5];
                			VERT(vChild[5])->neighbor[1] = vChild[2];
                		VERT(vChild[2])->neighbor[6] = vChild[4];
                			VERT(vChild[4])->neighbor[2] = vChild[2];
                		// middle verticies
                		VERT(vChild[1])->neighbor[7] = vChild[4];
                			VERT(vChild[4])->neighbor[1] = vChild[1];
                		VERT(vChild[5])->neighbor[3] = vChild[4];
                			VERT(vChild[4])->neighbor[5] = vChild[5];
                		// diagnals
                		VERT(vChild[5])->neighbor[0] = vChild[1];
                			VERT(vChild[1])->neighbor[8] = vChild[5];
                	}
                
                	if( vChild[6] ) // If we're on an edge, this vertex may not exist.
                	{
                		// corner vertex
                		VERT(vChild[6])->neighbor[5] = vChild[7];
                			VERT(vChild[7])->neighbor[3] = vChild[6];
                		VERT(vChild[6])->neighbor[1] = vChild[3];
                			VERT(vChild[3])->neighbor[7] = vChild[6];
                		VERT(vChild[6])->neighbor[2] = vChild[4];
                			VERT(vChild[4])->neighbor[6] = vChild[6];
                		// middle verticies
                		VERT(vChild[3])->neighbor[5] = vChild[4];
                			VERT(vChild[4])->neighbor[3] = vChild[3];
                		VERT(vChild[7])->neighbor[1] = vChild[4];
                			VERT(vChild[4])->neighbor[7] = vChild[7];
                		// diagnals
                		VERT(vChild[3])->neighbor[8] = vChild[7];
                			VERT(vChild[7])->neighbor[0] = vChild[3];
                	}
                
                	if( vChild[8] ) // If we're on an edge, this vertex may not exist.
                	{
                		// corner vertex
                		VERT(vChild[8])->neighbor[3] = vChild[7];
                			VERT(vChild[7])->neighbor[5] = vChild[8];
                
                		VERT(vChild[8])->neighbor[1] = vChild[5];
                			VERT(vChild[5])->neighbor[7] = vChild[8];
                		VERT(vChild[8])->neighbor[0] = vChild[4];
                			VERT(vChild[4])->neighbor[8] = vChild[8];
                		// middle verticies
                		VERT(vChild[5])->neighbor[3] = vChild[4];
                			VERT(vChild[4])->neighbor[5] = vChild[5];
                		VERT(vChild[7])->neighbor[1] = vChild[4];
                			VERT(vChild[4])->neighbor[7] = vChild[7];
                		// diagnals
                		VERT(vChild[5])->neighbor[6] = vChild[7];
                			VERT(vChild[7])->neighbor[2] = vChild[5];
                	}
                
                
                	// point vChildren at thier cousins
                	// must check that cousins are split, and that we dont lie on an edge (some
                	// verticies dont exist).
                
                	// neighbor 0, a diagnal
                	if( neighbor[0] && neighbor[0]->isSplit )
                	{
                		VERT(vChild[0])->neighbor[0] = VERT(neighbor[0])->vChild[8];
                			VERT(VERT(neighbor[0])->vChild[8])->neighbor[8] = vChild[0];
                	}
                
                	// neighbor 1
                	if( neighbor[1] && neighbor[1]->isSplit )
                	{
                		// The straight edge.
                		VERT(vChild[1])->neighbor[1] = VERT(neighbor[1])->vChild[7];
                			VERT(VERT(neighbor[1])->vChild[7])->neighbor[7] = vChild[1];
                		// if the corner vChild exists, then we know we aren't hanging over an edge
                		if( vChild[0] )
                		{
                			VERT(vChild[0])->neighbor[1] = VERT(neighbor[1])->vChild[6];
                				VERT(VERT(neighbor[1])->vChild[6])->neighbor[7] = vChild[0];
                			VERT(vChild[0])->neighbor[2] = VERT(neighbor[1])->vChild[7];
                				VERT(VERT(neighbor[1])->vChild[7])->neighbor[6] = vChild[0];
                
                			VERT(vChild[1])->neighbor[0] = VERT(neighbor[1])->vChild[6];
                				VERT(VERT(neighbor[1])->vChild[6])->neighbor[8] = vChild[1];
                		}
                
                		if( vChild[2] )
                		{
                			VERT(vChild[2])->neighbor[1] = VERT(neighbor[1])->vChild[8];
                				VERT(VERT(neighbor[1])->vChild[8])->neighbor[7] = vChild[2];
                			VERT(vChild[2])->neighbor[0] = VERT(neighbor[1])->vChild[7];
                				VERT(VERT(neighbor[1])->vChild[7])->neighbor[8] = vChild[2];
                
                			VERT(vChild[1])->neighbor[2] = VERT(neighbor[1])->vChild[8];
                				VERT(VERT(neighbor[1])->vChild[8])->neighbor[6] = vChild[1];
                		}
                	}
                
                	// neighbor 2, a diagnal
                	if( neighbor[2] && neighbor[2]->isSplit )
                	{
                		VERT(vChild[2])->neighbor[2] = VERT(neighbor[2])->vChild[6];
                			VERT(VERT(neighbor[2])->vChild[6])->neighbor[6] = vChild[2];
                	}
                
                	// neighbor 3
                	if( neighbor[3] && neighbor[3]->isSplit )
                	{
                		// The straight edge.
                		VERT(vChild[3])->neighbor[3] = VERT(neighbor[3])->vChild[5];
                			VERT(VERT(neighbor[3])->vChild[5])->neighbor[5] = vChild[3];
                		// if the corner vChild exists, then we know we aren't hanging over an edge
                		if( vChild[6] )
                		{
                			VERT(vChild[6])->neighbor[3] = VERT(neighbor[3])->vChild[8];
                				VERT(VERT(neighbor[3])->vChild[8])->neighbor[5] = vChild[6];
                			VERT(vChild[6])->neighbor[0] = VERT(neighbor[3])->vChild[5];
                				VERT(VERT(neighbor[3])->vChild[5])->neighbor[8] = vChild[6];
                
                			VERT(vChild[3])->neighbor[6] = VERT(neighbor[3])->vChild[8];
                				VERT(VERT(neighbor[3])->vChild[8])->neighbor[2] = vChild[3];
                		}
                
                		if( vChild[0] )
                		{
                			VERT(vChild[0])->neighbor[3] = VERT(neighbor[3])->vChild[2];
                				VERT(VERT(neighbor[3])->vChild[2])->neighbor[5] = vChild[0];
                			VERT(vChild[0])->neighbor[6] = VERT(neighbor[3])->vChild[5];
                				VERT(VERT(neighbor[3])->vChild[5])->neighbor[2] = vChild[0];
                
                			VERT(vChild[3])->neighbor[0] = VERT(neighbor[3])->vChild[2];
                				VERT(VERT(neighbor[3])->vChild[2])->neighbor[8] = vChild[3];
                		}
                	}
                
                	// neighbor 5
                	if( neighbor[5] && neighbor[5]->isSplit )
                	{
                		// The straight edge.
                		VERT(vChild[5])->neighbor[5] = VERT(neighbor[5])->vChild[3];
                			VERT(VERT(neighbor[5])->vChild[3])->neighbor[3] = vChild[5];
                
                		// if the corner vChild exists, then we know we aren't hanging over an edge
                		if( vChild[2] )
                		{
                
                			VERT(vChild[2])->neighbor[5] = VERT(neighbor[5])->vChild[0];
                				VERT(VERT(neighbor[5])->vChild[0])->neighbor[3] = vChild[2];
                			VERT(vChild[2])->neighbor[8] = VERT(neighbor[5])->vChild[3];
                				VERT(VERT(neighbor[5])->vChild[3])->neighbor[0] = vChild[2];
                
                			VERT(vChild[5])->neighbor[2] = VERT(neighbor[5])->vChild[0];
                				VERT(VERT(neighbor[5])->vChild[0])->neighbor[6] = vChild[5];
                		}
                
                		if( vChild[8] )
                		{
                			VERT(vChild[8])->neighbor[5] = VERT(neighbor[5])->vChild[6];
                				VERT(VERT(neighbor[5])->vChild[6])->neighbor[3] = vChild[8];
                			VERT(vChild[8])->neighbor[2] = VERT(neighbor[5])->vChild[3];
                
                				VERT(VERT(neighbor[5])->vChild[3])->neighbor[6] = vChild[8];
                			VERT(vChild[5])->neighbor[8] = VERT(neighbor[5])->vChild[6];
                				VERT(VERT(neighbor[5])->vChild[6])->neighbor[0] = vChild[5];
                		}
                	}
                
                
                	// neighbor 6, a diagnal
                	if( neighbor[6] && neighbor[6]->isSplit )
                	{
                		VERT(vChild[6])->neighbor[6] = VERT(neighbor[6])->vChild[2];
                			VERT(VERT(neighbor[6])->vChild[2])->neighbor[2] = vChild[6];
                	}
                
                
                	// neighbor 7
                	if( neighbor[7] && neighbor[7]->isSplit )
                	{
                		// The straight edge.
                		VERT(vChild[7])->neighbor[7] = VERT(neighbor[7])->vChild[1];
                			VERT(VERT(neighbor[7])->vChild[1])->neighbor[1] = vChild[7];
                		// if the corner vChild exists, then we know we aren't hanging over an edge
                		if( vChild[8] )
                		{
                			VERT(vChild[8])->neighbor[7] = VERT(neighbor[7])->vChild[2];
                				VERT(VERT(neighbor[7])->vChild[2])->neighbor[1] = vChild[8];
                			VERT(vChild[8])->neighbor[6] = VERT(neighbor[7])->vChild[1];
                				VERT(VERT(neighbor[7])->vChild[1])->neighbor[2] = vChild[8];
                
                			VERT(vChild[7])->neighbor[8] = VERT(neighbor[7])->vChild[2];
                				VERT(VERT(neighbor[7])->vChild[2])->neighbor[0] = vChild[7];
                		}
                
                		if( vChild[6] )
                		{
                			VERT(vChild[6])->neighbor[7] = VERT(neighbor[7])->vChild[0];
                				VERT(VERT(neighbor[7])->vChild[0])->neighbor[1] = vChild[6];
                			VERT(vChild[6])->neighbor[8] = VERT(neighbor[7])->vChild[1];
                				VERT(VERT(neighbor[7])->vChild[1])->neighbor[0] = vChild[6];
                
                			VERT(vChild[7])->neighbor[6] = VERT(neighbor[7])->vChild[0];
                				VERT(VERT(neighbor[7])->vChild[0])->neighbor[2] = vChild[7];
                		}
                	}
                	// neighbor 8, a diagnal
                	if( neighbor[8] && neighbor[8]->isSplit )
                	{
                		VERT(vChild[8])->neighbor[8] = VERT(neighbor[8])->vChild[0];
                			//BUG!!! This line sometimes causes seg faults! (may be fixed)
                			VERT(VERT(neighbor[8])->vChild[0])->neighbor[0] = vChild[8];
                
                	}
                
                
                	return 0;
                }
                
                // If our neighbors dont exist, split the appropriate aunt until they do.
        1982 -> int Vertex::assertNeighborsSplit()
                {
                	switch( vChildNum )
                	{
                		case 0:
                			// corner verticies check 3 neighbors.
                			if( VERT(parent)->neighbor[3] && !VERT(parent)->neighbor[3]->isSplit )
                				VERT(parent)->neighbor[3]->split();
                			if( VERT(parent)->neighbor[0] && !VERT(parent)->neighbor[0]->isSplit )
                				VERT(parent)->neighbor[0]->split();
                			if( VERT(parent)->neighbor[1] && !VERT(parent)->neighbor[1]->isSplit )
                				VERT(parent)->neighbor[1]->split();
                		break;
                
                		case 1:
                			// side verticies only need to check 1 vertex.
                			if( VERT(parent)->neighbor[1] && !VERT(parent)->neighbor[1]->isSplit )
                				VERT(parent)->neighbor[1]->split();
                		break;
                
                		case 2:
                			if( VERT(parent)->neighbor[1] && !VERT(parent)->neighbor[1]->isSplit )
                				VERT(parent)->neighbor[1]->split();
                			if( VERT(parent)->neighbor[2] && !VERT(parent)->neighbor[2]->isSplit )
                				VERT(parent)->neighbor[2]->split();
                			if( VERT(parent)->neighbor[5] && !VERT(parent)->neighbor[5]->isSplit )
                				VERT(parent)->neighbor[5]->split();
                		break;
                
                		case 3:
                			if( VERT(parent)->neighbor[3] && !VERT(parent)->neighbor[3]->isSplit )
                				VERT(parent)->neighbor[3]->split();
                		break;
                
                		case 4:
                			// We're the middle vChild and all our neighbor are guarenteed to exist.
                			// Dont need to bother checking!
                		break;
                
                		case 5:
                			if( VERT(parent)->neighbor[5] && !VERT(parent)->neighbor[5]->isSplit )
                				VERT(parent)->neighbor[5]->split();
                		break;
                
                		case 6:
                			if( VERT(parent)->neighbor[3] && !VERT(parent)->neighbor[3]->isSplit )
                				VERT(parent)->neighbor[3]->split();
                			if( VERT(parent)->neighbor[6] && !VERT(parent)->neighbor[6]->isSplit )
                				VERT(parent)->neighbor[6]->split();
                			if( VERT(parent)->neighbor[7] && !VERT(parent)->neighbor[7]->isSplit )
                				VERT(parent)->neighbor[7]->split();
                		break;
                
                		case 7:
                			if( VERT(parent)->neighbor[7] && !VERT(parent)->neighbor[7]->isSplit )
                				VERT(parent)->neighbor[7]->split();
                		break;
                
                		case 8:
                			if( VERT(parent)->neighbor[5] && !VERT(parent)->neighbor[5]->isSplit )
                				VERT(parent)->neighbor[5]->split();
                			if( VERT(parent)->neighbor[7] && !VERT(parent)->neighbor[7]->isSplit )
                				VERT(parent)->neighbor[7]->split();
                			if( VERT(parent)->neighbor[8] && !VERT(parent)->neighbor[8]->isSplit )
                				VERT(parent)->neighbor[8]->split();
                		break;
                
                		case -1:
                			// We're the root vertex in the mesh. No need to split at this time.
                		break;
                
                		default:
                			cout << "vChildnum isn't from -1 to 7!" << endl;
                		break;
                
                	}
                
                	return 0;
                }
                
       17555 -> int Vertex::constructor( BaseEnt *inParent )
                {
                	isEdge = false;
                	isCorner = false;
                	vChildNum = -1;
                
                	for( int i=0; i<9; i++ )
                	{
                		vChild[i] = NULL;
                		neighbor[i] = NULL;
                	}
                
                	for( int i=0; i<NUM_AFFECT_VERTICIES; i++ )
                	{
                		affectVertex[i] = NULL;
                		affectAmount[i] = 0.0;
                	}
                	neighbor[4] = this;
                
                	// this morph vertex shouldn't really need to be initalized
                	morphVertex.initalize();
                	trueVertex.initalize();
                	startMorphVertex.initalize();
                
                	BaseEnt::constructor( inParent );
                	return 0;
                }
                
     1891384 -> void Vertex::draw()
                {
                #if( 0 )
                	if( !isSplit )
                		teapot();
                		//morphVertex.drawNormal( bound.radius );
                #endif
                    // Add the vertex to the vertexArrayList
                    
                    // TODO: change renderVertex so that it's data types
                    // match openGL's datatypes, then make the vertex array
                    // store instances of rendervertex. Everything will 
                    // work faster that way.
                    
                    Camera *cam = getFlandPtr()->camera;
                
                    vertexArrayIndex = vertexArray.size();
                    vertexArray.push_back( morphVertex );
                    vertexArray[vertexArrayIndex].x -= cam->x;
                    vertexArray[vertexArrayIndex].y -= cam->y;
                    vertexArray[vertexArrayIndex].z -= cam->z;
                
                	BaseEnt::draw();
                
                }
                
       ##### -> bool Vertex::canUnSplit()
                {
                	// do the normal checks first, if this dosn't work,
                	// there is no need to check further.
                	if( BaseEnt::canUnSplit() == false )
                		return false;
                
                	return true;
                
                }
                
                // This checks our neighbors to see if they are keeping us from un-spliting.
         111 -> bool Vertex::specialUnSplitCheck()
                {
                	// Macro to check a single vertex
                	#define CHECK_VERT( n, vc ) \
                		/* does his child keep us from spliting? */ \
                		if( VERT(neighbor[n])->vChild[vc] && VERT(neighbor[n])->vChild[vc]->isSplit ) \
                		{ \
                			/* try to un-split the child, */ \
                			VERT(neighbor[n])->vChild[vc]->recursiveUnSplit(); \
                			/* if it didn't work, the special check bails out with false. */ \
                			if( VERT(neighbor[n])->vChild[vc]->isSplit ) \
                				return false; \
                		}
                
                	// Make a macro to check a corner vertex
                	#define CHECK_CORNER( n, vc )	\
                		/* neighbor 0 */  \
                		if( neighbor[n] && neighbor[n]->isSplit ) \
                		{ \
                			CHECK_VERT( n, vc ) \
                		}
                
                	// Check a side. ( all three verticies )
                	#define CHECK_SIDE( n, vc1, vc2, vc3 ) \
                		if( neighbor[n] && neighbor[n]->isSplit )\
                		{\
                			if( VERT(neighbor[n])->vChild[vc1] ){ \
                				CHECK_VERT( n, vc1 ) }\
                			CHECK_VERT( n, vc2 )\
                			if( VERT(neighbor[n])->vChild[vc3] ){ \
                				CHECK_VERT( n, vc3 )}\
                		}
                
                	CHECK_CORNER( 0, 8 )
                	CHECK_CORNER( 2, 6 )
                	CHECK_CORNER( 6, 2 )
                	CHECK_CORNER( 8, 0 )
                
                	CHECK_SIDE( 1, 6, 7, 8 )
                	CHECK_SIDE( 5, 0, 3, 6 )
                	CHECK_SIDE( 7, 0, 1, 2 )
                	CHECK_SIDE( 3, 2, 5, 8 )
                
                	#undef CHECK_SIDE
                	#undef CHECK_CORNER
                	#undef CHECK_VERT
                	return true;
                }
                
         953 -> void Vertex::destructor( bool willDelete )
                {
                
                	// delete our children, rules and parent's references to us
                	BaseEnt::destructor( true );
                	// clear our neighbor's pointers to me
                
                	clearNeighborPointersToMe();
                
                	// and finally, if we're not being deleted by a child class (if one
                	// eventually exist) delete ourselves.
                	if( !willDelete )
                		reuse.tDelete( this );
                }
                
         953 -> void Vertex::clearNeighborPointersToMe()
                {
                	// TODO: this function could be optimized for speed by
                	// hard coding all the checks into it.
                	// loop through neighbors
                	for( int n=0; n<9; n++ )
                	{
                		// if the neighbor exist and he's not our sibling
                		if( neighbor[n] && neighbor[n]->parent != parent )
                		{
                			// loop through each of the neighbor's neighbors.
                			for( int nn=0; nn<9; nn++ )
                			{
                				if( VERT(neighbor[n])->neighbor[nn] == this )
                					VERT(neighbor[n])->neighbor[nn] = NULL;
                			}
                		}
                	}
                }
                
                ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                //////////////////////////////////////////////////// THE MESH STUFF ///////////////////////////////////////////////////
                
                
                // unused, remove.
                //int Vertex::drawTri( BaseEnt *b1, BaseEnt *b2, BaseEnt *b3, int triType )
                //{
                //	// This function draws the triangles in a triangle mesh recursively.
                //	// It is passed three verticies.
                //	// It is recursive, so if the verticies are split it will call itself
                //	// for each smaller triangle.
                //
                //	// tritype is either LEFT or RIGHT. LEFT is the top-left oriented triangle,
                //	// RIGHT is the bottom-right. This has to be specified because the child
                //	// indexes are different for left and right triangles.
                //
                //	if( triType == LEFT )
                //	{
                //		drawLeft( b1, b2, b3 );
                //	}
                //	if( triType == RIGHT )
                //	{
                //		drawRight( b1, b2, b3 );
                //	}
                //	return 0;
                //}
                
                //#define SPLIT_COLORS
                
      587681 -> int Vertex::drawLeft( BaseEnt* b1, BaseEnt* b2, BaseEnt* b3 )
                {
                	// Make baseEnt pointers and cast the verticies to them. For future use.
                	Vertex *v1, *v2, *v3;
                	v1 = dynamic_cast< Vertex* >( b1 );
                	v2 = dynamic_cast< Vertex* >( b2 );
                	v3 = dynamic_cast< Vertex* >( b3 );
                
                	// Note: there are 8 possible combinations of split and un-split vertexes.
                	int combination;
                	// Create an int with the correct combination number.
                	combination = (int)v1->isSplit + (int)v2->isSplit*2 + (int)v3->isSplit*4;
                	switch( combination )
                	{
                		case 0:
                			// white
                			#ifdef SPLIT_COLORS
                			glColor3f( 1.0, 1.0, 1.0 );
                			#endif
                //            glBegin( GL_TRIANGLES );
                
                			v1->addIndexToVertexArrayIndexList();
                			v2->addIndexToVertexArrayIndexList();
                			v3->addIndexToVertexArrayIndexList();
                //            glEnd();
                		break;
                
                		case 1:
                			// red
                			#ifdef SPLIT_COLORS
                			glColor3f( 1.0, 0.0, 0.0 );
                			#endif
                
                			//glBegin( GL_TRIANGLE_FAN );
                				v1->vChild[2]->addIndexToVertexArrayIndexList();
                				v1->vChild[1]->addIndexToVertexArrayIndexList();
                				v2->addIndexToVertexArrayIndexList();
                
                				v1->vChild[2]->addIndexToVertexArrayIndexList();
                				v2->addIndexToVertexArrayIndexList();
                				v3->addIndexToVertexArrayIndexList();
                				
                				v1->vChild[2]->addIndexToVertexArrayIndexList();
                				v3->addIndexToVertexArrayIndexList();
                                v1->vChild[2]->addIndexToVertexArrayIndexList();
                			//glEnd();
                			drawLeft( v1->vChild[4], v1->vChild[1], v1->vChild[2] );
                		break;
                
                		case 2:
                			// orange
                			#ifdef SPLIT_COLORS
                			glColor3f( 1.0, 0.5, 0.0 );
                			#endif
                
                			//glBegin( GL_TRIANGLE_FAN );
                				v2->vChild[8]->addIndexToVertexArrayIndexList();
                				v2->vChild[5]->addIndexToVertexArrayIndexList();
                				v3->addIndexToVertexArrayIndexList();
                
                				v2->vChild[8]->addIndexToVertexArrayIndexList();
                				v3->addIndexToVertexArrayIndexList();
                				v1->addIndexToVertexArrayIndexList();
                				
                				v2->vChild[8]->addIndexToVertexArrayIndexList();
                				v1->addIndexToVertexArrayIndexList();
                                v2->vChild[7]->addIndexToVertexArrayIndexList();
                				
                				v2->vChild[8]->addIndexToVertexArrayIndexList();
                                v2->vChild[7]->addIndexToVertexArrayIndexList();
                                v2->vChild[5]->addIndexToVertexArrayIndexList();
                			//glEnd();
                
                			// call the recursive function
                			drawLeft( v2->vChild[7], v2->vChild[4], v2->vChild[5] );
                		break;
                
                		case 3:
                			// yellow
                			#ifdef SPLIT_COLORS
                			glColor3f( 1.0, 1.0, 0.0 );
                			#endif
                
                //            glBegin( GL_TRIANGLE_FAN );
                				v2->vChild[8]->addIndexToVertexArrayIndexList();
                				v2->vChild[5]->addIndexToVertexArrayIndexList();
                				v3->addIndexToVertexArrayIndexList();
                
                				v2->vChild[8]->addIndexToVertexArrayIndexList();
                				v3->addIndexToVertexArrayIndexList();
                				v1->vChild[2]->addIndexToVertexArrayIndexList();
                				
                				v2->vChild[8]->addIndexToVertexArrayIndexList();
                				v1->vChild[2]->addIndexToVertexArrayIndexList();
                                v2->vChild[8]->addIndexToVertexArrayIndexList();
                //            glEnd();
                
                			drawLeft( v1->vChild[4], v1->vChild[1], v1->vChild[2] );
                			drawLeft( v1->vChild[1], v2->vChild[7], v2->vChild[8] );
                			drawLeft( v2->vChild[7], v2->vChild[4], v2->vChild[5] );
                
                			drawRight( v2->vChild[8], v1->vChild[2], v1->vChild[1] );
                			drawRight( v2->vChild[5], v2->vChild[8], v2->vChild[7] );
                		break;
                
                		case 4:
                			// green
                			#ifdef SPLIT_COLORS
                			glColor3f( 0.0, 1.0, 0.0 );
                			#endif
                
                //            glBegin( GL_TRIANGLE_FAN );
                				v3->vChild[6]->addIndexToVertexArrayIndexList();
                				v1->addIndexToVertexArrayIndexList();
                				v2->addIndexToVertexArrayIndexList();
                
                				v3->vChild[6]->addIndexToVertexArrayIndexList();
                				v2->addIndexToVertexArrayIndexList();
                				v3->vChild[3]->addIndexToVertexArrayIndexList();
                				
                				v3->vChild[6]->addIndexToVertexArrayIndexList();
                				v3->vChild[3]->addIndexToVertexArrayIndexList();
                                v3->vChild[6]->addIndexToVertexArrayIndexList();
                //            glEnd();
                			drawLeft( v3->vChild[6], v3->vChild[3], v3->vChild[4] );
                		break;
                
                		case 5:
                			// blue
                			#ifdef SPLIT_COLORS
                			glColor3f( 0.0, 0.0, 1.0 );
                			#endif
                
                //            glBegin( GL_TRIANGLE_FAN );
                				v2->addIndexToVertexArrayIndexList();
                				v3->vChild[3]->addIndexToVertexArrayIndexList();
                				v3->vChild[6]->addIndexToVertexArrayIndexList();
                				
                				v2->addIndexToVertexArrayIndexList();
                				v3->vChild[6]->addIndexToVertexArrayIndexList();
                                v1->vChild[2]->addIndexToVertexArrayIndexList();
                
                				v2->addIndexToVertexArrayIndexList();
                                v1->vChild[2]->addIndexToVertexArrayIndexList();
                				v1->vChild[1]->addIndexToVertexArrayIndexList();
                //            glEnd();
                			drawLeft( v1->vChild[4], v1->vChild[1], v1->vChild[2] );
                			drawLeft( v3->vChild[6], v3->vChild[3], v3->vChild[4] );
                		break;
                
                		case 6:
                			// purple
                			#ifdef SPLIT_COLORS
                			glColor3f( 0.7, 0.1, 1.0 );
                			#endif
                
                //            glBegin( GL_TRIANGLE_FAN );
                				v2->vChild[8]->addIndexToVertexArrayIndexList();
                				v3->vChild[6]->addIndexToVertexArrayIndexList();
                				v1->addIndexToVertexArrayIndexList();
                				
                				v2->vChild[8]->addIndexToVertexArrayIndexList();
                				v1->addIndexToVertexArrayIndexList();
                                v2->vChild[7]->addIndexToVertexArrayIndexList();
                
                				v2->vChild[8]->addIndexToVertexArrayIndexList();
                                v2->vChild[7]->addIndexToVertexArrayIndexList();
                				v2->vChild[8]->addIndexToVertexArrayIndexList();
                //            glEnd();
                
                			drawLeft( v2->vChild[7], v2->vChild[4], v2->vChild[5] );
                			drawLeft( v2->vChild[8], v2->vChild[5], v3->vChild[3] );
                			drawLeft( v3->vChild[6], v3->vChild[3], v3->vChild[4] );
                
                			drawRight( v2->vChild[5], v2->vChild[8], v2->vChild[7] );
                			drawRight( v3->vChild[3], v3->vChild[6], v2->vChild[8] );
                		break;
                
                		case 7:
                			// None are drawn here, call the recursive functions!
                			// draw the left ones
                			drawLeft( v1->vChild[4], v1->vChild[1], v1->vChild[2] );
                			drawLeft( v1->vChild[1], v2->vChild[7], v2->vChild[8] );
                			drawLeft( v2->vChild[7], v2->vChild[4], v2->vChild[5] );
                			drawLeft( v1->vChild[2], v2->vChild[8], v3->vChild[6] );
                			drawLeft( v2->vChild[8], v2->vChild[5], v3->vChild[3] );
                			drawLeft( v3->vChild[6], v3->vChild[3], v3->vChild[4] );
                
                			// draw the right ones
                			drawRight( v2->vChild[8], v1->vChild[2], v1->vChild[1] );
                			drawRight( v2->vChild[5], v2->vChild[8], v2->vChild[7] );
                			drawRight( v3->vChild[3], v3->vChild[6], v2->vChild[8] );
                
                		break;
                
                		default:
                			cout << "Combination chooser is broken! Switch statement defaulted!" << endl;
                			LN
                			break;
                	}
                
                	return 0;
                }
                
      606086 -> int Vertex::drawRight( BaseEnt* b1, BaseEnt* b2, BaseEnt* b3 )
                {
                	// Make baseEnt pointers and cast the verticies to them. For future use.
                	Vertex *v1, *v2, *v3;
                	v1 = dynamic_cast< Vertex* >( b1 );
                	v2 = dynamic_cast< Vertex* >( b2 );
                	v3 = dynamic_cast< Vertex* >( b3 );
                
                	// Note: there are 8 possible combinations of split and un-split vertexes.
                	int combination;
                	// Create an int with the correct combination number.
                	combination = (int)v1->isSplit + (int)v2->isSplit*2 + (int)v3->isSplit*4;
                
                	switch( combination )
                	{
                	case 0:
                			// white
                			#ifdef SPLIT_COLORS
                			glColor3f( 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0 );
                			#endif
                
                //            glBegin( GL_TRIANGLES );
                			v1->addIndexToVertexArrayIndexList();
                			v2->addIndexToVertexArrayIndexList();
                			v3->addIndexToVertexArrayIndexList();
                //            glEnd();
                		break;
                
                		case 1:
                			// red
                			#ifdef SPLIT_COLORS
                			glColor3f( 1.0 / 2.0, 0.0 / 2.0, 0.0 / 2.0 );
                			#endif
                
                //            glBegin( GL_TRIANGLE_FAN );
                				v1->vChild[6]->addIndexToVertexArrayIndexList();
                				v1->vChild[7]->addIndexToVertexArrayIndexList();
                				v2->addIndexToVertexArrayIndexList();
                				
                				v1->vChild[6]->addIndexToVertexArrayIndexList();
                				v2->addIndexToVertexArrayIndexList();
                                v3->addIndexToVertexArrayIndexList();
                
                				v1->vChild[6]->addIndexToVertexArrayIndexList();
                                v3->addIndexToVertexArrayIndexList();
                				v1->vChild[6]->addIndexToVertexArrayIndexList();
                //            glEnd();
                			drawRight( v1->vChild[4], v1->vChild[7], v1->vChild[6] );
                		break;
                
                		case 2:
                			// orange
                			#ifdef SPLIT_COLORS
                			glColor3f( 1.0 / 2.0, 0.5 / 2.0, 0.0 / 2.0 );
                			#endif
                
                //            glBegin( GL_TRIANGLE_FAN );
                				v2->vChild[0]->addIndexToVertexArrayIndexList();
                				v2->vChild[3]->addIndexToVertexArrayIndexList();
                				v3->addIndexToVertexArrayIndexList();
                
                				v2->vChild[0]->addIndexToVertexArrayIndexList();
                				v3->addIndexToVertexArrayIndexList();
                				v1->addIndexToVertexArrayIndexList();
                				
                				v2->vChild[0]->addIndexToVertexArrayIndexList();
                				v1->addIndexToVertexArrayIndexList();
                                v2->vChild[1]->addIndexToVertexArrayIndexList();
                				
                				v2->vChild[0]->addIndexToVertexArrayIndexList();
                                v2->vChild[1]->addIndexToVertexArrayIndexList();
                                v2->vChild[3]->addIndexToVertexArrayIndexList();
                //            glEnd();
                
                			// call the recursive function
                			drawRight( v2->vChild[1], v2->vChild[4], v2->vChild[3] );
                		break;
                
                		case 3:
                			// yellow
                			#ifdef SPLIT_COLORS
                			glColor3f( 1.0 / 2.0, 1.0 / 2.0, 0.0 / 2.0 );
                			#endif
                
                //            glBegin( GL_TRIANGLE_FAN );
                				v2->vChild[0]->addIndexToVertexArrayIndexList();
                				v2->vChild[3]->addIndexToVertexArrayIndexList();
                				v3->addIndexToVertexArrayIndexList();
                				
                				v2->vChild[0]->addIndexToVertexArrayIndexList();
                				v3->addIndexToVertexArrayIndexList();
                                v1->vChild[6]->addIndexToVertexArrayIndexList();
                
                				v2->vChild[0]->addIndexToVertexArrayIndexList();
                                v1->vChild[6]->addIndexToVertexArrayIndexList();
                				v2->vChild[0]->addIndexToVertexArrayIndexList();
                //            glEnd();
                
                			drawRight( v1->vChild[4], v1->vChild[7], v1->vChild[6] );
                			drawRight( v1->vChild[7], v2->vChild[1], v2->vChild[0] );
                			drawRight( v2->vChild[1], v2->vChild[4], v2->vChild[3] );
                
                			drawLeft( v2->vChild[0], v1->vChild[6], v1->vChild[7] );
                			drawLeft( v2->vChild[3], v2->vChild[0], v2->vChild[1] );
                		break;
                
                		case 4:
                			// green
                			#ifdef SPLIT_COLORS
                			glColor3f( 0.0 / 2.0, 1.0 / 2.0, 0.0 / 2.0 );
                			#endif
                
                //            glBegin( GL_TRIANGLE_FAN );
                				v3->vChild[2]->addIndexToVertexArrayIndexList();
                				v1->addIndexToVertexArrayIndexList();
                				v2->addIndexToVertexArrayIndexList();
                				
                				v3->vChild[2]->addIndexToVertexArrayIndexList();
                				v2->addIndexToVertexArrayIndexList();
                                v3->vChild[5]->addIndexToVertexArrayIndexList();
                
                				v3->vChild[2]->addIndexToVertexArrayIndexList();
                                v3->vChild[5]->addIndexToVertexArrayIndexList();
                				v3->vChild[2]->addIndexToVertexArrayIndexList();
                //            glEnd();
                			drawRight( v3->vChild[2], v3->vChild[5], v3->vChild[4] );
                		break;
                
                		case 5:
                			// blue
                			#ifdef SPLIT_COLORS
                			glColor3f( 0.0 / 2.0, 0.0 / 2.0, 1.0 / 2.0 );
                			#endif
                
                //            glBegin( GL_TRIANGLE_FAN );
                				v2->addIndexToVertexArrayIndexList();
                				v3->vChild[5]->addIndexToVertexArrayIndexList();
                				v3->vChild[2]->addIndexToVertexArrayIndexList();
                
                				v2->addIndexToVertexArrayIndexList();
                				v3->vChild[2]->addIndexToVertexArrayIndexList();
                				v1->vChild[6]->addIndexToVertexArrayIndexList();
                				
                				v2->addIndexToVertexArrayIndexList();
                				v1->vChild[6]->addIndexToVertexArrayIndexList();
                                v1->vChild[7]->addIndexToVertexArrayIndexList();
                //            glEnd();
                			drawRight( v1->vChild[4], v1->vChild[7], v1->vChild[6] );
                			drawRight( v3->vChild[2], v3->vChild[5], v3->vChild[4] );
                		break;
                
                		case 6:
                			// purple
                			#ifdef SPLIT_COLORS
                			glColor3f( 0.0 / 7.0, 0.0 / 2.0, 1.0 / 2.0 );
                			#endif
                
                //            glBegin( GL_TRIANGLE_FAN );
                				v2->vChild[0]->addIndexToVertexArrayIndexList();
                				v3->vChild[2]->addIndexToVertexArrayIndexList();
                				v1->addIndexToVertexArrayIndexList();
                				
                				v2->vChild[0]->addIndexToVertexArrayIndexList();
                				v1->addIndexToVertexArrayIndexList();
                                v2->vChild[1]->addIndexToVertexArrayIndexList();
                
                				v2->vChild[0]->addIndexToVertexArrayIndexList();
                                v2->vChild[1]->addIndexToVertexArrayIndexList();
                				v2->vChild[0]->addIndexToVertexArrayIndexList();
                //            glEnd();
                
                			drawRight( v3->vChild[2], v3->vChild[5], v3->vChild[4] );
                			drawRight( v2->vChild[0], v2->vChild[3], v3->vChild[5] );
                			drawRight( v2->vChild[1], v2->vChild[4], v2->vChild[3] );
                
                			drawLeft( v3->vChild[5], v3->vChild[2], v2->vChild[0] );
                			drawLeft( v2->vChild[3], v2->vChild[0], v2->vChild[1] );
                		break;
                
                		case 7:
                			// None are drawn here, call the recursive functions!
                			// draw the left ones
                			drawRight( v1->vChild[4], v1->vChild[7], v1->vChild[6] );
                			drawRight( v1->vChild[7], v2->vChild[1], v2->vChild[0] );
                			drawRight( v2->vChild[1], v2->vChild[4], v2->vChild[3] );
                			drawRight( v1->vChild[6], v2->vChild[0], v3->vChild[2] );
                			drawRight( v2->vChild[0], v2->vChild[3], v3->vChild[5] );
                			drawRight( v3->vChild[2], v3->vChild[5], v3->vChild[4] );
                
                			// draw the right ones
                			drawLeft( v2->vChild[0], v1->vChild[6], v1->vChild[7] );
                			drawLeft( v2->vChild[3], v2->vChild[0], v2->vChild[1] );
                			drawLeft( v3->vChild[5], v3->vChild[2], v2->vChild[0] );
                		break;
                
                		default:
                			cout << "Combination chooser is broken! Switch statement defaulted!" << endl;
                			LN
                			break;
                	}
                	return 0;
           1 -> }
           1 -> 
                #endif


Top 10 Lines:

     Line      Count

       62    5461930
      782    1891384
      192    1678396
     1137     606086
      933     587681
      754      17555
      121       1982
      145       1982
      213       1982
      292       1982

Execution Summary:

       25   Executable lines in this file
       25   Lines executed
   100.00   Percent of the file executed

 10258925   Total number of line executions
410357.00   Average executions per line


*** File /home/tyler/Desktop/fland2/tyler.cpp:
                #ifndef _TYLER_CPP
                #define _TYLER_CPP
                
                #include <iostream>
                #include <math.h>
                #include <stdlib.h>
                #include <string>
                #include "tyler.h"
                
                using namespace std;
                
                
                
                // indent - pass an int, it returns a string of that many indents
       ##### -> string indent( int num )
                {
                	string s;
                	for( int i=0; i<num; i++ )
                		{ s += "."; }
                	return s;
                }
                
                // PrintBool Pass a bool to this function before printing it
       ##### -> string pBool( bool inVal )
                {
                	if( inVal )
                		return "true";
                	else
                		return "false";
                }
                
                // assign a string value to a bool
       ##### -> void aBool( string val, bool& b )
                {
                	if( val == "" || val == "0" || val == "false" )
                		b = false;
                	else
                		b = true;
                }
                
                
       17555 -> Color::Color()
                {
                	red = green = blue = 0.0;
                }
                
                
                // THIS STUFF WOULD GO IN THE .CPP FILE
       ##### -> Point3D::Point3D()
                {
                	x = 0;
                	y = 0;
                	z = 0;
                }
                
       ##### -> Point3D::Point3D( double ix, double iy, double iz )
                {
                	x = ix;
                	y = iy;
                	z = iz;
                }
                
                // For debug purposes
                #include <ctime>
                
       ##### -> void pause( int x ){
                	double startPauseTime=time( 0 );
                	while( time( 0 ) < startPauseTime + x ){}
           1 -> }
           1 -> 
                
                #endif


Top 10 Lines:

     Line      Count

       42      17555
       69          1
       70          1

Execution Summary:

        9   Executable lines in this file
        9   Lines executed
   100.00   Percent of the file executed

    17557   Total number of line executions
  1950.78   Average executions per line


*** File /home/tyler/Desktop/fland2/roughr.cpp:
                #ifndef ROUGHR_CPP
                #define ROUGHR_CPP
                
                // This rule applies to verticies. Moves them up or down to make
                // a rough, mountainous terrain.
                // a meRule
                
                using namespace std;
                
                #include <sstream>
                #include "tyler.h"
                #include "vertex.h"
                #include "baserule.h"
                #include "templates.h"
                #include "roughr.h"
                
                
           9 -> string RoughR::assignValue( string valueType, istringstream *value, FmlParser* fPtr )
                {
                	if( valueType == "roughness" )
                	{
                		 *value >> roughness;
                	}
                    else if( valueType == "uppull" )
                	{
                		 *value >> upPull;
                	}
                	else
                	{
                		return BaseRule::assignValue( valueType, value, fPtr );
                	}
                	return "";
                }
                
           5 -> RoughR::RoughR():BaseRule()
                {
                	roughness = 0.3;
                    upPull = 0.0;
                }
                
       13726 -> void RoughR::goCalcMe( BaseEnt* inClient, intensityType runIntensity )
                {
                
                	runIntensity *= intensity;
                
                //    cout << upPull << endl;LN
                	double randAmount = ( roughness * 2.0 * ( rnd() - 0.5 ) + upPull ) * VERT(inClient)->bound.radius * runIntensity;
                
                	VERT(inClient)->trueVertex.x += ( randAmount * VERT(inClient)->trueVertex.nx );
                	VERT(inClient)->trueVertex.y += ( randAmount * VERT(inClient)->trueVertex.ny );
                	VERT(inClient)->trueVertex.z += ( randAmount * VERT(inClient)->trueVertex.nz );
                
           1 -> }
           1 -> 
                
                
                
                #endif


Top 10 Lines:

     Line      Count

       41      13726
       18          9
       35          5
       53          1
       54          1

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

    13742   Total number of line executions
  2748.40   Average executions per line


*** File /home/tyler/Desktop/fland2/rendervertex.cpp:
                // Render Vertex. An object that is drawn onscreen.
                #ifndef RENDER_VERTEX_CPP
                #define RENDER_VERTEX_CPP
                
                using namespace std;
                
                #include <GL/glut.h>
                #include <math.h>
                #include <iomanip>
                #include <sstream>
                #include <math.h>
                #include "tyler.h"
                #include "camera.h"
                #include "fland.h"
                #include "rendervertex.h"
                #include "glutenv.h"
                
                
       18602 -> BoundSphere::BoundSphere()
                {
                	initalize();
                }
                
                // An example of how to use project-wide global variables.
                // the keyword 'extern' here tells the compiler not to allocate
                // memory for these vars because they are defined elsewhere.
                extern vector<RenderVertex> vertexArray;
                extern vector<GLuint> vertexArrayIndex;
                
                //void RenderVertex::printVertex()
                //{
                //    Camera *cam = getFlandPtr()->camera;
                
                //    glColor3f( red, green, blue );
                //    glNormal3f( nx, ny, nz );
                //    glVertex3d( x - cam->x, y - cam->y, z - cam->z );
                
                //    int i = vertexArray.size();
                //}
                
       ##### -> string RenderVertex::toString( int depth )
                {
                	ostringstream out;
                	string ind = indent( depth );
                		//cout.setf( ios::fixed );
                		out
                		<< ind << "  RenderVertex::"
                		<< ind << "\tx: " << x
                		<< ind << "\ty: " << y
                		<< ind << "\tz: " << z
                        << ind << "\n\t  nx      " << nx
                        << ind << "\n\t  ny      " << ny
                        << ind << "\n\t  nz      " << nz
                        << ind << "\n\t  red     " << red
                        << ind << "\n\t  green   " << green
                        << ind << "\n\t  blue    " << blue
                        << ind << endl
                		;
                	return out.str();
                }
                
       96524 -> RenderVertex::RenderVertex()
                {
                	initalize();
           1 -> };
           1 -> 
                //void RenderVertex::operator=( const RenderVertex& ir )
                //{
                //	x = ir.x;
                //	y = ir.y;
                //	z = ir.z;
                //	red = ir.red;
                //	green = ir.green;
                //	blue = ir.blue;
                //	nx = ir.nx;
                //	ny = ir.ny;
                //	nz = ir.nz;
                //
                //	if( abs( x ) > 0.7 || abs( z ) > 0.7 )
                //		{ cout << toString(0);LN }
                //}
                
                
                
                #endif


Top 10 Lines:

     Line      Count

       62      96524
       19      18602
       65          1
       66          1

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

   115128   Total number of line executions
 23025.60   Average executions per line


*** File /home/tyler/Desktop/fland2/meshseed.cpp:
                #ifndef MESHSEED_CPP
                #define MESHSEED_CPP
                
                #include <cassert>
                #include <GL/glut.h>
                #include "meshseed.h"
                #include "defines.h"
                #include "tyler.h"
                #include "defines.h"
                #include "glutenv.h"
                #include "fland.h"
                
       ##### -> Reuse< BaseEnt, MeshSeed >MeshSeed::reuse;
                
           1 -> void MeshSeed::setMeshParams( QUARD_TYPE ix, QUARD_TYPE iy, QUARD_TYPE iz, DIS_TYPE isize )
                {
                	x = bound.x = ix;
                	y = bound.y = iy;
                	z = bound.z = iz;
                	size = bound.radius = isize;
                }
                
                
           1 -> void MeshSeed::split()
                {
                	for( int i=0; i<4; i++ )
                	{
                		Vertex* vert = VERT( Vertex::reuse.tNew( this ) );
                		vChild[i] = vert;
                		child.push_back( vert );
                
                		// so the bound radius will extend and overlap the opposite corner vertex.
                		vert->bound.radius = size * 1.5;
                		vert->trueVertex.nz = 1.0; // BUG: TODO: this normal should be positive? what is my quardinate system?
                
                		// NOTE: this is where the inital properties are set.
                		vert->trueVertex.red   = 1.0;
                		vert->trueVertex.green = 1.0;
                		vert->trueVertex.blue  = 1.0;
                	}
                	attachVertexNeighbors();
                
                	// Set the quardinates of the verticies.
                	VERT(vChild[0])->trueVertex.x = x - size * 0.5;
                	VERT(vChild[0])->trueVertex.y = y;
                	VERT(vChild[0])->trueVertex.z = z - size * 0.5;
                
                	VERT(vChild[1])->trueVertex.x = x + size * 0.5;
                	VERT(vChild[1])->trueVertex.y = y;
                	VERT(vChild[1])->trueVertex.z = z - size * 0.5;
                
                	VERT(vChild[2])->trueVertex.x = x - size * 0.5;
                	VERT(vChild[2])->trueVertex.y = y;
                	VERT(vChild[2])->trueVertex.z = z + size * 0.5;
                
                	VERT(vChild[3])->trueVertex.x = x + size * 0.5;
                	VERT(vChild[3])->trueVertex.y = y;
                	VERT(vChild[3])->trueVertex.z = z + size * 0.5;
                
                	VERT(vChild[0])->startMorphVertex = VERT(vChild[0])->trueVertex;
                	VERT(vChild[1])->startMorphVertex = VERT(vChild[1])->trueVertex;
                	VERT(vChild[2])->startMorphVertex = VERT(vChild[2])->trueVertex;
                	VERT(vChild[3])->startMorphVertex = VERT(vChild[3])->trueVertex;
                
                	BaseEnt::split();
                }
                
           1 -> int MeshSeed::constructor( BaseEnt *parent )
                {
                	for( int i=0; i<4; i++ )
                		vChild[i] = NULL;
                	x = y = z = 0.0;
                	size = 0.0;
                	BaseEnt::constructor( parent );
                }
                
       ##### -> void MeshSeed::destructor( bool willDelete )
                {
                	for( int i=0; i<4; i++ )
                		vChild[i] = NULL;
                	// delete our children, rules and parent's references to us
                	BaseEnt::destructor( true );
                
                	// and finally, if we're not being deleted by a child class (if one
                	// eventually exist) delete ourselves.
                	if( !willDelete )
                		reuse.tDelete( this );
                }
                
                
       ##### -> bool MeshSeed::specialUnSplitCheck()
                {
                	// cant be unsplit (i think thats what false means)
                	return false;
                	//return true;
                }
                
           1 -> void MeshSeed::attachVertexNeighbors()
                {
                  // point the verticies at thier neighbors.
                	vChild[0]->neighbor[4] = vChild[0];
                	vChild[0]->neighbor[5] = vChild[1];
                	vChild[0]->neighbor[7] = vChild[2];
                	vChild[0]->neighbor[8] = vChild[3];
                
                	vChild[1]->neighbor[4] = vChild[1];
                	vChild[1]->neighbor[3] = vChild[0];
                	vChild[1]->neighbor[6] = vChild[2];
                	vChild[1]->neighbor[7] = vChild[3];
                
                	vChild[2]->neighbor[4] = vChild[2];
                	vChild[2]->neighbor[1] = vChild[0];
                	vChild[2]->neighbor[2] = vChild[1];
                	vChild[2]->neighbor[5] = vChild[3];
                
                	vChild[3]->neighbor[4] = vChild[3];
                	vChild[3]->neighbor[0] = vChild[0];
                	vChild[3]->neighbor[1] = vChild[1];
                	vChild[3]->neighbor[3] = vChild[2];
                }
                
         306 -> void MeshSeed::draw()
                {
                	//cout << "drawmesh";
                
                	// make sure the verticies exist before we try to reference them.
                	// to avoid seg faults.
                
                	if( isSplit )
                	{
                
                		sassert( vChild[0] );
                		sassert( vChild[1] );
                		sassert( vChild[2] );
                		sassert( vChild[3] );
                
                        // refresh the vertexArray to contain valid data of every vertex object
                        vertexArray.clear();
                        vertexArrayIndexList.clear();
                
                		// pass the draw message down the line.
                		BaseEnt::draw();
                
                		vChild[0]->drawLeft( vChild[2],
                						vChild[0],
                						vChild[1] );
                		vChild[0]->drawRight( VERT( vChild[1] ),
                					VERT( vChild[3] ),
                					VERT( vChild[2] ) );
                
                		//VERT( vChild[0] )->teapot();
                		//VERT( vChild[1] )->teapot();
                		//VERT( vChild[2] )->teapot();
                		//VERT( vChild[3] )->teapot();
                
                
                        glVertexPointer(    3,
                                            GL_FLOAT,
                                            sizeof(RenderVertex),
                                            &vertexArray[0].x
                                        );
                        glColorPointer(     3,
                                            GL_FLOAT,
                                            sizeof(RenderVertex),
                                            &vertexArray[0].red
                                        );
                        glNormalPointer(    GL_FLOAT,
                                            sizeof(RenderVertex),
                                            &vertexArray[0].nx
                                        );
                        glDrawElements( GL_TRIANGLES,
                                        vertexArrayIndexList.size(),
                                        GL_UNSIGNED_INT,
                                        &vertexArrayIndexList[0]
                                );
                	}
                	else
                	{
                		//drawSphere( x - Fland::fland->camera->x, y - Fland::fland->camera->y, z - Fland::fland->camera->z, size );
                	}
                
                }
                
       ##### -> void MeshSeed::unSplit()
                {
                	BaseEnt::unSplit();
                	for( int i=0; i<4; i++ )
                		vChild[i] = NULL;
           1 -> }
           1 -> 
                #endif
                


Top 10 Lines:

     Line      Count

      122        306
       15          1
       24          1
       68          1
       98          1
      189          1
      190          1

Execution Summary:

       11   Executable lines in this file
       11   Lines executed
   100.00   Percent of the file executed

      312   Total number of line executions
    28.36   Average executions per line


*** File /home/tyler/Desktop/fland2/main.cpp:
                #ifndef MAIN_CPP
                #define MAIN_CPP
                // the tester program. Fland will have an interface and can be used in any program.
                // compile it like this:
                // tclear; g++ main.cpp -lGL -lGLU -lglut -ofland2
                // NOTE: tclear is not necessary, it just clears the screen.
                
                // NOTE: a perl script will insert the statements to include the other cpp files here.
                // <START_CPP_INCLUES>
                		// these files are now written to includecpps.cpp.
                // <END_CPP_INCLUDES>
                
                using namespace std;
                
                #include <iostream>
                #include <fstream>
                // this must come before globals because globals uses it.
                #include "defines.h"
                #include "main.h"
                #include "camera.h"
                
                
                
                // callback functions for event handling.
                #include "events.h"
                // the functions glut calls
                #include "glutenv.h"
                
                #include "fland.h"
                
                
                
                // application enters here
       ##### -> int main(int argc, char** argv)
                {
                	// this is in glutenv.cpp
                	initEnv(argc, argv);
                	return 0;
                }
                
                // Called by the event system after the window and callback functions
                // are all set up.
           1 -> int initProgram()
                {
                	new Fland( 1 );
                	return 0;
                }
                
                // Called by the event system each frame.
         306 -> int mainLoop()
                {
                	gRepeatKeys(); // in events.h
                	getFlandPtr()->fland->recalculateView();
                	getFlandPtr()->fland->draw();
                
                	return 0;
                }
                
                // called by the event system when the exit event gets called.
           1 -> int closeProgram()
                {
                	delete Fland::fland;
                	cout << "Done\n\n" << TEST_MESSAGE;
                	exit( 0 );
                	// the program never gets here.
                	return 0;
                }
                
       ##### -> void resetFland( int seed )
                {
                	Camera cam;
                	cam = *(Fland::fland->camera);
                	delete Fland::fland;
                	new Fland( seed );
                	*(Fland::fland->camera) = cam;
                
           1 -> }
           1 -> 
                
                #endif
                


Top 10 Lines:

     Line      Count

       50        306
       43          1
       60          1
       77          1
       78          1

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

      310   Total number of line executions
    44.29   Average executions per line


*** File /home/tyler/Desktop/fland2/groupr.cpp:
                #ifndef GROUPR_CPP
                #define GROUPR_CPP
                
                
                using namespace std;
                #include <sstream>
                #include <cassert>
                
                #include "groupr.h"
                #include "tyler.h"
                #include "defines.h"
                #include "fmlparser.h"
                #include "baseent.h"
                
                
                #if( DEBUG )
       ##### -> string GroupR::toString( int depth = 0 )
                {
                	string ind = indent( depth );
                	ostringstream out;
                
                	out
                		<< ind << "(GroupR)" << endl
                		<< BaseRule::toString( depth )
                		<< ind << "GroupR::" << endl
                		<< ind << "Size              " << this->size() << endl
                		<< ind << "Members:" << endl
                	;
                	for( int i=0; i<this->size(); i++ )
                	{
                		out << groupMember[i]->toString( depth + 4 );
                	}
                	return out.str();
                }
                
                
                #endif
                
                
          46 -> string GroupR::assignValue( string valueType, istringstream *value, FmlParser* fPtr )
                {
                	if( valueType == "groupmember" )
                	{
                		BaseRule* temp;
                		temp = fPtr->nameMap[ value->str() ];
                		addGroupMember( temp );
                		//cout << fPtr->nameMap[ value->str() ];LN
                	}
                	else
                	{
                		return BaseRule::assignValue( valueType, value, fPtr );
                	}
                	return "";
                }
                
          26 -> void GroupR::addGroupMember( BaseRule* inPtr )
                {
                	addRule( inPtr );
                	//push_back( inPtr );
                }
                
                // this function is called on a groupr when it's client is being split.
                //It returns a pointer to the new rule that the new entity should have.
        1763 -> void GroupR::propogateChildren( BaseEnt* newEnt, intensityType inIntensity )
                {
                	if( childRule )
                	{
                		BaseRule::propogateChildren( newEnt, inIntensity );
                	}
                	else
                	{
                		// loop through each groupmember and insert her  or her child
                		// depending on if the groupmember has a numPropogates > 0
                		for( int i=0; i<size(); i++ )
                		{
                			groupMember[i]->propogateRules( newEnt, groupMember[i]->numPropogates, inIntensity );
                		}
                	}
                }
                
       ##### -> void GroupR::destructor( bool willDelete )
                {
                
                	BaseRule::destructor( true );
                }
                
       37067 -> void GroupR::goCalcMe( BaseEnt *inClient, intensityType runIntensity )
                {
                	sassert( inClient );
                
                	sassert( (runIntensity >= 0.0 && runIntensity <= 1.01) );
                
                	for( int i=0; i<size(); ++i )
                	{
                		groupMember[i]->goCalcMe( inClient, runIntensity * intensity );
                	}
                }
                
                
          15 -> GroupR::GroupR():BaseRule()
                {
                	groupMember.clear();
           1 -> }
           1 -> 
                #endif


Top 10 Lines:

     Line      Count

       87      37067
       64       1763
       40         46
       56         26
      100         15
      103          1
      104          1

Execution Summary:

        9   Executable lines in this file
        9   Lines executed
   100.00   Percent of the file executed

    38919   Total number of line executions
  4324.33   Average executions per line


*** File /home/tyler/Desktop/fland2/glutenv.cpp:
                #ifndef GLUTENV_CPP
                #define GLUTENV_CPP
                
                using namespace std;
                #include <GL/glut.h>
                
                #include "main.h"
                #include "events.h"
                #include "defines.h"
                #include "glutenv.h"
                #include "rendervertex.h"
                
                // These functions are to be used by the main program
                // If you want to use a system other then GLUT you need to rewrite this file
                // keeping these functions the same.
                // ALSO: Make sure the callback functions have the right parameters.
                
                
                
       ##### -> vector<RenderVertex> vertexArray;
       ##### -> vector<GLuint> vertexArrayIndexList;
                
                // These functions use the GLUT environment.
                
         306 -> float getElapsedTime()
                {
                	return glutGet( GLUT_ELAPSED_TIME ) / 1000.0;
                }
                
                // abstract the glutSwapBuffers()
         306 -> int swapBuffers()
                {
                	glutSwapBuffers();
                	return 0;
                }
                
                // The outside program calls this function to initalize everything.
           1 -> int initEnv(int argc, char** argv)
                {
                	// this is in this file
                   initGraphics(argc, argv);
                   initProgram();
                
                   glutMainLoop();
                
                   // THE PROGRAM NEVER EVEN GETS HERE!
                	return 0;
                }
                
                // sets the callback functions for event processing.
           1 -> int setCallbacks()
                {
                	glutMouseFunc( gMouse );
                	glutMotionFunc( gMouseMove );
                   glutDisplayFunc(gDisplay);
                   glutIdleFunc(gIdle);
                   glutReshapeFunc(gReshape);
                   glutKeyboardFunc(gKeyboard);
                   glutKeyboardUpFunc(gKeyboardUp );
                	glutPassiveMotionFunc(gPassiveMotionFunc);
                
                	return 0;
                }
                
           1 -> int setupMenu()
                {
                	// in events.h is the enum of the options
                	glutCreateMenu(gMenu);
                	//glutAddSubMenu("Camera", 90);
                	glutAddMenuEntry("Full Screen", FULL_SCREEN);
                	glutAddMenuEntry("Reset View", RESET_VIEW);
                	glutAddMenuEntry("Dump Object Parameters", DUMP_SPECS);
                	glutAddMenuEntry("Dump Environment Specs", DUMP_ENVIRONMENT);
                	glutAddMenuEntry("Reset Fland", RESET_FLAND );
                	glutAddMenuEntry("Randomize Fland", RANDOMIZE_LAND);
                	glutAddMenuEntry("Quit", QUIT_PROGRAM);
                	glutAttachMenu(GLUT_RIGHT_BUTTON);
                	return 0;
                }
                
                // This function sets up the graphics.
           1 -> int initGraphics(int argc, char** argv)
                {
                
                	glutInit(&argc, argv);
                   glutInitDisplayMode ( GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGB);
                   glutInitWindowSize (DEFULT_WINDOW_WIDTH, DEFULT_WINDOW_HEIGHT); // these vals are defined in defines.h
                   glutInitWindowPosition ( 100, 10 );
                   glutCreateWindow ("Fractal Land");
                
                   setCallbacks();
                	setupMenu();
                
                	//glEnable(GL_CULL_FACE);
                	//glCullFace(GL_FRONT);
                	glShadeModel(GL_SMOOTH);							// Enable Smooth Shading
                	//glShadeModel(GL_FLAT);
                	glClearColor(0.0, 0.0, 0.0, 0.5);				// Black Background
                	glClearDepth(1.0);									// Depth Buffer Setup
                	glEnable(GL_DEPTH_TEST);							// Enables Depth Testing
                	glEnable(GL_TEXTURE_2D);							// Enable Texture Mapping
                	glEnable(GL_COLOR_MATERIAL);    // this is necessary. Dont ask why
                	glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);					// Set The Blending Function For Translucency
                	glEnable(GL_BLEND);
                
                	glDepthFunc(GL_LEQUAL);								// The Type Of Depth Testing To Do
                	glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);	// Really Nice Perspective Calculations
                	//glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_FASTEST);	// Really fast Perspective Calculations
                
                   GLfloat LightSpecular[]= { 1.0f, 1.0f, 1.0f, 1.0f }; 				// Ambient Light Values
                   GLfloat LightShininess[]= { 50.0 }; 				// Ambient Light Values
                   GLfloat LightAmbient[]= { 0.2f, 0.2f, 0.2f, 1.0f }; 				// Ambient Light Values
                	GLfloat LightDiffuse[]= { 0.7f, 0.7f, 0.7f, 1.0f };				 // Diffuse Light Values
                	GLfloat LightPosition[]= { 0.0f, 0.0f, 0.0f, 1.0f };				 // Light Position
                
                	//glLightfv(GL_LIGHT1, GL_SPECULAR, LightAmbient);
                	//glLightfv(GL_LIGHT1, GL_SHININESS, LightShininess );
                   // glMaterialfv(GL_FRONT, GL_SPECULAR, LightSpecular);
                   // glMaterialfv(GL_FRONT, GL_SHININESS, LightShininess);
                
                	glLightfv(GL_LIGHT1, GL_DIFFUSE, LightDiffuse);				// Setup The Diffuse Light
                	glLightfv(GL_LIGHT1, GL_AMBIENT, LightAmbient);				// Setup The Ambient Light
                	glLightfv(GL_LIGHT1, GL_POSITION,LightPosition);			// Position The Light
                	glEnable(GL_LIGHT1);							// Enable Light One
                	glEnable(GL_LIGHTING);
                
                	glEnable( GL_FOG );
                	glFogi(GL_FOG_MODE, GL_LINEAR);
                	glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );
                	glHint( GL_FOG_HINT, GL_NICEST );
                
                    // set up displaylist stuff
                    glEnableClientState( GL_VERTEX_ARRAY );
                    glEnableClientState( GL_COLOR_ARRAY );
                    glEnableClientState( GL_NORMAL_ARRAY );
                
                
                    cout << "&VertexArray[0]: " << &vertexArray[0];LN
                
                   return 0;
                }
                
       ##### -> void drawSphere( double x, double y, double z, double r )
                {
                	glPushMatrix();
                	glTranslatef( x, y, z );
                	glColor4f( 1.0, 0.5, 0.5, 0.5 );
                	glDisable( GL_DEPTH_TEST );
                	glutSolidSphere( r, 10, 5 );
                	glEnable( GL_DEPTH_TEST );
                	glPopMatrix();
           1 -> }
           1 -> 
                
                #endif


Top 10 Lines:

     Line      Count

       25        306
       31        306
       38          1
       51          1
       65          1
       82          1
      152          1
      153          1

Execution Summary:

       11   Executable lines in this file
       11   Lines executed
   100.00   Percent of the file executed

      618   Total number of line executions
    56.18   Average executions per line


*** File /home/tyler/Desktop/fland2/fmlutils.cpp:
                #ifndef FMLUTILS_CPP
                #define FMLUTILS_CPP
                
                
                
                #include <fstream>
                #include <cstdlib>
                #include <iomanip>
                #include <iostream>
                #include <map>
                #include <string>
                #include <sstream>
                #include <stdio.h>
                #include <stdlib.h>
                #include <typeinfo>
                #include "fmlutils.h"
                
                
                
                using namespace std;
                
                
                
           3 -> TextFile::TextFile( string inFileName )
                {
                	file = NULL;
                
                	line = 0;
                	fileName = inFileName + '\0';
                
                	FILE *fp;
                	fp = fopen(fileName.data(), "r");
                	if( !fp )
                	{
                		cout << "Couldn't open " << fileName << endl;
                	}
                	else
                	{
                		string str;
                		char chr;
                		do
                		{
                			fread(&chr, sizeof(char), 1, fp);
                			str = str + chr;
                		}while( !feof( fp ) );
                		fclose( fp );
                		file = new istringstream( str );
                	}
                }
                
           3 -> TextFile::~TextFile()
                {
                	if( file )
                		delete file;
                }
                
                
           3 -> bool TextFile::loaded()
                {
                	if( file )
                		return true;
                	else
                		return false;
                }
                
                
         263 -> string TextFile::getLine()
                {
                	string str = "";
                
                	// if this char isn't initalized to something then get() returns garbage at the end of a file.
                	// TODO: replace get with something else if this continues.
                	char chr = ' ';
                
                	do
                	{
                		file->get( chr );
                		if( chr != '\n' )
                			str = str + chr;
                	}while( !file->eof() && chr != '\n' );
                	if( chr == '\n' )
                		line++;
                	return str;
                }
                
         267 -> bool TextFile::eof()
                {
                	return file->eof();
                }
                
                
                // returns a string of the position in the file
          29 -> string TextFile::pos()
                {
                	ostringstream temp;
                	string sTemp = fileName;
                	string fname = tokenize( sTemp, "." );
                	temp << fname << (int)line;
                	return temp.str();
                }
                
           1 -> void TextFile::pError( string error )
                {
                	if( error.length() > 0 )
                		cout << "Parse Error " << fileName << " " << line << "\n\t" << error << endl;
                }
                
       ##### -> FmlParserFatalError::FmlParserFatalError( string err )
                {
                	message = err;
                }
                
                // pass an error message and a position in the file
       ##### -> FmlParserFatalError::FmlParserFatalError( string err, string pos )
                {
                	message = err; file = pos;
                }
                
       ##### -> FmlParserFatalError::FmlParserFatalError()
                : message( "FML Parse Fatal Error Occured." )
                {
                	line = 0; file = "";
                }
                
       ##### -> string FmlParserFatalError::what()
                {
                	return message + "\n\t" + file;
                }
                
       ##### -> string getLine( ifstream *handle )
                {
                	string str = "";
                	char chr;
                	do
                	{
                		handle->get( chr );
                		if( chr != '\n' )
                		str = str + chr;
                	}while( !handle->eof() && chr != '\n' );
                	return str;
                }
                
                // takes a string, breaks off the first occurence of token, and returns the token.
                // the origional string is changed
        1150 -> string tokenize( string &inString, string delimiter )
                {
                
                	int x = inString.find( delimiter );
                
                	string ret = inString;
                
                	if( x == string::npos )
                	{
                		inString = "";
                	}
                	else
                	{
                		ret = inString.substr( 0, x );
                		int chop = x + delimiter.length();
                		inString = inString.substr( chop, inString.length() - chop );
                	}
                	return ret;
                }
                
                // takes a string, breaks off the LAST occurence of token, and returns the token.
                // the origional string is changed
         444 -> string tokenizer( string &inString, string delimiter )
                {
                
                	int x = inString.rfind( delimiter );
                
                	string ret = inString;
                
                	if( x == string::npos )
                	{
                		inString = "";
                	}
                	else
                	{
                		x = x + delimiter.length();
                		ret = inString.substr( x, inString.length() - x );
                		int chop = ret.length() + delimiter.length();
                		inString = inString.substr( 0, inString.length() - chop );
                	}
                	return ret;
                }
                
       ##### -> string addQuotes( string inStr )
                {
                	return( "\"" + inStr + "\"" );
                }
                
                // The string cant have leading or trailing whitespace.
         429 -> string stripQuotes( string instr )
                {
                	if( instr.substr( 0,1 ) == "\"" )
                	{
                		return( instr.substr( 1, instr.length() - 2 ) );
                	}
                	else
                	{
                		return instr;
                	}
           1 -> }
           1 -> 
                
                #endif
                


Top 10 Lines:

     Line      Count

      145       1150
      167        444
      194        429
       86        267
       67        263
       93         29
       24          3
       51          3
       58          3
      102          1

Execution Summary:

       18   Executable lines in this file
       18   Lines executed
   100.00   Percent of the file executed

     2594   Total number of line executions
   144.11   Average executions per line


*** File /home/tyler/Desktop/fland2/fmlparser.cpp:
                #ifndef FMLPARSER_CPP
                #define FMLPARSER_CPP
                #include <sstream>
                #include <iterator>
                #include <map>
                
                using namespace std;
                
                #include "fmlparser.h"
                #include "defines.h"
                #include "tyler.h"
                #include "baserule.h"
                
                #include "groupr.h"
                #include "averager.h"
                #include "roughr.h"
                #include "colorshiftr.h"
                #include "drules.h"
                #include "main.h"
                
                
                
                //using std::ios;
                // Note: This code needs a lot of TLC. Its way messy (if I remember from before my mission right)
                // it starts here with a filename passed in.
           1 -> FmlParser::FmlParser( string inStartFile )
                {
                	cout << "Parsing " << inStartFile << endl;
                
                	startFile = inStartFile;
                	parseFile( startFile );
                
                	// check for a rule named "root"
                	if( !nameMap[ ROOT_RULE_NAME ] )
                		throw( FmlParserFatalError( "FML ERROR! Finished compiling FML files \n\tand there was no rule named " ROOT_RULE_NAME " found!" ) );
                }
                
           1 -> FmlParser::~FmlParser()
                {
                	// TODO: delete everything in the nameMap and picMap
                	/* // Disable this because it has to do with pictures
                	picMapType::iterator iter;
                	for( iter = picMap.begin();
                	iter != picMap.end();
                	++iter )
                	{
                		//cout << iter->first << iter->second << endl;
                		if( iter->second )
                			delete iter->second;
                	}
                	*/
                	nameMapType::iterator niter;
                	for( niter = nameMap.begin();
                	niter != nameMap.end();
                	++niter )
                	{
                		//cout << niter->first << niter->second << endl;
                		if( niter->second )
                			delete niter->second;
                	}
                }
                
                // this gets called on main.fml, and every file that is included
           3 -> int FmlParser::parseFile( string inFile )
                {
                
                	// add the FML folder to the fileName ( defined in defines.h )
                	inFile = FML_FOLDER + inFile;
                
                	TextFile file( inFile );
                //return 0;
                	if( !file.loaded() )
                	{
                		return 1;
                	}
                	string ret;
                
                
                	while( !file.eof() )
                	{
                		ret = evaluateLine( &file, NULL );
                		//cout << file.pos() << endl;
                	}
                	return 0;
                }
                
                // this is called on every line of a file, one line after another.
                // When called initially currentRule is NULL.
         263 -> string FmlParser::evaluateLine( TextFile *file, BaseRule* currentRule )
                {
                		string fileLine = file->getLine();
                
                		// clean out coments, leading and trailing whitespace.
                		cleanLine( fileLine );
                
                		string token;
                		string rightOperand = "";
                		string returnVal = "";
                
                		// for checking for barewords
                		int numTokens = 0;
                
                		do
                		{
                			// strip off the rightmost token. The equals is the delimiter.
                			// after this line fileLine will have one less token and equals on the right.
                			token = tokenizer( fileLine, "=" );
                
                
                			// this is genius. The rightmost token is striped off and passed in as 'token'.
                			// Any processing is done on it (if it is some command like 'print' or 'include')
                			// if there is no processing to do (like if it is an rvalue) it will just be returned.
                			// Then the returned value is passed back in to be the rvalue of the next call (returnVal)
                			returnVal = evaluateToken( token, returnVal, file, currentRule );
                
                			// make sure there is a returnVal. /closing tags are allowed as barewords.
                			if( returnVal != "" && returnVal.substr( 0, 1 ) != "/" ){ numTokens++; }
                		}while( fileLine.length() > 0 );
                
                		if( numTokens == 1 ) { file->pError( "Bareword '" + returnVal + "' found" ); }
                
                		return returnVal;
                }
                
                // This is disabled at the moment until we fix the bitmap loader
                /*
                int FmlParser::processImage( string fileName )
                {
                	// if the image is already loaded and in the array, we're good.
                	if( picMap[ fileName ] )
                		return 0;
                
                	string loadFile = PIC_FOLDER + fileName;
                
                	// not loaded yet, load it.
                	Bitmap* nBitmap;
                	// THIS NEXT LINE is what causes the problem
                	// it has nothing to do with the Bitmap class, Vertex does the same thing
                	nBitmap = new Bitmap;
                	nBitmap->loadBitmap( loadFile );
                
                	// if there was an error, bail out now
                	if( nBitmap->isGood == false )
                	{
                		delete nBitmap;
                		return 1;
                	}
                
                	// there wasn't an error, put it in the picMap
                	picMap[ fileName ] = nBitmap;
                
                	return 0;
                
                }
                */
                
                // token is the rule being processed. inputVal is the argument to the rule. For example
                // token = inputVal
                // ret is the same as token if token isn't a /rule tag and inputVal is null,
                // or ret is the value of a new rule.
         429 -> string FmlParser::evaluateToken( string token, string inputVal, TextFile* file, BaseRule* currentRule )
                {
                	cleanLine( inputVal );
                	cleanLine( token );
                
                	token = stripQuotes( token );
                	string ret = token; // by default, return the token, striped of quotes
                
                	// bail out if no rvalue is given.
                	if( inputVal == "" && token.substr( 0, 1 ) != "/" )
                	{
                		return ret;
                	}
                
                	// first, check if it is an image. If so, load and put in picMap
                	if( token == "image" )
                	{
                		//if( processImage( inputVal ) )
                		//	file->pError( "Couldn't load image " + inputVal );
                	}
                
                	if( token == "print" )
                	{
                		cout << inputVal << "\n" << flush;
                	}
                	else if( token == "include" )
                	{
                		parseFile( inputVal );
                	}
                	else if( token == "rule" )
                	{
                		ret = evaluateRule( inputVal, file );
                	}
                	else if( token == "/rule" && currentRule == NULL )
                	{
                		file->pError( "There are more /rule then there are rule tags!" );
                	}
                	else if( token == "printnames" )
                	{
                		cout << "Printing the entire name map\n";
                		nameMapType::iterator niter;
                		for( niter = nameMap.begin();
                		niter != nameMap.end();
                		++niter )
                		{
                			cout << "\t" << BASER(niter->second)->getType() << " " << niter->first << " " << niter->second << endl;
                		}
                	}
                	else if( token == "name" )
                	{
                	// insert a new name into the name map
                		if( nameMap[ inputVal ] )
                		{
                			file->pError( "you are trying to create rule " + addQuotes( inputVal ) + " twice!" );
                		}
                		nameMap[ inputVal ] = currentRule;
                		// return the name of the new rule, with a flag so we know it is for us
                		ret = "name=" + inputVal;
                	}
                	else
                	{
                		// this is one of the many individual parameters in a rule.
                		if( currentRule && inputVal != "" )
                		{
                			// Clean the inputVal for certain conditions
                			if( inputVal == "true" )
                				inputVal = "1";
                			if( inputVal == "false" )
                				inputVal = "0";
                			if( inputVal == "infinity" )
                				inputVal = "99999999";
                
                			// create the stream, and send the parameters to the virtual function of the rule they
                			// go to
                			istringstream sVal( inputVal );
                			string rError;
                			rError = currentRule->assignValue( token, &sVal, this );
                			// TODO: make sure assignValue returns a value, at least empty string.
                			// if it doesn't, then this next line can seg-fault.
                			if( rError != "" )
                			{
                				if( rError == "ERROR" ) // These are fatal errors
                					{ throw FmlParserFatalError( rError, file->pos() ); }
                				else
                					file->pError( rError );
                			}
                		}
                		else if( !currentRule && inputVal != "" ) // This command of text is not recognised.
                		{
                			file->pError( "Command \"" + inputVal + "\" not recognised" );
                		}
                	}
                
                	return ret;
                }
                
                // inputVal is the name of the rule type to create (like averager or groupr). If left
                // blank a unique rule name will be given.
                // this function will create a new rule of the type specified, put it's pointer into the
                // nameMap hash and return the string name that references it.
                // this function is called when the parser encounters a rule tag. Then this function
                // evaluates lines inside the file until reaching it's /rule tag.
          29 -> string FmlParser::evaluateRule( string inputVal, TextFile *file )
                {
                	// the filename and position in the file.
                	// name is the name of the rule that will be put in the namemap.
                	// Because some rules are not given names, the filename and position is given as a unique name.
                	// If the rule IS given a specific name, this name parameter will be overridden.
                	string name = file->pos();
                
                	string type = "";
                	BaseRule* rptr = NULL;
                	// first create the rule
                	if( inputVal == "groupr" )
                	{
                		rptr = new GroupR;
                	}
                	else if( inputVal == "colorshiftr" )
                	{
                		rptr = new ColorShiftR;
                	}
                	else if( inputVal == "roughr" )
                	{
                		rptr = new RoughR;
                	}
                	else if( inputVal == "averager" )
                	{
                		rptr = new AverageR;
                	}
                	else if( inputVal == "patternr" )
                	{
                		rptr = new PatternR;
                	}
                	else if( inputVal == "altituder" )
                	{
                		rptr = new AltitudeR;
                	}
                	else if( inputVal == "sloper" )
                	{
                		rptr = new SlopeR;
                	}
                	else if( inputVal == "altitudexslope" || inputVal == "slopexaltitude" )
                	{
                		rptr = new SlopeXAltitudeR;
                	}
                	else
                	{
                		throw FmlParserFatalError( "Undefined rule type " + inputVal + " Bailing out! ", file->pos() );
                	}
                	string ret = "";
                
                	bool didName = false;
                	// parse one line at a time through the FML file and evaluate the rule parameters.
                	do
                	{
                
                		if( file->eof() ){ break; }
                
                		ret = evaluateLine( file, rptr );
                
                		// find the fml name and store it.
                		if( ret.find( "name=" ) != string::npos )
                		{
                			name = tokenizer( ret, "name=" );
                			didName = true;
                		}
                	}while( ret != "/rule" );
                
                	if( !didName )
                	{
                		ret = evaluateToken( "name", name, file, rptr );
                		if( ret == "ERROR" )
                			{ LN return ret; }
                	}
                
                	#if( DEBUG )
                		rptr->fmlName = name;
                		rptr->fmlRule = true;
                	#endif
                	return name;
                }
                
                // cleans out whitespace and coments
                // Any internal whitespace will remain.
        1121 -> void FmlParser::cleanLine( string &newLine )
                {
                	// first clean out the leading whitespace
                	int i;
                	for( i=0; i<newLine.length(); i++ )
                	{
                		if( newLine.substr( i, 1 ) == " " ||
                			 newLine.substr( i, 1 ) == "\r" ||
                			 newLine.substr( i, 1 ) == "\n" ||
                			 newLine.substr( i, 1 ) == "\t" ||
                			 newLine.substr( i, 1 ) == "\0" )
                			continue;
                		break;
                	}
                	newLine = newLine.substr( i, newLine.length() - i );
                
                
                	// a trick to strip off the coments.
                	newLine = tokenize( newLine, COMENT );
                
                	// now clean out the trailing whitespace
                	for( i=newLine.length()-1; i>=0; i-- )
                	{
                		if( newLine.substr( i, 1 ) == " " ||
                			 newLine.substr( i, 1 ) == "\n" ||
                			 newLine.substr( i, 1 ) == "\r" ||
                			 newLine.substr( i, 1 ) == "\t" ||
                			 newLine.substr( i, 1 ) == "\0" )
                			continue;
                		break;
                	}
                	newLine = newLine.substr( 0, i+1 );
                
                
           1 -> }
           1 -> 
                // ParseRule stuff
                
                #endif


Top 10 Lines:

     Line      Count

      345       1121
      161        429
       89        263
      263         29
       64          3
       26          1
       38          1
      379          1
      380          1

Execution Summary:

        9   Executable lines in this file
        9   Lines executed
   100.00   Percent of the file executed

     1849   Total number of line executions
   205.44   Average executions per line


*** File /home/tyler/Desktop/fland2/fland.cpp:
                #ifndef FLAND_CPP
                #define FLAND_CPP
                
                using namespace std;
                #include <iostream>
                #include <fstream>
                #include <string>
                #include <cassert>
                
                #include "glutenv.h"
                #include "fland.h"
                #include "defines.h"
                #include "baseent.h"
                #include "fmlparser.h"
                #include "vertex.h"
                #include "meshseed.h"
                #include "buildhtml.h"
                #include "camera.h"
                #include "defines.h"
                
                Fland* Fland::fland;
                extern vector<RenderVertex> vertexArray;
                extern vector<GLuint> vertexArrayIndexList;
                
       ##### -> void Fland::dumpObjectsToFile( string fileName )
                {
                	ofstream logFile( fileName.c_str() );
                	getFlandPtr()->dump( logFile, 0 );
                	logFile.close();
                }
                
       ##### -> void Fland::dump( ostream& out, int depth )
                {
                	#if DEBUG
                	if( firstEnt )
                	{
                		out << "\nDumping every object in fland! elapsed time: " << getElapsedTime() << endl;
                		firstEnt->dump( out, depth );
                	}
                	#endif
                	int deepest = 0;
                	out << "\nClosest Render Distance: " << closestRenderDistance
                		  << "\nFarthest Render Distance: " << farthestRenderDistance
                		  << "\nNumber of entities: " << firstEnt->getCount( deepest )
                		  << "\nDeepest Entity Depth: " << deepest
                		  << "\nSplit Visibility: " << splitVisibility << endl;
                }
                
                
           1 -> Fland::Fland( int inSeed )
                {
                	maxCreates = 100;
                	static int numTimes = 0;
                
                	fland = this;
                
                	//if( numTimes == 0 )
                	//{
                		cout << "\n\n\n\nRealtime Fractal Landscape Generator\n";
                		cout << "By Tyler Patterson\n";
                		cout << "Compiled on " __DATE__ " at " __TIME__ << endl;
                		cout << "Using seed " << inSeed << endl;
                	//}
                	numTimes++;
                	cout << endl;
                
                	morphPercentage = MORPH_AMOUNT;
                
                	// First parse the rules
                	// Do it in a try block to make sure everything is OK.
                	try
                	{
                		fmlParser = new FmlParser( "main.fml" );
                	}
                	catch( FmlParserFatalError ex )
                	{
                		cout << ex.what() << endl;
                		// Dont clean anything up, just rethrow the error and let the
                		// system call all the destructors as it exits.
                		throw;
                	}
                
                	setSplitVisibility( DEFAULT_SPLIT_VISIBILITY );
                	closestRenderDistance = 1.0; // set it for fun, it will be set later.
                	farthestRenderDistance = 10.0; // dito.
                	targetFrameRate = DEFAULT_TARGET_FRAMERATE; // the goal.
                
                	// Create the camera;
                	camera = new Camera;
                	// The first entity has to be set by hand.
                
                
                	firstEnt = MeshSeed::reuse.tNew( NULL );
                	MSEED(firstEnt)->setMeshParams( 0.0, 0.0, 0.0, 1.0 );
                
                	// This is the split rule for the firstEnt.
                	//BaseRule* fRule = reusePlaneR.tNew( firstEnt );
                	// Set the firstent rule
                	firstEnt->seed = inSeed;
                	//firstEnt->splitRule = fRule;
                
                	if( fmlParser->nameMap[ ROOT_RULE_NAME ] )
                	{
                		// create a pointer to the first rule
                		BaseRule* fRule;
                		// Create the first rule of the root entity firstEnt.
                		fRule = fmlParser->nameMap[ ROOT_RULE_NAME ];
                		assert( fRule );
                		firstEnt->addRule( fRule, fRule->numPropogates, 1.0 );
                	}
                	else
                	{
                		cout << "No rule named " << ROOT_RULE_NAME << " found in FML files!\n";
                		LN
                	}
                
                }
                
           1 -> Fland::~Fland()
                {
                	// empty out the reuse objects
                	MeshSeed::reuse.empty();
                	Vertex::reuse.empty();
                	//reuseBaseEnt.empty();
                
                	// Kill everything
                	if( firstEnt )
                	{
                		delete firstEnt;
                	}
                	delete camera;
                	delete fmlParser;
                	fland = NULL;
                }
                
         306 -> int Fland::recalculateView()
                {
                	Fland* fl = getFlandPtr();
                	double frameDiscrepancy = targetFrameRate / fl->env.frameRate;
                //	splitVisibility = ( splitVisibility + splitVisibility * frameDiscrepancy ) / 2.0;
                //	if( frameDiscrepancy > 1.0 ) // if we are too detailed
                //		splitVisibility *= frameDiscrepancy; // take detail away quick
                //	else // add detail slowly
                //	splitVisibility *= ( frameDiscrepancy - 1.0 ) / FRAME_CHANGE_DAMPENER + 1.0;
                
                
                
                	//if( splitVisibility > 0.2 )
                	//	splitVisibility = 0.2;
                	//if( splitVisibility < 0.0001 )
                	//	splitVisibility = 0.0001;
                
                	//camera->viewAngle = 15;
                	camera->updateLocation();
                	if( firstEnt )
                	{
                		// This is the distance to the clostest rendered entity.
                		// start it out high so it will be guranteed to be
                		// set to the correct value in BaseEnt::calcVisibility
                		closestRenderDistance = 99999999999.9;
                		farthestRenderDistance = 0.0;
                
                
                		firstEnt->recursiveCalcVisibility();
                
                		// a little debug thing. Stop spliting and un-spliting while spacebar is pressed.
                		if( fl->env.keys[' '] == false )
                		{
                			firstEnt->recursiveSplit();
                			// tell firstEnt's children to unsplit. We dont want to un-split the base
                			// entity or the whole world will go away!
                
                			// This makes it impossible for the root entity to be unsplit.
                			// It was causing the mesh to never split farther and become 'stuck'
                			for( int i=0; i<firstEnt->child.size(); i++ )
                				firstEnt->child[i]->recursiveUnSplit();
                
                			// This makes it so that even the root entity can be unsplit
                			// and the whole thing goes away.
                			//firstEnt->recursiveUnSplit();
                
                		}
                	}
                	fl->env.recalculateFramerate();
                	// set the near and far planes.
                	// Make them a hair larger then they need to be, just so things dont
                	// lie exactly on the line and cause flickering.
                	//camera->near = closestRenderDistance * 0.99;
                	//camera->far = farthestRenderDistance * 1.01;
                	camera->setNearFarPlanes( closestRenderDistance, farthestRenderDistance );
                	//camera->printFrustum();
                	return 0;
                }
                
         306 -> int Fland::draw()
                {
                	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
                
                	glMatrixMode(GL_PROJECTION);
                	glLoadIdentity();
                	glMatrixMode(GL_MODELVIEW);
                
                	camera->viewAngle = 30.0;
                	//camera->near = 0.001;
                	//camera->far = 10;
                	camera->printFrustum();
                
                
                	if( firstEnt )
                	{
                		firstEnt->draw();
                	}
                	//glTranslatef( 0, 1, 0 );
                	//glRotatef( fl->env.frameCount, 0, 0, 1 );
                	//glutSolidTeapot( .1 );
                	swapBuffers();
                	return 0;
                }
                
       ##### -> void Fland::buildRuleLayout()
                {
                	BuildDiagnosticHtml( this );
                
           1 -> }
           1 -> 
                
                #endif


Top 10 Lines:

     Line      Count

      136        306
      195        306
       50          1
      119          1
      224          1
      225          1

Execution Summary:

        9   Executable lines in this file
        9   Lines executed
   100.00   Percent of the file executed

      616   Total number of line executions
    68.44   Average executions per line


*** File /home/tyler/Desktop/fland2/events.cpp:
                #ifndef EVENTS_CPP
                #define EVENTS_CPP
                // This file has all the callback functions for event handling.
                
                #include <GL/glut.h>
                #include <fstream>
                #include <iostream>
                #include <string>
                
                #include "events.h"
                #include "main.h"
                #include "fland.h"
                #include "camera.h"
                #include "baseent.h"
                #include "buildhtml.h"
                #include "glutenv.h"
                
                using namespace std;
                
                
                
                // When the window is resized.
       ##### -> void gReshape(int width, int height)
                {
                	Fland *fl = getFlandPtr();
                	fl->env.screenWidth = width;
                	fl->env.screenHeight = height;
                	glViewport(0, 0, (GLint) width, (GLint) height);
                	glMatrixMode(GL_PROJECTION);
                	glLoadIdentity();
                	//glFrustum(-1.0, 1.0, -h, h, 3.0, 600.0);
                
                	gluPerspective(25.0,(GLdouble)width/(GLdouble)height, 0.000003, 600.0);
                	glMatrixMode(GL_MODELVIEW);
                }
                
       ##### -> void gIdle()
                {
                	mainLoop();
                	//glutPostRedisplay();
                }
                
       ##### -> void gDisplay()
                {
                
                }
                
       ##### -> void gKeyboard(unsigned char key, int x, int y)
                {
                
                	Fland* fl = getFlandPtr();
                	if( fl )
                		fl->env.keys[ key ] = true; // set the key variable
                	switch( key )
                	{
                		case 'q':
                		case 27:
                			closeProgram();
                		break;
                
                		case 'e':
                			fl->env.printVars();
                			break;
                
                		case 't':
                			//cout << fl->camera->toString( 1 );
                			resetFland( (int)(getElapsedTime() * 1000) );
                			break;
                
                		case '=':
                			fl->setSplitVisibility( fl->getSplitVisibility() / 1.2 );
                			cout << "splitVisibility: " << fl->getSplitVisibility() << endl;
                			break;
                
                		case '-':
                			fl->setSplitVisibility( fl->getSplitVisibility() * 1.2 );
                			cout << "splitVisibility: " << fl->getSplitVisibility() << endl;
                			break;
                
                		case ' ':
                			glDisable( GL_FOG );
                			break;
                
                		case '[':
                			fl->morphPercentage -= .1;
                			if( fl->morphPercentage < 0.0 )
                				fl->morphPercentage = 0.0;
                			cout << "morphPercentage " << fl->morphPercentage << endl;
                			break;
                
                		case ']':
                			fl->morphPercentage += .1;
                			if( fl->morphPercentage > 1.0 )
                				fl->morphPercentage = 1.0;
                			cout << "morphPercentage " << fl->morphPercentage << endl;
                			break;
                
                		case 'g':
                			fl->firstEnt->printGeneology( 0 );
                			break;
                
                		case 'o': // dump the envirnment specs
                			fl->dumpObjectsToFile( DUMP_FILE_NAME );
                			break;
                
                		case 'h':
                			fl->buildRuleLayout();
                			break;
                
                		case 'p': // take a picture
                			double saveSplit = fl->getSplitVisibility();
                			fl->setSplitVisibility( saveSplit / 5.0 ); // make the visibility this much higher
                			fl->recalculateView();
                			//fl->dump( cout, 0 );
                			fl->draw();
                			fl->setSplitVisibility( saveSplit );
                			pause( 4 );
                			break;
                	}
                }
                
       ##### -> void gMouse(int button, int state, int x, int y)
                {
                	Fland* fl = getFlandPtr();
                	fl->env.mouseX = x;
                	fl->env.mouseY = y;
                	fl->env.mouseButton = button;
                }
                
       ##### -> void gMouseMove( int x, int y)
                {
                	Fland* fl = getFlandPtr();
                	int moveX = x - fl->env.mouseX;
                	int moveY = y - fl->env.mouseY;
                
                	// This determines how the camera moves when you move the mouse.
                	fl->camera->rotY += moveX * CAMERA_LOOK_SPEED;
                	fl->camera->rotX -= moveY * CAMERA_LOOK_SPEED;
                
                
                	fl->env.mouseX = x;
                	fl->env.mouseY = y;
                }
                
         306 -> void gRepeatKeys()
                {
                	Fland* fl = getFlandPtr();
                	// move forward
                	if( fl->env.keys['w'] )
                	{
                		fl->camera->speed += CAMERA_MOVE_SPEED;
                	}
                
                	if( fl->env.keys['s'] )
                	{
                		fl->camera->speed -= CAMERA_MOVE_SPEED;
                	}
                
                	// move up and down
                	if( fl->env.keys['r'] )
                	{
                		fl->camera->vertSpeed += CAMERA_MOVE_SPEED;
                	}
                
                	if( fl->env.keys['f'] )
                	{
                		fl->camera->vertSpeed -= CAMERA_MOVE_SPEED;
                	}
                
                	// move Side to side
                	if( fl->env.keys['a'] )
                	{
                		fl->camera->sideSpeed += CAMERA_MOVE_SPEED;
                	}
                
                	if( fl->env.keys['d'] )
                	{
                		fl->camera->sideSpeed -= CAMERA_MOVE_SPEED;
                	}
                }
                
       ##### -> void gKeyboardUp( unsigned char key, int x, int y )
                {
                	Fland* fl = getFlandPtr();
                	fl->env.keys[key] = false;
                
                	// turn fog back on when the spacebar comes up
                	if( key == ' ' )
                		glEnable( GL_FOG );
                }
       ##### -> void gPassiveMotionFunc(int x, int y)
                {
                
                }
                //static void gMenu( int option )
                //{
       ##### -> void gMenu( int option )
                {
                	Fland* fl = getFlandPtr();
                	switch( option )
                	{
                		case DUMP_SPECS:
                		{
                			//ofstream logFile( LOG_FILE_NAME );
                			fl->dump( cout, 0 );
                			//logFile.close();
                		}
                			break;
                
                		case QUIT_PROGRAM:
                			closeProgram();
                			break;
                
                		case RESET_VIEW:
                			fl->camera->resetView();
                			break;
                
                		case DUMP_ENVIRONMENT:
                			fl->env.printVars();
                			break;
                
                		case RESET_FLAND:
                			resetFland( 1 );
                			break;
                
                		case FULL_SCREEN:
                			glutFullScreen();
                			break;
                
                		case RANDOMIZE_LAND:
                			resetFland( fl->firstEnt->seed + 1 );
                			break;
                
                		default:
                			cout << "Invalid menu option " << option << endl;
                			LN
                			break;
                	}
           1 -> }
           1 -> 
                #endif


Top 10 Lines:

     Line      Count

      145        306
      239          1
      240          1

Execution Summary:

       12   Executable lines in this file
       12   Lines executed
   100.00   Percent of the file executed

      308   Total number of line executions
    25.67   Average executions per line


*** File /home/tyler/Desktop/fland2/env.cpp:
                #ifndef ENV_CPP
                #define ENV_CPP
                // Environment: This class is for keeping track of the
                // environment that the program is running in.
                // Things like framerate, current keys states, mousestate, etc.
                
                using namespace std;
                
                #include <iostream>
                #include "env.h"
                #include "glutenv.h"
                
           1 -> Env::Env()
                {
                	mouseX = mouseY = mouseButton = 0;
                
                	for( int i=0; i<256; i++ )
                	{
                		keys[i] = false;
                	}
                	timeSlice = 0.1; // has to start somewhere
                	frameCount = 0; // the number of frames elapsed
                	frameRate = 0.0;
                	lastFrameTime = 0.0;
                	// set these to something, will be set again later.
                	screenWidth = 100;
                	screenHeight = 100;
                }
                
       ##### -> void Env::printVars()
                {
                	cout << "\nFrameRate: " << frameRate
                		  << "\nTime Slice: " << timeSlice
                		  << "\nFrame Count: " << frameCount
                		  << "\nElapsed Time: " << lastFrameTime << endl;
                }
                
         306 -> void Env::recalculateFramerate()
                {
                	double currentTime = getElapsedTime();
                
                	// Calculate the timeSlice
                	timeSlice = currentTime - lastFrameTime;
                	lastFrameTime = currentTime;
                
                	// Calculate the framerate
                	frameRate = 1.0 / timeSlice;
                
                	// if the timeslice is more then 1 second, stick it to 1 second.
                	if( timeSlice > 1.0 )
                		timeSlice = 1.0;
                
                	// increment the frameCount
                	frameCount++;
           1 -> }
           1 -> 
                #endif


Top 10 Lines:

     Line      Count

       38        306
       13          1
       55          1
       56          1

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

      309   Total number of line executions
    61.80   Average executions per line


*** File /home/tyler/Desktop/fland2/drules.cpp:
                #ifndef D_RULES_CPP
                #define D_RULES_CPP
                
                
                #include "baseent.h"
                #include "vertex.h"
                #include "tyler.h"
                
                #include "drules.h"
                
                //////////////////////////////////////////////////////////////////////////////////
                ////////////////////////////////// PATTERN //////////////////////////////////////
                // inClient HAS to be a vertex!
       17551 -> intensityType PatternR::getSecondRegionIntensity( BaseEnt* inClient )
                {
                	intensityType n;
                    n = noise.multipleNoise( size, 3, 
                            VERT( inClient )->getX(), 
                            VERT( inClient )->getY(), 
                            VERT( inClient )->getZ(),
                            0.3 );
                	
                    return( convertRange1ToRange2( n, threshold1, threshold2, (intensityType)0.0, (intensityType)1.0 )  );
                }
                
           2 -> PatternR::PatternR()
                	:DescriminatoryR()
                {
                    size = 1.0;
                }
                
          12 -> string PatternR::assignValue( string valueType, istringstream *value, FmlParser* fPtr )
                {
                	if( valueType == "size" )
                	{
                		*value >> size;
                	}
                	else
                	{
                		return DescriminatoryR::assignValue( valueType, value, fPtr );
                	}
                	return "";
                }
                
                //////////////////////////////////////////////////////////////////////////////////
                ////////////////////////////////// ALTITUDE //////////////////////////////////////
                // inClient HAS to be a vertex!
       ##### -> intensityType AltitudeR::getSecondRegionIntensity( BaseEnt* inClient )
                {
                	intensityType alt = VERT( inClient )->getAltitude();
                
                	return( convertRange1ToRange2( alt, threshold1, threshold2, (intensityType)0.0, (intensityType)1.0 ) );
                }
                
                //////////////////////////////////////////////////////////////////////////////////
                ////////////////////////////////// SLOPE /////////////////////////////////////////
                // inClient HAS to be a vertex!
       ##### -> intensityType SlopeR::getSecondRegionIntensity( BaseEnt* inClient )
                {
                	intensityType slope = VERT( inClient )->getSlope();
                //cout << VERT( inClient )->trueVertex.nz;LN
                	return( convertRange1ToRange2( slope, threshold1, threshold2, (intensityType)0.0, (intensityType)1.0 ) );
                }
                
                //////////////////////////////////////////////////////////////////////////////////
                ////////////////////////////// SLOPE_X_ALTITUDE //////////////////////////////////
                // inClient HAS to be a vertex!
       ##### -> intensityType SlopeXAltitudeR::getSecondRegionIntensity( BaseEnt* inClient )
                {
                	intensityType slope = VERT( inClient )->getSlope() * VERT( inClient )->getAltitude();
                
                	return( convertRange1ToRange2( slope, threshold1, threshold2, (intensityType)0.0, (intensityType)1.0 ) );
           1 -> }
           1 -> 
                #endif
                


Top 10 Lines:

     Line      Count

       14      17551
       32         12
       26          2
       73          1
       74          1

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

    17567   Total number of line executions
  2195.88   Average executions per line


*** File /home/tyler/Desktop/fland2/descriminatoryr.cpp:
                #ifndef DESCRIMINATORYR_CPP
                #define DESCRIMINATORYR_CPP
                
                #include <string>
                #include <sstream>
                #include "groupr.h"
                #include "tyler.h"
                #include "defines.h"
                #include "descriminatoryr.h"
                
                
                #define REGION_CUTOFF 0.01
                
           4 -> DescriminatoryR::DescriminatoryR()
                	:GroupR()
                {
                	threshold1 = threshold2 = 0.0;
                }
                
          20 -> string DescriminatoryR::assignValue( string valueType, istringstream *value, FmlParser* fPtr )
                {
                
                	// an alias for adding groupmembers
                	if( valueType == "threshold1" )
                	{
                		*value >> threshold1;
                	}
                	else if(valueType == "threshold2" )
                	{
                		*value >> threshold2;
                	}
                	else
                	{
                		return GroupR::assignValue( valueType, value, fPtr );
                	}
                	return "";
                }
                
       ##### -> void DescriminatoryR::propogateChildren( BaseEnt* newEnt, intensityType inIntensity )
                {
                	intensityType region0, region1; // the intensities of both regions
                	getBothIntensities( newEnt, inIntensity, region0, region1 );
                
                	sassert( groupMember[0] );
                	sassert( groupMember[1] );
                
                
                	if( region0 > REGION_CUTOFF )
                		groupMember[0]->propogateChildren( newEnt, region0 );
                
                	if( region1 > REGION_CUTOFF )
                		groupMember[1]->propogateChildren( newEnt, region1 );
                
                	//cout << "region0: " << region0 << " region1: " << region1;LN
                	//cout << groupMember[0]->toString(0);
                }
                
       17551 -> void DescriminatoryR::goCalcMe( BaseEnt *inClient, intensityType inIntensity )
                {
                	intensityType region0, region1; // the intensities of both regions
                	getBothIntensities( inClient, inIntensity, region0, region1 );
                
                	sassert( groupMember[0] );
                	sassert( groupMember[1] );
                	if( region0 > REGION_CUTOFF )
                		groupMember[0]->goCalcMe( inClient, region0 );
                // here is our segfault
                	if( region1 > REGION_CUTOFF )
                		groupMember[1]->goCalcMe( inClient, region1 );
                }
                
                
                void DescriminatoryR::getBothIntensities( BaseEnt* inClient, intensityType inIntensity,
       17551 -> 	intensityType& region0, intensityType& region1 )
                {
                	region1 = getSecondRegionIntensity( inClient );
                	region0 = 1.0 - region1;
                
                	region0 *= inIntensity;
                	region1 *= inIntensity;
           1 -> }
           1 -> 
                #endif
                


Top 10 Lines:

     Line      Count

       58      17551
       74      17551
       20         20
       14          4
       81          1
       82          1

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

    35128   Total number of line executions
  5018.29   Average executions per line


*** File /home/tyler/Desktop/fland2/colorshiftr.cpp:
                #ifndef COLORSHIFTR_CPP
                #define COLORSHIFTR_CPP
                
                using namespace std;
                
                #include <sstream>
                #include "baserule.h"
                #include "templates.h"
                #include "tyler.h"
                #include "vertex.h"
                #include "colorshiftr.h"
                
                // a meRule.
                
                #if( DEBUG )
       ##### -> string ColorShiftR::getType(){ return "ColorShiftR"; }
                #endif
                
                
           6 -> ColorShiftR::ColorShiftR()
                	:BaseRule()
                {
                	shiftAmount = 0.1;
                	stayAmount = 0.0;
                	inverseStayAmount = 1.0;
                	sr = sg = sb = 1.0;
                }
                
          36 -> string ColorShiftR::assignValue( string valueType, istringstream *value, FmlParser* fPtr )
                {
                	if( valueType == "shiftamount" )
                	{
                		*value >> shiftAmount;
                	}
                	else if( valueType == "stayamount" )
                	{
                		*value >> stayAmount;
                		inverseStayAmount = 1.0 - stayAmount;
                	}
                	else if( valueType == "sr" || valueType == "stayred" || valueType == "red" )
                	{
                		*value >> sr;
                	}
                	else if( valueType == "sg" || valueType == "staygreen" || valueType == "green" )
                	{
                		*value >> sg;
                	}
                	else if( valueType == "sb" || valueType == "stayblue" || valueType == "blue" )
                	{
                		*value >> sb;
                	}
                	else
                	{
                		return BaseRule::assignValue( valueType, value, fPtr );
                	}
                	return "";
                }
                
                
       20052 -> void ColorShiftR::goCalcMe( BaseEnt* inClient, intensityType runIntensity )
                {
                	float startRed = VERT(inClient)->trueVertex.red;
                	float startGreen = VERT(inClient)->trueVertex.green;
                	float startBlue = VERT(inClient)->trueVertex.blue;
                
                
                	float rndRed = ( rnd() - 0.5 ) * 2.0 * shiftAmount;
                	float targetRed = startRed * inverseStayAmount;
                	targetRed += sr * stayAmount;
                	targetRed += rndRed;
                	if( targetRed > 1.0 )
                		targetRed = 1.0;
                	if( targetRed < 0.0 )
                		targetRed = 0.0;
                
                	float rndGreen = ( rnd() - 0.5 ) * 2.0 * shiftAmount;
                	float targetGreen = startGreen * inverseStayAmount;
                	targetGreen += sg * stayAmount;
                	targetGreen += rndGreen;
                	if( targetGreen > 1.0 )
                		targetGreen = 1.0;
                	if( targetGreen < 0.0 )
                		targetGreen = 0.0;
                
                	float rndBlue = ( rnd() - 0.5 ) * 2.0 * shiftAmount;
                	float targetBlue = startBlue * inverseStayAmount;
                	targetBlue += sb * stayAmount;
                	targetBlue += rndBlue;
                	if( targetBlue > 1.0 )
                		targetBlue = 1.0;
                	if( targetBlue < 0.0 )
                		targetBlue = 0.0;
                
                	runIntensity *= intensity;
                	float newRed = ( targetRed - startRed ) * runIntensity + startRed;
                	float newGreen = ( targetGreen - startGreen ) * runIntensity + startGreen;
                	float newBlue = ( targetBlue - startBlue ) * runIntensity + startBlue;
                
                	VERT(inClient)->trueVertex.red = newRed;
                	VERT(inClient)->trueVertex.green = newGreen;
                	VERT(inClient)->trueVertex.blue = newBlue;
           1 -> }
           1 -> 
                #endif


Top 10 Lines:

     Line      Count

       60      20052
       29         36
       20          6
      102          1
      103          1

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

    20096   Total number of line executions
  3349.33   Average executions per line


*** File /home/tyler/Desktop/fland2/camera.cpp:
                #ifndef CAMERA_CPP
                #define CAMERA_CPP
                
                using namespace std;
                
                #include <sstream>
                #include <math.h>
                #include <GL/glut.h>
                #include "camera.h"
                #include "fland.h"
                #include "main.h"
                #include "tyler.h"
                
         306 -> void Camera::setNearFarPlanes( double nearest, double farthest )
                {
                	//far = farthest * 1.00001;
                	near = nearest * cos( ( viewAngle * PI_D_180 ) ) * 0.9999;
                	far = near * farPercentage;
                }
                
       ##### -> string Camera::toString( int depth = 0 )
                {
                	string ind = indent( depth );
                	ostringstream out;
                	out << ind << "Camera::toString()";
                	out
                		<< ind << "\nx " << x
                		<< ind << "\ny " << y
                		<< ind << "\nz " << z
                		<< ind << "\nrotX " << rotX
                		<< ind << "\nroty " << rotY
                		<< ind << "\nrotZ " << rotZ
                		<< ind << "\nviewAngle " << viewAngle
                		<< ind << "\nnear " << near
                		<< ind << "\nfar " << far
                		<< ind << "\nspeed " << speed
                		<< ind << "\nvertSpeed " << vertSpeed
                		<< ind << "\nsideSpeed " << sideSpeed
                		<< ind << endl;
                
                	out << "\n\n";
                
                	//for( int i = 0; i<4; i++ )
                	//{
                	//	for( int j=0; j<4; j++ )
                	//	{
                	//		out << ind << "\tFrustum[" << i << "][" << j << "] " << frustum[i][j] << endl;
                	//	}
                	//}
                
                	#if( 0 )
                	// print out the frustum stuff
                   double   proj[16];
                   double   modl[16];
                   double   clip[16];
                   double   t;    /* Get the current PROJECTION matrix from OpenGL */
                   glGetDoublev( GL_PROJECTION_MATRIX, proj );    /* Get the current MODELVIEW matrix from OpenGL */
                   glGetDoublev( GL_MODELVIEW_MATRIX, modl );    /* Combine the two matrices (multiply projection by modelview) */
                
                	for( int i=0; i<16; i++ )
                	{
                		out << ind << "Projection[" << i << "] " << proj[i] << endl;
                	}
                	for( int i=0; i<16; i++ )
                	{
                		out << ind << "Modelview[" << i << "] " << modl[i] << endl;
                	}
                	#endif
                }
                
                
                // this function was written By Mark Morley, December 2000. markmorley.com
                // THANKS MARK!!! YOU DA MAN!!!
                // I (Tyler Patterson) changed the data types from "float" to "double".
                
                  //A plane can be defined with four numbers: A, B, and C define the plane's
                  //normal, and D defines its distance from the origin.
                
         306 -> void Camera::calcFrustum()
                {
                   double   proj[16];
                   double   modl[16];
                   double   clip[16];
                   double   t;    /* Get the current PROJECTION matrix from OpenGL */
                   glGetDoublev( GL_PROJECTION_MATRIX, proj );    /* Get the current MODELVIEW matrix from OpenGL */
                   glGetDoublev( GL_MODELVIEW_MATRIX, modl );    /* Combine the two matrices (multiply projection by modelview) */
                
                   clip[ 0] = modl[ 0] * proj[ 0] + modl[ 1] * proj[ 4] + modl[ 2] * proj[ 8] + modl[ 3] * proj[12];
                   clip[ 1] = modl[ 0] * proj[ 1] + modl[ 1] * proj[ 5] + modl[ 2] * proj[ 9] + modl[ 3] * proj[13];
                   clip[ 2] = modl[ 0] * proj[ 2] + modl[ 1] * proj[ 6] + modl[ 2] * proj[10] + modl[ 3] * proj[14];
                   clip[ 3] = modl[ 0] * proj[ 3] + modl[ 1] * proj[ 7] + modl[ 2] * proj[11] + modl[ 3] * proj[15];    clip[ 4] = modl[ 4] * proj[ 0] + modl[ 5] * proj[ 4] + modl[ 6] * proj[ 8] + modl[ 7] * proj[12];
                   clip[ 5] = modl[ 4] * proj[ 1] + modl[ 5] * proj[ 5] + modl[ 6] * proj[ 9] + modl[ 7] * proj[13];
                   clip[ 6] = modl[ 4] * proj[ 2] + modl[ 5] * proj[ 6] + modl[ 6] * proj[10] + modl[ 7] * proj[14];
                   clip[ 7] = modl[ 4] * proj[ 3] + modl[ 5] * proj[ 7] + modl[ 6] * proj[11] + modl[ 7] * proj[15];    clip[ 8] = modl[ 8] * proj[ 0] + modl[ 9] * proj[ 4] + modl[10] * proj[ 8] + modl[11] * proj[12];
                   clip[ 9] = modl[ 8] * proj[ 1] + modl[ 9] * proj[ 5] + modl[10] * proj[ 9] + modl[11] * proj[13];
                   clip[10] = modl[ 8] * proj[ 2] + modl[ 9] * proj[ 6] + modl[10] * proj[10] + modl[11] * proj[14];
                   clip[11] = modl[ 8] * proj[ 3] + modl[ 9] * proj[ 7] + modl[10] * proj[11] + modl[11] * proj[15];    clip[12] = modl[12] * proj[ 0] + modl[13] * proj[ 4] + modl[14] * proj[ 8] + modl[15] * proj[12];
                   clip[13] = modl[12] * proj[ 1] + modl[13] * proj[ 5] + modl[14] * proj[ 9] + modl[15] * proj[13];
                   clip[14] = modl[12] * proj[ 2] + modl[13] * proj[ 6] + modl[14] * proj[10] + modl[15] * proj[14];
                   clip[15] = modl[12] * proj[ 3] + modl[13] * proj[ 7] + modl[14] * proj[11] + modl[15] * proj[15];    /* Extract the numbers for the RIGHT plane */
                   frustum[0][0] = clip[ 3] - clip[ 0];
                   frustum[0][1] = clip[ 7] - clip[ 4];
                   frustum[0][2] = clip[11] - clip[ 8];
                   frustum[0][3] = clip[15] - clip[12];    /* Normalize the result */
                   t = sqrt( frustum[0][0] * frustum[0][0] + frustum[0][1] * frustum[0][1] + frustum[0][2] * frustum[0][2] );
                   frustum[0][0] /= t;
                   frustum[0][1] /= t;
                   frustum[0][2] /= t;
                   frustum[0][3] /= t;    /* Extract the numbers for the LEFT plane */
                   frustum[1][0] = clip[ 3] + clip[ 0];
                   frustum[1][1] = clip[ 7] + clip[ 4];
                   frustum[1][2] = clip[11] + clip[ 8];
                   frustum[1][3] = clip[15] + clip[12];    /* Normalize the result */
                   t = sqrt( frustum[1][0] * frustum[1][0] + frustum[1][1] * frustum[1][1] + frustum[1][2] * frustum[1][2] );
                   frustum[1][0] /= t;
                   frustum[1][1] /= t;
                   frustum[1][2] /= t;
                   frustum[1][3] /= t;    /* Extract the BOTTOM plane */
                   frustum[2][0] = clip[ 3] + clip[ 1];
                   frustum[2][1] = clip[ 7] + clip[ 5];
                   frustum[2][2] = clip[11] + clip[ 9];
                   frustum[2][3] = clip[15] + clip[13];    /* Normalize the result */
                   t = sqrt( frustum[2][0] * frustum[2][0] + frustum[2][1] * frustum[2][1] + frustum[2][2] * frustum[2][2] );
                   frustum[2][0] /= t;
                   frustum[2][1] /= t;
                   frustum[2][2] /= t;
                   frustum[2][3] /= t;    /* Extract the TOP plane */
                   frustum[3][0] = clip[ 3] - clip[ 1];
                   frustum[3][1] = clip[ 7] - clip[ 5];
                   frustum[3][2] = clip[11] - clip[ 9];
                   frustum[3][3] = clip[15] - clip[13];    /* Normalize the result */
                   t = sqrt( frustum[3][0] * frustum[3][0] + frustum[3][1] * frustum[3][1] + frustum[3][2] * frustum[3][2] );
                   frustum[3][0] /= t;
                   frustum[3][1] /= t;
                   frustum[3][2] /= t;
                   frustum[3][3] /= t;    /* Extract the FAR plane */
                   frustum[4][0] = clip[ 3] - clip[ 2];
                   frustum[4][1] = clip[ 7] - clip[ 6];
                   frustum[4][2] = clip[11] - clip[10];
                   frustum[4][3] = clip[15] - clip[14];    /* Normalize the result */
                   t = sqrt( frustum[4][0] * frustum[4][0] + frustum[4][1] * frustum[4][1] + frustum[4][2] * frustum[4][2] );
                   frustum[4][0] /= t;
                   frustum[4][1] /= t;
                   frustum[4][2] /= t;
                   frustum[4][3] /= t;    /* Extract the NEAR plane */
                   frustum[5][0] = clip[ 3] + clip[ 2];
                   frustum[5][1] = clip[ 7] + clip[ 6];
                   frustum[5][2] = clip[11] + clip[10];
                   frustum[5][3] = clip[15] + clip[14];    /* Normalize the result */
                   t = sqrt( frustum[5][0] * frustum[5][0] + frustum[5][1] * frustum[5][1] + frustum[5][2] * frustum[5][2] );
                   frustum[5][0] /= t;
                   frustum[5][1] /= t;
                   frustum[5][2] /= t;
                   frustum[5][3] /= t;
                }
                
       ##### -> bool Camera::pointInFrustum( double inX, double inY, double inZ )
                {
                	// dont check for the near or far clip planes.
                   for( int p = 0; p < 4; ++p )
                      if( frustum[p][0] * inX + frustum[p][1] * inY + frustum[p][2] * inZ + frustum[p][3] <= 0.0 )
                         return false;
                   return true;
                }
                
         306 -> void Camera::updateLocation()
                {
                	Fland *fl = getFlandPtr();
                
                	// slow down the camera
                	double speedBreak = CAMERA_SPEED_BREAK * fl->env.timeSlice;
                	speed /= ( 1.0 + speedBreak );
                	vertSpeed /= ( 1.0 + speedBreak );
                	sideSpeed /= ( 1.0 + speedBreak );
                
                	// scale the speed to the timeslice
                	double thisSpeed = speed * fl->env.timeSlice;
                	double thisVertSpeed = vertSpeed * fl->env.timeSlice;
                	double thisSideSpeed = sideSpeed * fl->env.timeSlice;
                
                	// scale the speed to the nearest rendered object
                	thisSpeed *= fl->closestRenderDistance;
                	thisVertSpeed *= fl->closestRenderDistance;
                	thisSideSpeed *= fl->closestRenderDistance;
                
                	double rx = rotX * PI_D_180;
                	//double ry = rotY * PI_D_180;
                	double ry = rotY * PI_D_180;
                	x += thisSpeed * cos( rx ) * sin( ry );
                	y -= thisSpeed * sin( rx );
                	z -= thisSpeed * cos( rx ) * cos( ry ); // subtract from Z because the Z axis points at your face initally
                
                	// vertical movement
                	x += thisVertSpeed * sin( rx ) * sin( ry );
                	y += thisVertSpeed * cos( rx );
                	z -= thisVertSpeed * sin( rx ) * cos( ry );
                
                	// Side to side movement
                	x -= thisSideSpeed * cos( ry );
                	//y += thisSideSpeed * cos( rz + PI / 2.0 );
                	z -= thisSideSpeed * sin( ry );
                
                	updateGlView();
                
                
                	//cout << x << "\n" << y << "\n" << z << "\n";
                	//cout << "\t" << rotX << "\n\t" << rotY << "\n" << endl;
                }
                
                // opengL uses the RIGHT HAND RULE for rotation
         306 -> void Camera::updateGlView()
                {
                	glLoadIdentity();
                
                	//glRotatef(rotZ, 0.0, 0.0, 1.0);
                	glRotatef(rotX, 1.0, 0.0, 0.0);
                	glRotatef(rotY, 0.0, 1.0, 0.0);
                
                
                
                	//glPushMatrix();
                	//glTranslatef(x, y, z);
                	GLfloat nDis = near + ((far - near)*0.1);
                	GLfloat fDis = far;
                	glFogf( GL_FOG_START, nDis );
                	glFogf( GL_FOG_END, fDis );
                	glFogf( GL_FOG_DENSITY, 2.0 / fDis );
                	glFogfv( GL_FOG_COLOR, fogColor );
                	glClearColor( fogColor[0], fogColor[1], fogColor[2], fogColor[3] );
                	calcFrustum();
                	//glPopMatrix();
                
                
                	//printFrustum();
                	//glFrustum(-1.0, 1.0, -h, h, 3.0, 600.0);
                }
                
                
                inline double Camera::calcVisibility( double inX, double inY, double inZ )
                {
                	return distance( inX, x, inY, y, inZ, z );
                }
                
           1 -> Camera::Camera()
                {
                	resetView();
                }
                
           1 -> void Camera::resetView()
                {
                	x = y = z = rotY = rotX = rotZ = speed = 0.0;
                	farPercentage = 200;
                	viewAngle = 1.5;
                	near = 0.0001; // just for now
                	far = 600; // ditto
                	speed = 0.0;
                	vertSpeed = 0;
                	sideSpeed = 0;
                //	rotX = 2.1;
                	rotZ = 0.0;
                //	rotY = -15.6;
                //	x = 0.0;
                	y = 0.1;
                //	z = 2.0;
                	fogColor[0] =  0.3; // red
                	fogColor[1] =  0.85; // green
                	fogColor[2] =  0.85; // blue
                	fogColor[3] =  1.0; // alpha?
                }
                
       ##### -> void Camera::setNearFarPlanes( )
                {
                	Fland* fl = getFlandPtr();
                  glMatrixMode(GL_PROJECTION);
                  glLoadIdentity();
                  //glFrustum(-1.0, 1.0, -env.screenHeight, env.screenHeight, near, far);
                
                  //cout << "x: " << x << " y: " << y << " z: " << z;
                  //cout << "\trotX: " << rotX << " rotY: " << rotY << " rotZ: " << rotZ << endl;
                
                  gluPerspective(viewAngle, (GLdouble)fl->env.screenWidth / (GLdouble)fl->env.screenHeight, near, far );
                  glMatrixMode(GL_MODELVIEW);
                  //glTranslatef( 0, 0, -0.2 );
                }
                
         306 -> void Camera::printFrustum()
                {
                	Fland* fl = getFlandPtr();
                	sassert( fl );
                	glMatrixMode(GL_PROJECTION);
                	gluPerspective(viewAngle, (GLdouble)fl->env.screenWidth/(GLdouble)fl->env.screenHeight, near, far );
                	glMatrixMode(GL_MODELVIEW);
           1 -> }
           1 -> 
                
                
                #endif


Top 10 Lines:

     Line      Count

       14        306
       79        306
      166        306
      211        306
      286        306
      244          1
      249          1
      293          1
      294          1

Execution Summary:

       12   Executable lines in this file
       12   Lines executed
   100.00   Percent of the file executed

     1534   Total number of line executions
   127.83   Average executions per line


*** File /home/tyler/Desktop/fland2/buildhtml.cpp:
                #ifndef DIAGNOSE_CPP
                #define DIAGNOSE_CPP
                // this file contains fland diagnostic functions
                
                using namespace std;
                #include <string>
                #include <sstream>
                #include <fstream>
                #include <iostream>
                #include <iomanip>
                // this is needed to see if a rule is a groupr
                #include <typeinfo>
                #include "fland.h"
                #include "baseent.h"
                #include "baserule.h"
                #include "buildhtml.h"
                #include "groupr.h"
                #include "defines.h"
                
                // constructor
       ##### -> BuildDiagnosticHtml::BuildDiagnosticHtml( Fland* fland )
                {
                	if( fland == NULL )
                	{
                		cout << "Error. No fland pointer given in BuildDiagnosticHtml constructor"; LN
                	}
                	else
                	{
                		buildHtml( fland );
                	}
                }
                
                // loop through each entity.
       ##### -> void BuildDiagnosticHtml::recurseEntities( BaseEnt* entity, ostream& out )
                {
                	// put this entity and the rules that will follow into a table
                	// the table will have two or two columns, one for this rule and one for it's children.
                
                	// this will indent the html nicely
                	string ind;
                	for( int i=0; i<entity->iterationDepth; i++ ){ ind = ind + " "; }
                
                	// create the individual file
                	string individualFileName;
                	individualFileName = buildIndividualFile( entity );
                
                	// this table encloses the entity
                	out << "<!-- BEGIN ENTITY -->\n";
                	out << ind << "<table border=0 cellpadding=0 cellspacing=0><tr><td valign=top>";
                
                		// this puts a table and border around the entity and it's rules.
                		out << "<table border=1 cellpadding=0 cellspacing=0><tr><td valign=top>";
                
                			// This table puts the entity in it's own table row, with it's rules in another.
                			out << "<!-- THIS TABLE SEPERATES THE ENTITY AND IT'S RULES -->";
                			out << "<table border=0 cellpadding=0 cellspacing=0><tr><td valign=top>";
                				// this prints out the hyperlink to the individual file
                				out << "<a href='" << individualFileName << "' target='_blank'>";
                				out << entity->iterationDepth ;
                				out << "</a>&nbsp;";
                			out << "</td>";
                				if( entity->rules.size() > 0 )
                				{
                			out << "<td valign=top>";
                			out << "\n<!-- BEGIN RULES -->";
                					for( int i=0; i<entity->rules.size(); i++ )
                					{
                						out << entity->rules[i].getFmlName() << "-" << entity->rules[i].getIntensity() << "<br>\n";
                						//recurseRules( entity->rule.groupMember[i], out );
                					}
                			out << "<!-- END RULES -->";
                			out << "</td>";
                				}
                			out << "</tr></table>\n";
                			out << "<!-- END SEPERATE ENTITY AND IT'S RULES -->";
                		out << "</tr></table>\n";
                
                	out << "</td>";
                
                		// call this entities children
                		if( entity->child.size() > 0 )
                		{
                			out << "<td valign='top'>\n";
                			for( int i=0; i<entity->child.size(); i++ )
                			{
                				recurseEntities( entity->child[i], out );
                			}
                			out << "</td>\n";
                		}
                	out << ind << "</tr></table>\n";
                }
                
                //// loop through each rule that belongs to an entity
                //void BuildDiagnosticHtml::recurseRules( BaseRule* rule, ostream& out )
                //{
                //	string fileName;
                //	fileName = buildIndividualFile( rule );
                //
                //	bool hasGroupMembers = false;
                //	if( typeid( GroupR ).name() == typeid( *rule ).name() ){ hasGroupMembers = true; }
                //
                //	if( hasGroupMembers ){ out << "<table border=0 cellpadding=0 cellspacing=0><tr><td valign=top>"; }
                //
                //	out << "<a href='" << fileName << "' target='_blank'>";
                //	// Print the visible index string
                //	out << rule->fmlName << "(" << rule->intensity << ")";
                //	string test;
                //	out << "</a>&nbsp;\n";
                //	if( !hasGroupMembers ){ out << "<br>"; } // if this text doesn't go in a table, print a break
                //
                //	// check to see if the rule is a groupRule. If so, call this function on it's groupmembers
                //	if( hasGroupMembers )
                //	{
                //		out << "</td>";
                //		GroupR *thisRule = GROUPR( rule );
                //		out << "<td>";
                //		for( int i=0; i<thisRule->size(); i++ )
                //		{
                //			out << "<!-- BEGIN GROUPMEMBER -->\n";
                //			recurseRules( thisRule->groupMember[i], out );
                //			out << "\n<!-- END GROUPMEMBER -->";
                //		}
                //		out << "</td>";
                //		out << "</tr></table>\n";
                //	}
                //}
                
                
                // a pointer to fland, and a string filename. This builds the main index file.
       ##### -> void BuildDiagnosticHtml::buildHtml( Fland* fland )
                {
                	cout << "outputting index.html..." << endl;
                	ofstream ifile( "html/index.html" );
                
                	ifile << setprecision( 2 );
                
                	ifile << "\n\n<html>\n<head>"
                	<< "<script language='javascript' src='html/functions.js'></script>"
                	<< "<title>Fland Diagnostic Output</title></head>\n<body>\n";
                	ifile << "<b>Fland Diagnostic Output</b><br>\n";
                	maxRow = 0;
                	int numEntities = fland->firstEnt->getCount( maxRow );
                	ifile << numEntities << " Entities<br>\n" << maxRow << " Iterations Deep<br>\n";
                
                	recurseEntities( fland->firstEnt, ifile );
                
                	ifile.close();
                	cout << "done" << endl;
           1 -> }
           1 -> 
                
                
                
                #endif
                


Top 10 Lines:

     Line      Count

      149          1
      150          1

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     0.40   Average executions per line


*** File /home/tyler/Desktop/fland2/baserule.cpp:
                // Rules govern what an object's attributes will be, sort of like DNA.
                // different types of rules inherit from BaseRule.
                #ifndef BASE_RULE_CPP
                #define BASE_RULE_CPP
                
                using namespace std;
                
                #include <sstream>
                #include <cassert>
                #include "tyler.h"
                #include "baserule.h"
                #include "fmlparser.h"
                #include "baseent.h"
                
                // The -- client -- is the entity that is using the rule.
                
                #if( DEBUG )
       ##### -> string BaseRule::toString( int depth )
                {
                
                	ostringstream out;
                	string ind = indent( depth );
                	out
                		<< ind << "BaseRule::\n"
                		<< ind << "childRule         " << childRule << endl
                		<< ind << "numPropogates     " << numPropogates << endl
                		<< ind << "fmlName           " << this->fmlName << endl
                		//<< ind << "fmlRule        " << pBool( fmlRule ) << endl
                		<< ind << "this              " << this << endl
                ;
                	return out.str();
                }
                
                
                #endif
                
          29 -> BaseRule::BaseRule()
                {
                	childRule = NULL;
                	numPropogates = 0;
                	intensity = 1.0;
                }
                
                // every derrived class of baserule has an assignValue function.
                // if the value is not assigned to something inside it's assignValue,
                // it calles the BaseRule assignvalue, which returns an error.
                /*
                When an entity is being split,
                All the entity's rules check themselves, but only one level deep. In a globe, For
                example, the sphereRule will go for a certain number of iterations, and the
                globeRule will for a different number. But, the globe Rule wont check any of it's
                groupMembers.
                */
                // The param *file is here so that when returning errors we can return where the error occured.
          32 -> string BaseRule::assignValue( string valueType, istringstream *value, FmlParser *fPtr )
                {
                	if( valueType == "numiterations" || valueType == "numpropogates" )
                	{
                			*value >> numPropogates;
                	}
                	else if( valueType == "intensity" )
                	{
                		*value >> intensity;
                	}
                	else if( valueType == "childrule" )
                	{
                		BaseRule* inRule = fPtr->nameMap[ value->str() ];
                
                		// Make sure the rule is legitimate. If not, quit now.
                		if( !inRule )
                		{
                			ostringstream out;
                			out << "Bad Rule Name \"" << value->str() << "\"";
                			throw FmlParserFatalError( out.str() );
                
                			return( "ERROR" );	// This currently doesn't work.
                		}
                		childRule = inRule;
                	}
                	else
                	{
                		return( "Bad Type: " + valueType + " = " + value->str() );
                	}
                	return "";
                }
                
                
       17555 -> void BaseRule::propogateRules( BaseEnt* newEnt, int remainingPropogates, intensityType nIntensity )
                {
                	sassert( newEnt );
                
                	if( remainingPropogates > 0 )
                	{
                		newEnt->addAndRunRule( this, remainingPropogates - 1, nIntensity );
                	}
                	else
                	{
                		propogateChildren( newEnt, nIntensity );
                	}
                
                }
                
                // this is the generic propogateChild. GroupR and descriminatoryR have their own.
        1779 -> void BaseRule::propogateChildren( BaseEnt* newEnt, intensityType nIntensity )
                {
                	if( childRule )
                	{
                		// the rule will be set to propogate this many times.
                		int numPropogates = childRule->numPropogates;
                		newEnt->addAndRunRule( childRule, numPropogates, nIntensity );
                	}
                	else
                	{
                		// this is a case that happens often.
                		// Should we leave the behavior to happen this way?
                		//cout << "no childrule! ";LN
                	}
                }
                
       ##### -> void BaseRule::destructor( bool willDelete )
                {
                
                }
                
       ##### -> void BaseRule::goCalcMe( BaseEnt *inClient, intensityType runIntensity )
                {
                	LN
                }
                
                
       ##### -> BaseRule* BaseRule::startUse()
                { return this; }
                
           1 -> void BaseRule::endUse(){}
           1 -> 
                
                #endif
                
                
                
                
                #if( 0 )
                
                /*
                
                 NOTE!!!
                 To create a new rule class, do these steps
                
                 - create a new rule file and copy and paste the below code into it.
                 - do a search and replace SOMETHING for the rule name inside the file
                 - in defines.h put a line in with the other classes for quick dynamic casting
                	example: #define ROUGHR( x ) dynamic_cast< RoughR* >( x )
                 - in includes.cpp insert a line in the three places (near the end of the file)
                 - in fmlparser.cpp function evaluateRule, insert code to create your class
                 - IF your rule will extend anything other then BaseRule (for example GroupR), then do a search for
                 	GroupR (or something else) in the code and put the parent's rules name where it applies.
                 - Edit your new rule and start using it!
                */
                
                // COPY AND PASTE THIS CODE WHEN CREATING A NEW RULE.
                // Start copying here...
                
                #ifndef SOMETHING_CPP // TODO: insert class name before _CPP
                #define SOMETHING_CPP
                /*
                	SOMETHING
                	- Applies to:
                		eg. Verticies
                
                	- Description:
                
                	- Values it can recieve
                
                	- How it works
                
                */
                
                #include <iostream>
                #include <sstream>
                #include "tyler.h"
                #include "templates.h"
                #include "baserule.h"
                
                class SOMETHING : public BaseRule
                {
                	public:
                	SOMETHING();
                	virtual SOMETHING();
                
                	virtual void destructor( bool willDelete = false );
                
                	// This makes the rule do it's thing. Call it and pass the entity that
                	// is using the rule (client), and the rule will alter the appropriate attributes
                	// of the client.
                	virtual void goCalcMe( BaseEnt *inClient, intensityType runIntensity );
                
                	// used in the parse functions. assigns value to valuetype.
                	// returns an error, if there was one. Otherwise, returns blank ( "" )
                	virtual string assignValue( string valueType, istringstream *value, FmlParser* fPtr );
                
                	#if( DEBUG )
                	virtual string toString( int );
                	virtual string getType(){ return "SOMETHING"; }
                	#endif
                	static Reuse< BaseRule, SOMETHING > reuse;
                
                };
                
                // EVERYTHING AFTER THIS GOES IN THE .CPP
                #if( DEBUG )
                string SOMETHING::toString( int i )
                {
                	ostringstream out;
                	ind = indent( i );
                	out << ind << " SOMETHING::\n";
                	out << BaseRule::toString( i );
                	return out.str();
                }
                #endif
                
                // mention the reuse rule class
                Reuse< BaseRule, SOMETHING > SOMETHING::reuse;
                
                
                string SOMETHING::assignValue( string valueType, istringstream *value, FmlParser* fPtr )
                {
                	if( valueType == "test1" )
                	{
                		// *value >> test1;
                	}
                	else
                	{
                		return BaseRule::assignValue( valueType, value, fPtr );
                	}
                	return "";
                }
                
                SOMETHING::SOMETHING()
                	:BaseRule();
                {
                
                }
                
                void SOMETHING::destructor( bool willDelete )
                {
                
                	BaseRule::destructor( willDelete );
                }
                
                void SOMETHING::goCalcMe( BaseEnt *inClient, intensityType runIntensity )
                {
                	cout << "need to overload goCalcMe still! "; LN
                }
                
                #endif
                
                // THIS IS THE END OF WHAT YOU SHOULD COPY AND PASTE
                
                
                #endif
                


Top 10 Lines:

     Line      Count

       88      17555
      104       1779
       55         32
       37         29
      134          1
      135          1

Execution Summary:

       10   Executable lines in this file
       10   Lines executed
   100.00   Percent of the file executed

    19397   Total number of line executions
  1939.70   Average executions per line


*** File /home/tyler/Desktop/fland2/baseent.cpp:
                // Every entity inherits from BaseEnt.
                // BaseEnt is purely abstract. You can only inherit from it, not instantiate from it. --- ACTUALLY, you can. :)
                // This is good so we can have a root entity.
                #ifndef BASEENT_CPP
                #define BASEENT_CPP
                
                using namespace std;
                
                #include <iostream>
                #include <sstream>
                #include "tyler.h"
                #include "fland.h"
                #include "camera.h"
                #include "baseent.h"
                #include "templates.h"
                ////////////////////////////////////////////////////////////////////////////
                // The implementation of the BaseEnt class
                
       ##### -> Reuse< BaseEnt, BaseEnt > BaseEnt::reuse;
                
                /*
                // This is adam's singlton class. It creats only one instance of
                // itself.
                class Singlton
                {
                	private:
                		static Singlton instance;
                
                		Singlton();
                
                
                	public:
                		static Singlton getInstance()
                		{
                			return instance;
                		}
                };
                */
                
                #if DEBUG
       ##### -> void BaseEnt::dump( ostream& out, int depth )
                {
                	out << this->toString( depth ) << endl << endl;
                
                	for( int i=0; i<child.size(); i++ )
                	{
                		child[i]->dump( out, depth + 1 );
                	}
                }
                
       ##### -> string BaseEnt::toString( int indentNum )
                {
                	ostringstream out;
                	//cout << "BaseEnt " << this << visibility <<endl;
                
                	string ind = indent( indentNum );
                
                	out << ind << "BaseEnt::" << endl;
                	out << ind << "This              " << this << endl;
                	out << ind << "Parent            " << parent << endl;
                	out << ind << "Iteration Depth   " << iterationDepth << endl;
                	out << ind << "isVisible         " << isVisible << endl;
                	out << ind << "visibility        " << visibility << endl;
                	out << ind << "createVisibility  " << createVisibility << endl;
                	out << ind << "isSplit           " << isSplit << endl;
                	#if DEBUG
                	out << ind << "isDeleted         " << isDeleted << endl;
                	if( isDeleted )
                		out << ind << "********** THIS OBJECT HAS BEEN DELETED! IT SHOULDN'T BE BEING USED! **********" << endl;
                	#endif
                	for( int i=0; i<rules.size(); i++ )
                		out << rules[i].toString( indentNum );
                	out << ind << "child.size()      " << child.size() << endl;
                	out << ind << "child:" << endl;
                		for( int i=0; i<child.size(); ++i )
                		{
                			out << ind << "\t" << i << ": " << child[i] << "   " << child[i]->getType() << endl;
                		}
                
                	return out.str();
                }
                
       ##### -> string RulePointer::toString( int indentNum )
                {
                	string ind = indent( indentNum );
                	ostringstream out;
                
                	if( rule )
                		out << ind << "Rule: " << rule->fmlName << endl;
                
                	return out.str();
                }
                
       ##### -> void BaseEnt::printGeneology( int depth )
                {
                	for( int i=0; i<depth; i++ )
                	{
                		cout << ".";
                	}
                	cout << this->getType() << endl;
                	for( int i=0; i<child.size(); i++ )
                	{
                		child[i]->printGeneology( depth + 1 );
                	}
                }
                
       ##### -> void BaseEnt::printType(){ cout << "BaseEnt" << endl; }
       ##### -> string BaseEnt::getType(){ return( "BaseEnt" ); }
                #endif
                
                // called by split()
                // Take all the right rules from our parent.
                // This function is called from each child entity of a rule that was just split.
                // It is called before the children's rules are processed(duh, they dont exist until after this function)
                // This function loops through each of the rules of the entity that was just split, runs and inserts
                // the current entities rules into the new child.
       17555 -> void BaseEnt::takeRulesFromParent()
                {
                	for( int i=0; i < parent->rules.size(); i++ )
                	{
                		parent->rules[i].propogateRules( this );
                	}
                }
                
        2000 -> BaseEnt::~BaseEnt()
                {
                
                	//if( nextEnt ) delete nextEnt; // kill our kids
                	// TODO: put the delete rules code here!
                	//if( meRule && meRule->parent == this ) delete meRule; // kill the rules that made us
                	//if( splitRule && splitRule->parent == this ) delete splitRule; // kill the rules that made our kids.
                	//delete rule;
                }
                
                
       18602 -> BaseEnt::BaseEnt()
                {
                	//meRule = new GroupR;
                	//splitRule = new GroupR;
                	BaseEnt::constructor( NULL );
                }
                
                
       36158 -> int BaseEnt::constructor( BaseEnt *inParent )
                {
                
                	// Pass the object's parent to it.
                	parent = inParent;
                
                	bound.initalize();
                
                	if( parent ) // if we aren't the root entity
                	{
                		iterationDepth = parent->iterationDepth + 1; // depth increases each iteration
                		bound.radius = parent->bound.radius / 3.0; // TODO fix this to calculate more acurately the needed bounding sphere
                		// If any rules change the bound radius, rerun this calulation!
                		createVisibility = parent->bound.radius / bound.radius;
                	}
                	else // we are the root entity
                	{
                		createVisibility = 0.0; // we never get deleted.
                		iterationDepth = 0;
                	}
                	seed = 0; // The random seed. this will have to be set directly by the parent.
                	child.clear();
                	viewDistance = 0.0;
                	isSplit = false;
                
                	rules.clear();
                
                	#if DEBUG
                	isDeleted = false;
                	#endif
                
                	return 0;
                }
                
     1891690 -> void BaseEnt::draw()
                {
                
                	// tell all our children to draw themselves.
                	for( int i=0; i<child.size(); i++ )
                	{
                		child[i]->draw();
                	}
                
                }
                
                //int BaseEnt::calculateMe()
                //{
                //	// loop through and run all the me-rules.
                //	tSrand( seed );
                //	for( int i=0; i<rules.size(); i++ )
                //	{
                //		rules[i].goCalcMe( this );
                //	}
                //
                //	return 0;
                //}
                
                // When the entity needs to be split into smaller pieces.
        1983 -> void BaseEnt::split()
                {
                	if( !isSplit ) // make sure not already split
                	{ // We are NOT split yet
                		isSplit = true;
                
                		// Propogate the parent's rules, and calculate run calculateMe on each child.
                		for( int i=0; i<child.size(); i++ )
                		{
                			child[i]->takeRulesFromParent();
                			//child[i]->calculateMe();
                			child[i]->calcVisibility();
                			//child[i]->recursiveSplit(); // if necessary, split the new child.
                		}
                
                	} // not isSplit
                	else // We are split. This should actually never be called because recursiveSplit() checkes if the entity is already split.
                	{
                		cout << "Shouldn't be here! "; LN
                		// loop through and split all our kids.
                		for( int i=0; i<child.size(); i++ )
                		{
                			//if( rnd() < 0.8 )
                				child[i]->split();
                		}
                	}
                }
                
                
                
       ##### -> int BaseEnt::calcPass1()
                {
                	return 0;
                }
                
     1891801 -> void BaseEnt::calcVisibility()
                {
                	Fland *fl = getFlandPtr();
                	assert( fl );
                	Camera *cam = fl->camera;
                
                		// find the distance, and compute the visibility for the entity
                		DIS_TYPE dist = distance( cam->x, bound.x, cam->y, bound.y, cam->z, bound.z );
                		viewDistance = dist;
                
                	// check if the object is anywhere inside the view frustum
                	if( fl->camera->sphereInFrustum( bound.x, bound.y, bound.z, bound.radius ) )
                	{
                		// set isVisibile to TRUE
                		isVisible = true;
                		visibility = bound.radius / dist;
                		visibility *= fl->getInverseSplitVisibility();
                
                		// This will be used in setting the near and far clip plane for openGL.
                		// to determine how close and far the viewer should be able to see.
                		if( dist < fl->closestRenderDistance )
                			fl->closestRenderDistance = dist;
                		if( dist > fl->farthestRenderDistance )
                			fl->farthestRenderDistance = dist;
                
                		if( !isSplit )
                		{
                			double morphAmount = visibility;
                
                			morphAmount = morphAmount - createVisibility;
                			morphAmount *= ( 1.0 / (1.0 - createVisibility) );
                			morphAmount *= ( 1.0 / fl->morphPercentage );
                			if( morphAmount > 1.0 )
                				morphAmount = 1.0;
                			if( morphAmount < 0.0 )
                				morphAmount = 0.0;
                
                			calcMorph( morphAmount );
                		}
                	}
                	else
                	{
                		// the object is not inside the view frustum
                		isVisible = false;
                		calcMorph( (double)isSplit );
                
                	}
                }
                
                // the baseEnt version does nothing.
           1 -> void BaseEnt::calcMorph(double morphAmount ){}
                
                // goes through each entity and calculates the visibility for it.
         306 -> void BaseEnt::recursiveCalcVisibility()
                {
                	calcVisibility();
                	if( isVisible ) // if this entity is not visible, we know that none of
                	{// it's children are either. Dont bother calculating them.
                		for( int i=0; i<child.size(); i++ )
                		{
                			child[i]->recursiveCalcVisibility();
                		}
                	}
                	else
                	{
                		// We aren't visible, so none of our children are either.
                		// set them all to invisible.
                		setVisible( false );
                	}
                }
                
         306 -> void BaseEnt::recursiveSplit()
                {
                	Fland *fl = getFlandPtr();
                	if( isSplit )
                	{
                		for( int i=0; i<child.size(); i++ )
                		{
                			child[i]->recursiveSplit();
                		}
                	}
                	else
                	{
                		if( shouldSplit() )
                		{
                			split();
                			// now check his children to see if they should split too.
                			for( int i=0; i<child.size(); i++ )
                			{
                				// split() calculates the visibility, all we have to do is tell
                				// it to split now.
                				child[i]->recursiveSplit();
                			}
                		}
                	}
                }
                
                // The return parameter is whether or not this entity can be deleted.
        1224 -> bool BaseEnt::recursiveUnSplit()
                {
                
                				// debug
                			if( this->getType() == "BaseEnt" )
                				{LN}
                	// can we be unsplit?
                	// only if all our children are ready to be deleted.
                	bool retValue = true;
                	// go out to the leaves first, then un-split on your way back in.
                	for( int i=child.size() - 1; i>=0; i-- )
                	{
                		// even if we find one child that cant be un-split, still do the rest, to get
                		// them all as un-split as possible.
                		if( child[i]->recursiveUnSplit() == false )
                				retValue = false;
                	}
                
                			// debug
                			if( this->getType() == "BaseEnt" )
                				{cout << retValue; LN}
                
                	// if our children cant all be deleted, bail out now.
                	if( !retValue )
                		return false;
                	// NOTE: if we get to here and retValue is still true, then
                	// all are children are un-split and are able to be deleted.
                
                	// Now check if WE are able to be deleted.
                	// Check this entity's visibility
                	// if we're visible and shouldn't be un-split based on visiblity
                	// then bail out now.
                	if( !shouldUnSplit() )
                		return false;
                
                			// debug
                			if( this->getType() == "BaseEnt" )
                				{cout << retValue; LN}
                
                	// if we are a leaf (dont have any children), skip all this and return true.
                	if( isSplit )
                	{
                		// If we cant be deleted because the special check returns false, bail out.
                		if( this->specialUnSplitCheck() == false )
                			return false;
                
                		// If everything checks out, we can be un-split!
                		this->unSplit();
                	}
                
                	return true;
                }
                
       ##### -> bool BaseEnt::specialUnSplitCheck()
                {
                	return true;
                }
                
                // call this function on an entity to see if it can be un-split
                // IE - so all it's children are all destroyed.
                
                // This check is necessary because the unsplit function destroys all the
                // children, and they may be visible.
                
                // NOTE: it calls itself on entities that are not split yet, and then
                // all it does is check if they are visible or not. Still works the same.
       ##### -> bool BaseEnt::canUnSplit()
                {
                	// first check if it should un-split.
                	// This means that if we un-split the entity,
                	// it would only be resplit the next time.
                	if( shouldUnSplit() )
                		return false;
                
                	// Now check our children (if we have any)
                	// if not, then we are good for unspliting!
                	if( isSplit )
                	{
                		// loop through and check all the children.
                		for( int i=0; i<child.size(); i++ )
                		{
                			// if the child cannot be unsplit, then neither can we.
                			if( child[i]->canUnSplit() == false )
                				return false;
                		}
                	}
                
                	return true;
                }
                
       ##### -> int BaseEnt::getCount( int& deepestIteration )
                {
                	// childrenCount starts at one because this entity is a child (of it's parent)
                	// if it was zero the final count would also be zero.
                	int childrenCount = 1;
                	for( int i=0; i<child.size(); i++ )
                	{
                		childrenCount += child[i]->getCount( deepestIteration );
                	}
                	if( iterationDepth > deepestIteration )
                	{
                		deepestIteration = iterationDepth;
                	}
                	return childrenCount;
                }
                
                
                // Sets the visibility of an entity and all it's children.
                // used where the visibility is recursively calulated.
      307180 -> void BaseEnt::setVisible( bool inVisibility )
                {
                	// set the visibility
                	visibility = inVisibility;
                	// now set the visibility of the children
                	for( int i=0; i<child.size(); i++ )
                		child[i]->setVisible( inVisibility );
                }
                
                // kill all children.
         111 -> void BaseEnt::unSplit()
                {
                	// loop through children
                
                	for( int i=0; i<child.size(); i++ )
                	{
                		//cout << i << endl;
                		// delete the child
                		sassert( child[i] );
                		child[i]->destructor();
                	}
                	// clean out the child array
                	child.clear();
                	// set us back to un-split
                	isSplit = false;
                	// Now that we arent split anymore, calculate our visibility.
                	calcVisibility();
                }
                
       17556 -> void BaseEnt::addRule( BaseRule* r, int p, intensityType i )
                {
                	sassert( r );
                	sassert( i > 0 && i <= 1.0001 );
                
                	RulePointer nRule;
                	nRule.setRule( r );
                	nRule.setIntensity( i );
                	nRule.setRemainingPropogates( p );
                	rules.push_back( nRule );
                }
                
       17555 -> void BaseEnt::addAndRunRule( BaseRule* r, int p, intensityType  i)
                {
                	addRule( r, p, i );
                	r->goCalcMe( this, i );
                }
                
                
         953 -> void BaseEnt::destructor( bool willDelete )
                {
                
                	int i;
                	// delete all the children
                	for( i=0; i<child.size(); i++ )
                	{
                		child[i]->destructor();
                	}
                
                	// this is for possible future use.
                	//for( i=0; i<rules.size(); i++ )
                	//	if( rules[i]->parent == this )
                	//		rules[i].getRule()->endUse(); // this function doesnt do anything
                
                
                	if( parent )
                	{
                		// clear our parent's pointer to us
                		//remove( parent->child.begin(), parent->child.end(), this );
                	}
                	// This checks and if the object isn't being deleted somewhere else, it deletes it.
                	#if DEBUG
                	isDeleted = true;
                	#endif
                }
                
       17556 -> RulePointer::RulePointer()
                {
                	rule = NULL;
                	remainingPropogates = 0;
           1 -> }
           1 -> 
                #endif


Top 10 Lines:

     Line      Count

      237    1891801
      178    1891690
      444     307180
      144      36158
      136      18602
      473      17556
      519      17556
      117      17555
      485      17555
      125       2000

Execution Summary:

       30   Executable lines in this file
       30   Lines executed
   100.00   Percent of the file executed

  4222539   Total number of line executions
140751.30   Average executions per line


*** File /home/tyler/Desktop/fland2/averager.cpp:
                #ifndef AVERAGER_CPP
                #define AVERAGER_CPP
                // This rule takes a vertex and sticks it between it's parent and it's aunts.
                // in all attributes that apply.
                // (position, color)
                
                using namespace std;
                
                #include "baserule.h"
                #include "defines.h"
                #include "tyler.h"
                #include "vertex.h"
                #include "templates.h"
                #include "averager.h"
                #include <typeinfo>
                
                #if( DEBUG )
       ##### -> string AverageR::getType(){ return "AverageR"; }
       ##### -> string AverageR::toString( int ind ){ return indent( ind ) + "AverageR::\n" + BaseRule::toString( ind ); }
                #endif
                
           3 -> string AverageR::assignValue( string valueType, istringstream *value, FmlParser* fPtr )
                {
                	if( valueType == "test1" )
                	{
                		// *value >> test1;
                	}
                	else
                	{
                		return BaseRule::assignValue( valueType, value, fPtr );
                	}
                	return "";
                }
                
           3 -> AverageR::AverageR( )
                	:BaseRule()
                {
                }
                
                
                
       17555 -> void AverageR::goCalcMe( BaseEnt* inClient, intensityType runIntensity )
                {
                	Vertex* inC; // just make a casted alias to inClient, so we dont have to cast it
                					 // every time.
                	sassert( inClient );
                	inC = VERT( inClient );
                
                	// These are the attributes that will be averaged.
                	QUARD_TYPE ax, ay, az;
                //	QUARD_TYPE au, av;
                	//NORMAL_TYPE anx, any, anz; // normals
                	ax = ay = az = 0.0;
                //	au = av = 0.0;
                	//anx = any = anz = 0.0;
                	Color col;
                
                	// Loop through each affect vertex and add all the attributes
                	// (scaled by affectAmount) to the averaged attributes.
                	int i=0;
                	// if the prog seg-faults on the next line, chances are you are calling this
                	// rule on a non-vertex entity!
                	for( i=0; i<=3; i++ ) // while there is another affectVertex
                	{
                		if( inC->affectVertex[i] == NULL ){ break; }
                		ax += inC->affectAmount[i] * VERT(inC->affectVertex[i])->trueVertex.x;
                		ay += inC->affectAmount[i] * VERT(inC->affectVertex[i])->trueVertex.y;
                		az += inC->affectAmount[i] * VERT(inC->affectVertex[i])->trueVertex.z;
                	//	au += inC->affectAmount[i] * VERT(inC->affectVertex[i])->u;
                	//	av += inC->affectAmount[i] * VERT(inC->affectVertex[i])->v;
                
                		col.red += inC->affectAmount[i] * VERT(inC->affectVertex[i])->trueVertex.red;
                		col.green += inC->affectAmount[i] * VERT(inC->affectVertex[i])->trueVertex.green;
                		col.blue += inC->affectAmount[i] * VERT(inC->affectVertex[i])->trueVertex.blue;
                
                
                	}
                	// now set the client attributes to the averaged attributes.
                	if( i > 0 ) // but only if there were any affect verticies.
                	{
                		VERT(inC)->trueVertex.x = ax;
                		VERT(inC)->trueVertex.y = ay;
                		VERT(inC)->trueVertex.z = az;
                
                		VERT(inC)->trueVertex.red = col.red;
                		VERT(inC)->trueVertex.green = col.green;
                		VERT(inC)->trueVertex.blue = col.blue;
                	//	VERT(inC)->u = au;
                	//	VERT(inC)->v = av;
                
                		inC->bound.x = ax;
                		inC->bound.y = ay;
                		inC->bound.z = az;
                
                		//VERT(inC)->startMorphVertex = VERT(inC)->trueVertex;
                		//VERT(inC)->startMorphVertex.nx = anx;
                		//VERT(inC)->startMorphVertex.ny = any;
                		//VERT(inC)->startMorphVertex.nz = anz;
                	}
           1 -> }
           1 -> 
                #endif
                


Top 10 Lines:

     Line      Count

       42      17555
       22          3
       35          3
      100          1
      101          1

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

    17563   Total number of line executions
  2509.00   Average executions per line
